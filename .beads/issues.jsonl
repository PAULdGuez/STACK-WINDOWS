{"id":"StackWindowsElectron-0bd","title":"Fix: clicking active window in stack should always bring it to foreground","description":"## Files\n- src/renderer/index.html (modify)\n- src/main/main.js (modify)\n- src/main/window-manager.js (modify)\n\n## Bug\nWhen the user clicks on the ACTIVE window in a managed stack, nothing happens because:\n1. Renderer guard: `if (win.hwnd !== activeHwnd)` skips the call entirely\n2. WindowManager guard: `if (this.activeHwnd === hwndNum) return false` in promoteToActive()\n\nThis is a problem with multi-instance usage: window A is active in stack 1, window B is active in stack 2. User clicks window A in stack 1's UI — but A is behind B on screen. The click does nothing because A is 'already active' in that stack.\n\n## What to do\n\n### 1. In src/main/window-manager.js — modify promoteToActive()\n\nChange the early return when already active. Instead of returning false, still call SetForegroundWindow when forceNativeForeground is true:\n\n```js\npromoteToActive(hwnd, forceNativeForeground = false) {\n  const hwndNum = Number(hwnd);\n  const idx = this.managedWindows.findIndex(w =\u003e w.hwnd === hwndNum);\n  if (idx === -1) return false;\n\n  if (this.activeHwnd === hwndNum) {\n    // Already active in our stack, but may be behind other windows.\n    // If explicitly requested, bring to foreground anyway.\n    if (forceNativeForeground) {\n      if (api.IsIconic(hwndNum)) {\n        api.ShowWindow(hwndNum, SW_RESTORE);\n      }\n      api.SetForegroundWindow(hwndNum);\n    }\n    return false; // Still return false — no layout change needed\n  }\n\n  this.activeHwnd = hwndNum;\n\n  if (api.IsIconic(hwndNum)) {\n    api.ShowWindow(hwndNum, SW_RESTORE);\n  }\n\n  if (forceNativeForeground) {\n    api.SetForegroundWindow(hwndNum);\n  }\n\n  return true;\n}\n```\n\n### 2. In src/renderer/index.html — remove the activeHwnd guard on click\n\nIn renderManaged(), both the UPDATE branch (line ~651) and CREATE branch (line ~649), change the item.onclick handler from:\n\n```js\nitem.onclick = async () =\u003e {\n  if (win.hwnd !== activeHwnd) {\n    await activateWindow(win.hwnd);\n  }\n};\n```\n\nTo:\n\n```js\nitem.onclick = async () =\u003e {\n  await activateWindow(win.hwnd);\n};\n```\n\nRemove the `if (win.hwnd !== activeHwnd)` guard entirely. The backend handles the 'already active' case gracefully now.\n\n### 3. In src/main/main.js — always call SetForegroundWindow in activate-window handler\n\nChange the activate-window IPC handler so it always brings the window to foreground, even if promoteToActive returns false:\n\n```js\nipcMain.handle('activate-window', async (event, hwnd) =\u003e {\n  try {\n    const changed = windowManager.promoteToActive(hwnd, true);\n    if (changed) {\n      syncMonitor();\n      doLayout();\n      sendStateUpdate();\n      persistence.save(windowManager.getState());\n    }\n    return { success: true };\n  } catch (e) {\n    console.error('activate-window error:', e);\n    return { success: false, error: e.message };\n  }\n});\n```\n\nActually this handler already passes `true` for forceNativeForeground, so with the fix in step 1, it will call SetForegroundWindow even when already active. No change needed here — the fix in step 1 is sufficient.\n\n## Don't\n- Don't change the return value semantics of promoteToActive — it still returns false when already active (no layout change needed)\n- Don't change the ForegroundMonitor behavior\n- Don't change any other IPC handlers","acceptance_criteria":"1. Clicking the ACTIVE window in a stack calls activateWindow() (no guard skip)\n2. promoteToActive(hwnd, true) calls SetForegroundWindow even when hwnd is already activeHwnd\n3. promoteToActive(hwnd, false) still returns false and does nothing when already active (ForegroundMonitor path unchanged)\n4. promoteToActive still returns false when already active (no unnecessary layout recalc)\n5. Clicking an inactive window still works as before (promotes + layout + foreground)\n6. node --check passes on all three files","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-24T03:50:24Z","created_by":"unknown","updated_at":"2026-02-24T03:52:55Z","closed_at":"2026-02-24T03:52:55Z","close_reason":"1e8543d fix: clicking active window in stack always brings it to foreground","labels":["scope:trivial"]}
{"id":"StackWindowsElectron-17p","title":"Epic: Improve window transition animation system","description":"## Goals\nThis epic improves the Win32 window transition animation system in StackWindowsElectron. The current system uses a 200ms/12-frame setInterval-based animation with cubic ease-out to move real OS windows via DeferWindowPos. While functional, it has several issues:\n\n1. **Timing fragility**: setInterval at 16.67ms in Node.js is not guaranteed to fire on time, causing frame drops and choppy motion\n2. **No animation on removal**: removeWindow() and restoreAll() snap windows instantly, jarring contrast with smooth add/activate\n3. **Redundant Z-order work**: Every animation frame re-issues HWND_TOP for all windows, causing potential flicker\n4. **Rapid trigger jank**: Fast Alt-Tab restarts animation from scratch each time, resetting the 200ms duration\n5. **No CSS transitions in renderer**: Managed window list re-renders with innerHTML='', causing visual jumps\n6. **Stale code comments**: Comments claim no activate-window handler exists, but one does (line 165 main.js)\n\n## Success Criteria\n- Animation uses timestamp-based progress (performance.now/Date.now) instead of frame counting\n- Window removal is animated (slide back to original position)\n- Intermediate animation frames use SWP_NOZORDER to reduce flicker\n- Rapid layout triggers are debounced to prevent animation restart jank\n- Managed window list in renderer has CSS enter/exit transitions\n- All stale comments are corrected\n\n## Key Constraints\n- Must remain pure vanilla JS (no frameworks, no TypeScript)\n- Must not break existing Win32 FFI bridge (koffi/user32.dll)\n- Animation must remain in Electron main process (no requestAnimationFrame available)\n- Must maintain backward compatibility with persistence format v2\n- All changes must be testable by running the app and managing 2-3 windows","status":"closed","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-22T04:31:19Z","created_by":"unknown","updated_at":"2026-02-25T17:15:32Z","closed_at":"2026-02-25T17:15:32Z","close_reason":"Closed","labels":["needs-integration-review","scope:medium"]}
{"id":"StackWindowsElectron-17p.1","title":"Refactor _animateLayout to use timestamp-based progress instead of frame counting","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nReplace the current setInterval + frame-counting animation engine in _animateLayout() (lines 237-339) with a timestamp-based approach using setTimeout recursion and Date.now() (or process.hrtime).\n\nCurrent implementation:\n- Uses setInterval at 1000/60 (~16.67ms)\n- Counts frames: currentFrame++ up to TOTAL_FRAMES (12)\n- Progress = currentFrame / TOTAL_FRAMES\n- Problem: if setInterval fires late, frames bunch up or get skipped\n\nNew implementation:\n- Record startTime = Date.now() at animation start\n- Use recursive setTimeout (not setInterval) for each frame\n- Calculate progress = (Date.now() - startTime) / DURATION\n- Clamp progress to [0, 1]\n- Keep the same easing function: ease = 1 - Math.pow(1 - progress, 3)\n- Keep the same DeferWindowPos batching logic\n- Keep the same final snap logic when progress \u003e= 1\n- Keep the same error handling / fallback to instant SetWindowPos\n- Change _stopAnimation() to use clearTimeout instead of clearInterval\n- Rename _animationInterval to _animationTimer for clarity\n\nThe DURATION constant (200ms) and easing function must NOT change. Only the timing mechanism changes.\n\n## Don't\n- Don't change the easing function\n- Don't change the DeferWindowPos/BeginDeferWindowPos/EndDeferWindowPos API calls\n- Don't change the layoutStack() method\n- Don't change the final snap logic\n- Don't add any new dependencies\n- Don't use requestAnimationFrame (not available in main process)","acceptance_criteria":"1. _animateLayout uses Date.now() to compute progress as (elapsed / DURATION)\n2. Uses recursive setTimeout instead of setInterval\n3. _stopAnimation uses clearTimeout\n4. Animation still completes in ~200ms with cubic ease-out\n5. Final snap to exact target positions still occurs\n6. Error fallback to instant SetWindowPos still works\n7. App launches without errors and window transitions animate smoothly when switching between 2+ managed windows","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-22T04:31:35Z","created_by":"unknown","updated_at":"2026-02-22T04:39:34Z","closed_at":"2026-02-22T04:39:34Z","close_reason":"9bf0eb5 Refactor _animateLayout to use timestamp-based progress via recursive setTimeout and Date.now()","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.1","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:31:35Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.2","title":"Add animated window removal with slide-to-original-position effect","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nCurrently _restoreWindow() (lines 420-434) uses a single SetWindowPos call to instantly snap a removed window back to its original position. This is jarring compared to the smooth add/activate animations.\n\nCreate a new method _animateRestore(entry, callback) that:\n1. Gets the window's current position via GetWindowRect\n2. Computes target position from entry.originalRect (same logic as current _restoreWindow)\n3. Runs a standalone animation (NOT using _animateLayout, because that would conflict with the main layout animation) using the same timestamp-based approach from task 1\n4. Uses a SEPARATE timer reference (e.g. this._restoreAnimationTimer) so it doesn't cancel the main layout animation\n5. Duration: 250ms (slightly longer than layout animation for visual distinction)\n6. Easing: same cubic ease-out\n7. Uses single SetWindowPos per frame (not DeferWindowPos, since it's only one window)\n8. On the final frame, sets HWND_NOTOPMOST (same as current _restoreWindow)\n9. Calls callback() when animation completes (so removeWindow can chain doLayout after)\n\nModify removeWindow() (lines 150-164):\n- Instead of calling this._restoreWindow(entry), call this._animateRestore(entry, () =\u003e {})\n- The doLayout() call in main.js (line 155) already handles re-laying out remaining windows\n\nModify restoreAll() (lines 222-228):\n- Keep using instant _restoreWindow for restoreAll (app quit scenario - no time for animation)\n- Add a comment explaining why restoreAll stays instant\n\nAdd _stopRestoreAnimation() method similar to _stopAnimation() but for the restore timer.\nCall _stopRestoreAnimation() at the beginning of _animateRestore() to cancel any in-flight restore.\n\n## Don't\n- Don't modify _animateLayout or layoutStack\n- Don't use DeferWindowPos for single-window restore animation\n- Don't animate restoreAll() (app is quitting, no time)\n- Don't change the persistence format\n- Don't change the originalRect storage logic","acceptance_criteria":"1. removeWindow() triggers a smooth 250ms animation sliding the window back to its originalRect position\n2. The animation uses cubic ease-out easing\n3. The animation uses HWND_NOTOPMOST on the final frame\n4. restoreAll() still uses instant snap (no animation)\n5. A separate timer (_restoreAnimationTimer) is used, not conflicting with _animationTimer\n6. Remaining managed windows re-layout correctly after removal animation\n7. Removing a window while another removal is animating cancels the first and starts the new one\n8. App launches without errors; removing a window from a 3-window stack shows smooth slide-out","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":50,"created_at":"2026-02-22T04:31:52Z","created_by":"unknown","updated_at":"2026-02-22T04:44:44Z","closed_at":"2026-02-22T04:44:44Z","close_reason":"585b136 Add animated window removal with slide-to-original-position effect","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.2","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:31:51Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-17p.2","depends_on_id":"StackWindowsElectron-17p.1","type":"blocks","created_at":"2026-02-21T22:33:22Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.3","title":"Add SWP_NOZORDER flag to intermediate animation frames","description":"## Files\n- src/main/window-manager.js (modify)\n- src/main/win32.js (verify SWP_NOZORDER is exported — it already is at line 47/69)\n\n## What to do\nIn _animateLayout(), every animation frame calls DeferWindowPos with HWND_TOP, which re-issues a Z-order change for every window on every frame. This is redundant and can cause flicker on some systems.\n\nModify the animation loop in _animateLayout():\n1. On the FIRST frame (progress close to 0 or first iteration): use HWND_TOP and the existing flags (set Z-order)\n2. On INTERMEDIATE frames (not first, not last): add SWP_NOZORDER to the flags passed to DeferWindowPos, and pass 0 (or any value, it's ignored with SWP_NOZORDER) for hWndInsertAfter\n3. On the FINAL frame (the snap at the end): use HWND_TOP without SWP_NOZORDER (re-assert Z-order)\n\nImplementation approach:\n- Import SWP_NOZORDER from win32.js (already exported, line 69)\n- Add it to the destructured imports at the top of window-manager.js (line 5-8)\n- In the animation loop, add a boolean isFirstFrame tracked by a variable\n- For intermediate frames: flags = layout.flags | SWP_NOZORDER, and use 0 as hWndInsertAfter\n- The final snap block (lines 317-327) already uses HWND_TOP, keep it as-is\n\n## Don't\n- Don't change the first frame behavior (must set Z-order on first frame)\n- Don't change the final snap behavior\n- Don't change the easing or timing\n- Don't modify win32.js (SWP_NOZORDER is already exported)\n- Don't change layoutStack()","acceptance_criteria":"1. SWP_NOZORDER is imported in window-manager.js destructured imports\n2. First animation frame uses HWND_TOP without SWP_NOZORDER (sets Z-order)\n3. Intermediate frames (not first, not last) include SWP_NOZORDER in flags\n4. Final snap frame uses HWND_TOP without SWP_NOZORDER\n5. App launches without errors; switching between 3 managed windows animates without visible flicker\n6. Z-order is correct: active window on top, inactive windows behind in strip order","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-22T04:32:06Z","created_by":"unknown","updated_at":"2026-02-22T04:42:47Z","closed_at":"2026-02-22T04:42:47Z","close_reason":"7450107 Add SWP_NOZORDER flag to intermediate animation frames","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.3","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:32:06Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-17p.3","depends_on_id":"StackWindowsElectron-17p.1","type":"blocks","created_at":"2026-02-21T22:33:22Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.4","title":"Add debounce to doLayout to prevent animation restart jank on rapid triggers","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nCurrently, doLayout() (lines 75-88) is called directly from multiple triggers: foreground monitor (every 200ms), add-window, remove-window, activate-window, resize, and dead-window cleanup. When the user rapidly Alt-Tabs between managed windows, multiple doLayout() calls can fire within a single 200ms animation duration, causing _animateLayout to restart from scratch each time (jerky motion).\n\nAdd a debounce wrapper around doLayout:\n1. Create a module-level variable: let _layoutDebounceTimer = null;\n2. Create a new function doLayoutDebounced() that:\n   - Clears any pending _layoutDebounceTimer\n   - Sets _layoutDebounceTimer = setTimeout(() =\u003e { doLayout(); }, 16) — 16ms debounce (one frame at 60fps)\n   - This coalesces multiple rapid calls into a single layout pass\n3. Replace doLayout() calls with doLayoutDebounced() in these specific locations:\n   - onManagedWindowFocused (line 103) — this is the main rapid-fire source\n   - The cleanup timer callback (line 298)\n4. Keep doLayout() (NOT debounced) for these locations where immediate response is needed:\n   - add-window IPC handler (line 141) — user explicitly added, should respond immediately\n   - remove-window IPC handler (line 155) — user explicitly removed\n   - activate-window IPC handler (line 170) — user explicitly clicked\n   - resize event (line 49) — window is being resized, needs immediate feedback\n   - Initial layout setTimeout (line 289) — startup, only fires once\n5. Clean up _layoutDebounceTimer in the window-all-closed handler (line 312)\n\n## Don't\n- Don't modify window-manager.js\n- Don't modify foreground-monitor.js\n- Don't change the debounce delay to more than 50ms (would introduce perceptible lag)\n- Don't debounce the user-initiated actions (add, remove, activate, resize)\n- Don't use any external debounce library","acceptance_criteria":"1. A doLayoutDebounced() function exists that debounces with ~16ms delay\n2. onManagedWindowFocused uses doLayoutDebounced() instead of doLayout()\n3. Dead window cleanup timer uses doLayoutDebounced()\n4. add-window, remove-window, activate-window IPC handlers still use direct doLayout()\n5. resize event still uses direct doLayout()\n6. _layoutDebounceTimer is cleared in window-all-closed handler\n7. App launches without errors; rapid Alt-Tab between 3 managed windows produces smooth animation without visible jank/restart","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-22T04:32:20Z","created_by":"unknown","updated_at":"2026-02-22T04:39:25Z","closed_at":"2026-02-22T04:39:25Z","close_reason":"41be2f3 Add debounce to doLayout to prevent animation restart jank","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.4","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:32:20Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.5","title":"Make animation duration and easing configurable via constructor options","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nCurrently DURATION (200ms) and the easing function are hardcoded inside _animateLayout(). Extract them as configurable options on the WindowManager class for future flexibility and easier tuning.\n\n1. Add an options parameter to the WindowManager constructor with defaults:\n   constructor(options = {}) {\n     // ... existing code ...\n     this.animationDuration = options.animationDuration || 200;  // ms\n     this.animationEasing = options.animationEasing || 'ease-out-cubic';\n     this.restoreAnimationDuration = options.restoreAnimationDuration || 250; // ms\n   }\n\n2. Create a private method _applyEasing(progress) that maps a string name to an easing function:\n   - 'ease-out-cubic': 1 - Math.pow(1 - progress, 3)  (current default)\n   - 'ease-in-out-cubic': progress \u003c 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2\n   - 'linear': progress\n   Returns the eased value.\n\n3. In _animateLayout(), replace:\n   - const DURATION = 200; → use this.animationDuration\n   - const ease = 1 - Math.pow(1 - progress, 3); → const ease = this._applyEasing(progress);\n\n4. In _animateRestore() (from task 2, if it exists; otherwise in _restoreWindow), use this.restoreAnimationDuration.\n\n5. Do NOT change the default values — the app should behave identically with no options passed.\n\n## Don't\n- Don't change default behavior (200ms ease-out-cubic must remain the default)\n- Don't add more than 3 easing options\n- Don't expose these options via IPC or the renderer UI (internal only for now)\n- Don't change the persistence format\n- Don't modify main.js (it passes no options, gets defaults)","acceptance_criteria":"1. WindowManager constructor accepts an optional options object\n2. this.animationDuration defaults to 200 if not specified\n3. this.animationEasing defaults to 'ease-out-cubic' if not specified\n4. this.restoreAnimationDuration defaults to 250 if not specified\n5. _applyEasing('ease-out-cubic', 0.5) returns 1 - Math.pow(0.5, 3) = 0.875\n6. _applyEasing('linear', 0.5) returns 0.5\n7. _applyEasing('ease-in-out-cubic', 0.5) returns 0.5\n8. App launches without errors with no options passed to WindowManager()\n9. Animation behavior is identical to before (same duration, same easing)","status":"closed","priority":3,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-22T04:32:36Z","created_by":"unknown","updated_at":"2026-02-22T04:46:26Z","closed_at":"2026-02-22T04:46:26Z","close_reason":"f33cb7e Make animation duration and easing configurable via constructor options","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.5","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:32:35Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-17p.5","depends_on_id":"StackWindowsElectron-17p.1","type":"blocks","created_at":"2026-02-21T22:33:23Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-17p.5","depends_on_id":"StackWindowsElectron-17p.2","type":"blocks","created_at":"2026-02-21T22:33:24Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.6","title":"Add CSS transitions to managed window list in renderer","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\nCurrently renderManaged() (lines 505-563) destroys and recreates all DOM elements on every update via container.innerHTML = ''. This causes the list to 'jump' visually with no transition. Add smooth CSS transitions for managed window list items.\n\n### CSS Changes (add to the \u003cstyle\u003e block):\n1. Add transition to .managed-item for border-left-color and background:\n   .managed-item {\n     transition: border-left-color 0.2s ease, background-color 0.2s ease;\n   }\n\n2. Add a fade-in animation for new items:\n   @keyframes fadeSlideIn {\n     from { opacity: 0; transform: translateX(-8px); }\n     to { opacity: 1; transform: translateX(0); }\n   }\n   .window-item.entering {\n     animation: fadeSlideIn 0.2s ease forwards;\n   }\n\n### JavaScript Changes to renderManaged():\nReplace the current 'destroy all and recreate' approach with a DOM-diffing strategy:\n\n1. Build a Map of existing DOM items keyed by hwnd (data-hwnd attribute)\n2. Build the new desired list of hwnds from managedWindows\n3. For each window in managedWindows:\n   a. If a DOM element with matching data-hwnd exists: UPDATE it in place (change classes, badge text, etc.)\n   b. If no matching DOM element exists: CREATE a new element with class 'entering'\n4. Remove DOM elements whose hwnd is no longer in managedWindows\n5. Reorder DOM elements to match the managedWindows array order using insertBefore\n\nEach .window-item must have a data-hwnd attribute set to the window's hwnd for identification.\n\n### Key details:\n- The 'entering' class triggers the fadeSlideIn animation\n- The active/inactive class swap triggers the CSS transition on border-left-color and background\n- Remove the 'entering' class after animation ends (use animationend event listener)\n- Keep the empty state rendering (innerHTML for empty state is fine)\n\n## Don't\n- Don't use any framework or virtual DOM library\n- Don't change the visual appearance of items (colors, sizes, fonts must stay the same)\n- Don't modify the available windows list rendering (only managed list)\n- Don't change the IPC communication\n- Don't add transitions longer than 300ms","acceptance_criteria":"1. Managed window items have data-hwnd attributes\n2. When active window changes, the border-left-color and background transition smoothly (0.2s)\n3. When a new window is added to the stack, it fades/slides in from the left\n4. When a window is removed from the stack, its DOM element is removed (no exit animation required)\n5. DOM elements are reused when possible (not destroyed and recreated on every update)\n6. Empty state still renders correctly when all windows are removed\n7. The 'entering' class is removed after animation completes\n8. App launches without errors; adding/removing/switching windows shows smooth list transitions","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-22T04:32:51Z","created_by":"unknown","updated_at":"2026-02-22T04:40:24Z","closed_at":"2026-02-22T04:40:24Z","close_reason":"3f1a10b Add CSS transitions and DOM-diffing to managed window list","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.6","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:32:51Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.7","title":"Fix stale comments about activate-window IPC handler","description":"## Files\n- src/main/main.js (modify)\n- src/renderer/index.html (modify)\n\n## What to do\nThere are stale/contradictory comments in the codebase about the activate-window IPC handler:\n\n### main.js fixes:\n1. Line 109-110: Comment says 'Register IPC handlers — NO activate-window handler. Activation is driven by Win32 focus detection, not Electron.'\n   But line 165 registers an 'activate-window' handler that calls promoteToActive(hwnd, true).\n   \n   Replace the comment at lines 109-110 with:\n   // Register IPC handlers.\n   // Activation is primarily driven by Win32 focus detection (ForegroundMonitor),\n   // but an activate-window handler also exists for explicit UI-driven activation.\n\n2. Line 96-99: Comment says 'Called by ForegroundMonitor when a managed window gains OS focus. This is the ONLY activation path — driven by real Win32 focus, not Electron UI.'\n   This is false — the activate-window IPC handler (line 165) is another activation path.\n   \n   Replace with:\n   // Called by ForegroundMonitor when a managed window gains OS focus.\n   // This is the primary activation path. A secondary path exists via the\n   // 'activate-window' IPC handler for explicit UI-driven activation.\n\n### index.html fixes:\n1. Line 603: Comment says '// API calls — NO activateWindow. Activation is Win32-driven.'\n   But activateWindow() function exists at line 678 and is called from line 524.\n   \n   Replace with:\n   // API calls — activation is primarily Win32-driven, with UI fallback via activateWindow().\n\n## Don't\n- Don't change any code logic, only comments\n- Don't add new comments beyond what's specified\n- Don't reformat or restructure the code\n- Don't change any function signatures or behavior","acceptance_criteria":"1. Comment at main.js line 109-110 accurately describes that activate-window handler exists\n2. Comment at main.js line 96-99 mentions both activation paths (foreground monitor + IPC)\n3. Comment at index.html line 603 acknowledges activateWindow() exists\n4. No code logic changes — only comment text changes\n5. App launches without errors","status":"closed","priority":3,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-22T04:33:06Z","created_by":"unknown","updated_at":"2026-02-22T04:39:51Z","closed_at":"2026-02-22T04:39:51Z","close_reason":"5db73cd Fix stale comments about activate-window IPC handler","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.7","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:33:06Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.8","title":"Add animation-in-progress guard to prevent layout calls during active animation","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nCurrently _animateLayout() always cancels any in-progress animation and starts fresh. While the debounce in main.js (task 4) reduces the frequency of calls, there's still a case where layoutStack() is called while an animation is running and the new target positions are identical to the current targets (e.g., dead window cleanup finds no changes but doLayout still fires).\n\nAdd an optimization to skip redundant animations:\n\n1. Add a property this._currentTargets = null in the constructor\n2. At the start of _animateLayout(targetLayouts), before calling _stopAnimation():\n   - Serialize the target layouts into a comparable key: targetLayouts.map(t =\u003e t.hwnd + ':' + t.x + ',' + t.y + ',' + t.cx + ',' + t.cy).join('|')\n   - Compare with this._currentTargets\n   - If identical AND an animation is currently running (this._animationTimer !== null), return early (skip — already animating to these targets)\n3. If different or no animation running, proceed as normal and store the new key in this._currentTargets\n4. In _stopAnimation(), set this._currentTargets = null (animation completed, targets are reached)\n\nThis prevents unnecessary animation restarts when the target layout hasn't actually changed.\n\n## Don't\n- Don't skip animation when targets have changed (only skip when identical)\n- Don't modify layoutStack()\n- Don't modify main.js\n- Don't add any external dependencies\n- Don't change the animation timing or easing","acceptance_criteria":"1. this._currentTargets is initialized to null in constructor\n2. _animateLayout skips (returns early) when called with identical targets while animation is running\n3. _animateLayout proceeds normally when targets differ from current animation\n4. _animateLayout proceeds normally when no animation is running (even with same targets)\n5. _stopAnimation resets this._currentTargets to null\n6. App launches without errors; switching between windows still animates correctly\n7. Console.log or lack of animation restart confirms redundant calls are skipped","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-22T04:33:18Z","created_by":"unknown","updated_at":"2026-02-22T04:42:12Z","closed_at":"2026-02-22T04:42:12Z","close_reason":"a300a9b Add animation-in-progress guard to prevent redundant layout calls","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.8","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:33:18Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-17p.8","depends_on_id":"StackWindowsElectron-17p.1","type":"blocks","created_at":"2026-02-21T22:33:24Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-3go","title":"Epic: Fix custom dimensions, fix Hide behavior, add background color picker","description":"Tres problemas a resolver: (1) Custom dimensions no tiene efecto visible - el IPC funciona pero el layout no refleja los cambios porque setCustomDimensions recibe los valores correctamente y doLayout se llama, pero el problema es que availableWidth ya es menor o igual al customWidth solicitado, o hay un issue con el flujo. Necesita debugging y fix. (2) El boton Hide oculta la lista de managed windows ademas de available windows - solo deberia ocultar available windows. (3) Agregar un boton de color picker para cambiar el color de fondo de la pila administrativa, persistente entre sesiones.","status":"closed","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-20T23:38:55Z","created_by":"unknown","updated_at":"2026-02-25T17:15:28Z","closed_at":"2026-02-25T17:15:28Z","close_reason":"Closed","labels":["scope:medium"]}
{"id":"StackWindowsElectron-3go.1","title":"Fix custom dimensions sin efecto - debug y corregir layoutStack","description":"## Files\n- src/main/window-manager.js (modify)\n- src/main/main.js (modify) - posiblemente para agregar logging\n\n## What to do\nEl flujo IPC funciona: set-custom-dimensions llama setCustomDimensions(), luego doLayout(), pero las ventanas no cambian de tamano. \n\n### Analisis de la causa raiz\nEn layoutStack() linea 231: startX = workArea.x + workArea.width. Aqui workArea.x es la posicion X de mainWindow (bounds.x), y workArea.width es el ancho de mainWindow. Entonces startX = borde derecho de la pila administrativa.\n\nLinea 235-238: displayRightEdge viene de main.js como workArea.x + workArea.width del DISPLAY. availableWidth = displayRightEdge - startX. Este es el espacio entre el borde derecho de la pila admin y el borde derecho del monitor.\n\nLinea 242-244: effectiveWidth = Math.min(customWidth, availableWidth). Si customWidth (ej 800) \u003c availableWidth (ej 1620), deberia usar 800.\n\nEl PROBLEMA real: effectiveWidth SI se calcula bien, pero las ventanas de Windows tienen un tamano minimo impuesto por el OS. Ademas, SetWindowPos puede estar siendo sobreescrito por el timer de cleanup (cada 2s) o el resize handler de mainWindow que llama doLayout() sin custom dims.\n\n### Verificacion y fix\n1. Agregar console.log temporal en layoutStack() para imprimir: customWidth, customHeight, availableWidth, availableHeight, effectiveWidth, effectiveHeight justo antes de los SetWindowPos calls.\n2. Verificar que setCustomDimensions realmente guarda los valores (no los pierde por un race condition).\n3. Si el problema es que doLayout se llama desde el resize handler de mainWindow y este sobreescribe, verificar que customWidth/customHeight persisten entre llamadas a layoutStack.\n4. Agregar un console.log en el IPC handler set-custom-dimensions para confirmar que los valores llegan.\n5. Una vez identificado el bug exacto, corregirlo.\n6. REMOVER los console.log de debug despues de confirmar el fix.\n\n### Posible causa alternativa\nEl resize event de mainWindow (linea 48 de main.js) llama doLayout() que a su vez llama layoutStack(). Si el usuario cambia las dimensiones y luego mueve/resize la ventana admin, se re-aplica el layout con los custom dims. Pero si NO hay un trigger de re-layout despues del set-custom-dimensions... verificar que doLayout() SI se llama en el handler IPC (linea 216 de main.js - SI se llama).\n\n## Don't\n- No cambiar la logica de IPC\n- No cambiar la UI\n- No remover la funcionalidad de custom dimensions, solo hacerla funcionar","acceptance_criteria":"1. Establecer customWidth=800 customHeight=600 via Apply en la UI y las ventanas administradas se redimensionan visiblemente a 800x600 o menos. 2. Las ventanas no vuelven a su tamano anterior despues de un ciclo de cleanup (2s). 3. Reset vuelve las ventanas al tamano completo del espacio disponible.","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-20T23:39:20Z","created_by":"unknown","updated_at":"2026-02-20T23:48:45Z","closed_at":"2026-02-20T23:48:45Z","close_reason":"a4c944c fix: restore maximized windows before SetWindowPos so custom dimensions take effect","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-3go.1","depends_on_id":"StackWindowsElectron-3go","type":"parent-child","created_at":"2026-02-20T17:39:20Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-3go.2","title":"Fix Hide button - solo debe ocultar Available Windows, no Managed Stack","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\nEl boton Hide en la seccion Available Windows actualmente oculta la lista de managed windows (pestanas de la pila administrativa) ademas de la lista de available windows. Solo debe ocultar la seccion de Available Windows.\n\n### Causa raiz\nEn toggleAvailableVisibility() (linea 439), cuando isAvailableHidden=true, se calcula un targetHeight que es demasiado pequeno. El calculo en lineas 458-483 usa querySelectorAll('.section') y asume que sections[0] es managed y sections[1] es available. PERO ahora hay 3 secciones .section (dimensions-section, managed, available), asi que los indices estan desfasados.\n\nAdemas, el calculo de targetHeight no incluye la altura de la seccion dimensions-section ni su divider.\n\n### Fix\n1. Cambiar la logica de calculo de targetHeight para que sea robusta:\n   - Sumar la altura de TODOS los elementos visibles excepto el availableList\n   - O mejor: en vez de calcular un targetHeight exacto y hacer resizeApp, simplemente ocultar la seccion completa de Available Windows (el div.section que contiene availableList) y dejar que flexbox maneje el layout naturalmente SIN hacer resizeApp\n2. Alternativa mas simple y robusta: NO llamar resizeApp al ocultar. Solo ocultar el div availableList con display:none. La ventana de Electron mantiene su tamano y el espacio se redistribuye via flexbox.\n3. Elegir la alternativa 2: solo ocultar/mostrar availableList sin redimensionar la ventana de Electron. Esto evita el bug de calculo de alturas.\n\n### Implementacion concreta\n- En toggleAvailableVisibility(), cuando isAvailableHidden=true:\n  - listEl.classList.add('hidden') (ya existe)\n  - btn.textContent = 'Show' (ya existe)\n  - ELIMINAR todo el bloque setTimeout que calcula targetHeight y llama resizeApp\n- Cuando isAvailableHidden=false:\n  - listEl.classList.remove('hidden') (ya existe)\n  - btn.textContent = 'Hide' (ya existe)  \n  - ELIMINAR la llamada a resizeApp que restaura expandedHeight\n- Eliminar la variable expandedHeight ya que no se usa mas\n- Mantener la llamada a toggleAvailableVisibility IPC para persistir el estado\n\n## Don't\n- No tocar la seccion Managed Stack\n- No tocar la seccion Dimensions\n- No cambiar el comportamiento de persistencia del estado hideAvailable","acceptance_criteria":"1. Al hacer clic en Hide, solo se oculta la lista de Available Windows. La lista de Managed Stack (pestanas) sigue visible. 2. Al hacer clic en Show, la lista de Available Windows reaparece. 3. La seccion Dimensions no se ve afectada por Hide/Show. 4. El estado hideAvailable se persiste correctamente.","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-20T23:39:37Z","created_by":"unknown","updated_at":"2026-02-20T23:41:02Z","closed_at":"2026-02-20T23:41:02Z","close_reason":"5d63289 Fix Hide button - remove resizeApp from toggleAvailableVisibility","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-3go.2","depends_on_id":"StackWindowsElectron-3go","type":"parent-child","created_at":"2026-02-20T17:39:36Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-3go.3","title":"Agregar color picker para fondo de la pila administrativa","description":"## Files\n- src/renderer/index.html (modify)\n- src/main/window-manager.js (modify)\n- src/main/main.js (modify)\n- src/main/preload.js (modify)\n- src/main/persistence.js (modify)\n\n## What to do\nAgregar un boton en el header de la pila administrativa que abra un color picker nativo del navegador (input type=color) para elegir el color de fondo de la app. El color debe persistir entre sesiones.\n\n### window-manager.js\n- Agregar this.backgroundColor = '#000000' al constructor (negro por defecto, el color actual)\n- Agregar setBackgroundColor(color): valida que sea un string hex valido (#RRGGBB), guarda en this.backgroundColor\n- Agregar getBackgroundColor(): retorna this.backgroundColor\n- Incluir backgroundColor en getState()\n- Leer backgroundColor en loadState() con fallback a '#000000'\n\n### persistence.js\n- En save(): agregar backgroundColor: state.backgroundColor || '#000000'\n- En load() v2: agregar backgroundColor: data.backgroundColor || '#000000'\n- En load() v1 migration: agregar backgroundColor: '#000000'\n\n### main.js\n- Agregar IPC handler 'set-background-color': llama windowManager.setBackgroundColor(color), sendStateUpdate(), persistence.save()\n- Agregar IPC handler 'get-background-color': retorna windowManager.getBackgroundColor()\n- En sendStateUpdate(): incluir backgroundColor en el objeto enviado\n- En get-managed-windows handler: incluir backgroundColor\n\n### preload.js\n- Exponer setBackgroundColor: (color) =\u003e ipcRenderer.invoke('set-background-color', color)\n- Exponer getBackgroundColor: () =\u003e ipcRenderer.invoke('get-background-color')\n\n### index.html\n- En el header div, agregar un boton pequeno (icono de paleta o cuadrado de color) al lado derecho del titulo\n- Al hacer clic, abrir un input type=color oculto (trigger via click programatico)\n- Al seleccionar un color (evento change del input), llamar window.electronAPI.setBackgroundColor(color) y aplicar document.body.style.backgroundColor = color\n- En onStateUpdate: si data.backgroundColor, aplicar document.body.style.backgroundColor = data.backgroundColor\n- En refreshManaged (init): si result.backgroundColor, aplicar el color\n- CSS del boton: cuadrado de 16x16px con borde #444, el background del boton es el color actual, posicionado en el header con float right o flex\n\n## Don't\n- No usar librerias externas de color picker, usar el nativo input type=color\n- No cambiar el color de texto (solo el fondo)\n- No afectar el color de las ventanas administradas (solo la UI de la pila admin)","acceptance_criteria":"1. Un boton de color aparece en el header de la app. 2. Al hacer clic se abre el color picker nativo del OS. 3. Al elegir un color, el fondo de la app cambia inmediatamente. 4. El color persiste al reiniciar la app. 5. El color por defecto es negro (#000000).","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":40,"created_at":"2026-02-20T23:39:52Z","created_by":"unknown","updated_at":"2026-02-20T23:42:31Z","closed_at":"2026-02-20T23:42:31Z","close_reason":"a3f4331 Add background color picker to admin stack header","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-3go.3","depends_on_id":"StackWindowsElectron-3go","type":"parent-child","created_at":"2026-02-20T17:39:51Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-48q","title":"Epic: Cross-stack window toggle — click active window to switch back to previous stack","description":"## Goals\nWhen the user clicks on a window that is ALREADY the active window in its stack, instead of doing a useless 'refresh' (SetForegroundWindow on the same window), the app should bring to the foreground the last active window from ANOTHER stack instance. This creates a quick toggle between stacks without moving the mouse.\n\n## Scenario\n1. Stack 1: window A active, window C inactive\n2. Stack 2: window B active, window D inactive\n3. User clicks window A in Stack 1 panel → sees window A (normal activation)\n4. User clicks window B in Stack 2 panel → sees window B (normal activation)\n5. User clicks window B again (already active) → **should show window A from Stack 1** (toggle back)\n6. User clicks window B again → **should show window A again** (it was the last cross-stack active)\n\n## Current Problem\n- When clicking an already-active window, promoteToActive() returns false and just calls SetForegroundWindow on the same window — a useless refresh\n- There is no cross-instance communication about which window was last active\n- The instance-registry.json only stores managedHwnds per instance, not activeHwnd\n\n## What Success Looks Like\n1. instance-registry.json stores activeHwnd + lastActivatedAt per instance\n2. When clicking an already-active window, the app reads the registry, finds the most recently activated window from another instance, and brings it to the foreground\n3. The toggle feels instant — no visible delay\n4. Works correctly with 2+ simultaneous stack instances\n\n## Key Constraints\n- Must not break single-instance usage (no other instance = normal refresh behavior)\n- Registry reads must be fast (it is a small JSON file)\n- Must not introduce new IPC channels between instances — use the shared file\n- Must remain vanilla JS","status":"closed","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-24T23:07:13Z","created_by":"unknown","updated_at":"2026-02-25T03:32:10Z","closed_at":"2026-02-25T03:32:10Z","close_reason":"Closed","labels":["scope:small"]}
{"id":"StackWindowsElectron-48q.1","title":"Store activeHwnd and lastActivatedAt in instance registry","description":"## Files\n- src/main/instance-registry.js (modify)\n\n## What to do\nAdd two new methods and modify the registry data structure to track which window is active per instance and when it was last activated.\n\n### 1. Add updateActiveHwnd(hwnd) method (after updateManagedHwnds, ~line 149):\nThis method writes the activeHwnd and a timestamp to the registry immediately (NO debounce — this must be instant for cross-instance reads).\n\n```js\n/**\n * Update the activeHwnd for this instance in the registry.\n * Written immediately (no debounce) so other instances can read it.\n * @param {number} hwnd - The currently active window handle (0 if none)\n */\nupdateActiveHwnd(hwnd) {\n  try {\n    const registry = this._readRegistry();\n    if (registry.instances[this.instanceId]) {\n      registry.instances[this.instanceId].activeHwnd = hwnd;\n      registry.instances[this.instanceId].lastActivatedAt = Date.now();\n      this._writeRegistry(registry);\n    }\n  } catch (e) {\n    console.error('InstanceRegistry: failed to update activeHwnd:', e);\n  }\n}\n```\n\n### 2. Add getLastActiveHwndFromOtherInstances() method (after getOtherInstancesHwnds, ~line 192):\nThis method reads the registry and returns the activeHwnd from the OTHER instance that was most recently activated. Returns 0 if no other instance has an active window.\n\n```js\n/**\n * Get the most recently activated window handle from OTHER instances.\n * Used for cross-stack toggle: when clicking an already-active window,\n * switch to the last active window from another stack.\n * @returns {number} The hwnd of the most recently active window from another instance, or 0\n */\ngetLastActiveHwndFromOtherInstances() {\n  try {\n    const registry = this._readRegistry();\n    let bestHwnd = 0;\n    let bestTime = 0;\n    for (const [id, entry] of Object.entries(registry.instances)) {\n      if (id === this.instanceId) continue;\n      if (!this._isPidAlive(entry.pid)) continue;\n      const hwnd = entry.activeHwnd || 0;\n      const time = entry.lastActivatedAt || 0;\n      if (hwnd \u003e 0 \u0026\u0026 time \u003e bestTime) {\n        bestHwnd = hwnd;\n        bestTime = time;\n      }\n    }\n    return bestHwnd;\n  } catch (e) {\n    console.error('InstanceRegistry: failed to get last active hwnd from other instances:', e);\n    return 0;\n  }\n}\n```\n\n### 3. Update _register() (~line 51):\nAdd activeHwnd: 0 and lastActivatedAt: 0 to the initial registration data:\n```js\nregistry.instances[this.instanceId] = {\n  pid: process.pid,\n  startedAt: new Date().toISOString(),\n  managedHwnds: [],\n  activeHwnd: 0,\n  lastActivatedAt: 0\n};\n```\n\n## Don't\n- Don't add debounce to updateActiveHwnd — it must be synchronous/immediate\n- Don't modify updateManagedHwnds or any existing methods\n- Don't modify any other files\n- Don't prune dead instances inside getLastActiveHwndFromOtherInstances (just skip dead PIDs with _isPidAlive check)","acceptance_criteria":"1. instance-registry.js exports InstanceRegistry with two new methods: updateActiveHwnd(hwnd) and getLastActiveHwndFromOtherInstances()\n2. updateActiveHwnd writes activeHwnd and lastActivatedAt (Date.now()) to the registry file immediately\n3. getLastActiveHwndFromOtherInstances returns the activeHwnd from the other instance with the highest lastActivatedAt, skipping dead PIDs\n4. _register() initializes activeHwnd: 0 and lastActivatedAt: 0\n5. Existing methods (updateManagedHwnds, getOtherInstancesHwnds, unregister) are unchanged\n6. node --check src/main/instance-registry.js passes","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-24T23:07:33Z","created_by":"unknown","updated_at":"2026-02-24T23:09:09Z","closed_at":"2026-02-24T23:09:09Z","close_reason":"d73c3ae Store activeHwnd and lastActivatedAt in instance registry","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-48q.1","depends_on_id":"StackWindowsElectron-48q","type":"parent-child","created_at":"2026-02-24T17:07:33Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-48q.1","depends_on_id":"StackWindowsElectron-48q.2","type":"blocks","created_at":"2026-02-24T17:07:58Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-48q.2","title":"Wire up activeHwnd registry updates and cross-stack toggle in main.js","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nTwo changes: (A) update the registry whenever the active window changes, and (B) implement the cross-stack toggle when clicking an already-active window.\n\n### A. Update registry on active window change\n\nAdd instanceRegistry.updateActiveHwnd() calls in every place where the active window changes:\n\n#### 1. In onManagedWindowFocused() (~line 150):\nAfter the existing code that runs when changed is true, add the registry update:\n```js\nfunction onManagedWindowFocused(hwnd) {\n  const changed = windowManager.promoteToActive(hwnd);\n  if (changed) {\n    doLayoutDebounced();\n    sendStateUpdate();\n    debouncedSave();\n    instanceRegistry.updateActiveHwnd(hwnd);  // \u003c-- ADD THIS\n  }\n}\n```\n\n#### 2. In the 'activate-window' IPC handler (~line 238):\nAfter the existing code that runs when changed is true, add the registry update:\n```js\nipcMain.handle('activate-window', async (event, hwnd) =\u003e {\n  try {\n    hwnd = validateHwnd(hwnd);\n    const changed = windowManager.promoteToActive(hwnd, true);\n    if (changed) {\n      syncMonitor();\n      doLayout();\n      sendStateUpdate();\n      persistence.save(windowManager.getState());\n      instanceRegistry.updateActiveHwnd(hwnd);  // \u003c-- ADD THIS\n    }\n    return { success: true };\n  } catch (e) {\n    console.error('activate-window error:', e);\n    return { success: false, error: e.message };\n  }\n});\n```\n\n#### 3. In the 'add-window' IPC handler (~line 189):\nAfter the existing persistence.save line, add:\n```js\ninstanceRegistry.updateActiveHwnd(windowManager.getActiveHwnd());  // \u003c-- ADD THIS\n```\n\n### B. Cross-stack toggle when clicking already-active window\n\nModify the 'activate-window' IPC handler to detect when the user clicks on the already-active window and toggle to the other stack's last active window.\n\nThe current code has:\n```js\nconst changed = windowManager.promoteToActive(hwnd, true);\nif (changed) { ... }\nreturn { success: true };\n```\n\nAdd an else branch after the if (changed) block:\n```js\nconst changed = windowManager.promoteToActive(hwnd, true);\nif (changed) {\n  syncMonitor();\n  doLayout();\n  sendStateUpdate();\n  persistence.save(windowManager.getState());\n  instanceRegistry.updateActiveHwnd(hwnd);\n} else {\n  // Already active — try cross-stack toggle\n  const otherHwnd = instanceRegistry.getLastActiveHwndFromOtherInstances();\n  if (otherHwnd \u003e 0) {\n    try {\n      if (api.IsWindow(otherHwnd) !== 0) {\n        api.SetForegroundWindow(otherHwnd);\n      }\n    } catch (e) {\n      // Silently ignore — other instance's window may have been closed\n    }\n  }\n}\n```\n\nNote: The api module is already imported at the top of main.js (added in a7t.1). Verify it exists: `const api = require('./win32');` — if not present, add it.\n\n### C. Also update the mainWindow.on('focus') handler (~line 104):\nAfter the SetForegroundWindow call, also update the registry so the timestamp is fresh:\n```js\nmainWindow.on('focus', () =\u003e {\n  if (!windowManager) return;\n  const activeHwnd = windowManager.getActiveHwnd();\n  if (activeHwnd \u003e 0) {\n    try {\n      if (api.IsWindow(activeHwnd) !== 0) {\n        api.SetForegroundWindow(activeHwnd);\n        instanceRegistry.updateActiveHwnd(activeHwnd);  // \u003c-- ADD THIS\n      }\n    } catch (e) {\n      // Silently ignore\n    }\n  }\n});\n```\n\n## Don't\n- Don't modify window-manager.js or instance-registry.js\n- Don't modify the renderer (index.html)\n- Don't add new IPC channels\n- Don't change the promoteToActive logic — only add the else branch\n- Don't add debounce to the registry updates in this file — updateActiveHwnd is already immediate","acceptance_criteria":"1. instanceRegistry.updateActiveHwnd(hwnd) is called in onManagedWindowFocused, activate-window handler, add-window handler, and mainWindow.on('focus')\n2. When clicking an already-active window (promoteToActive returns false), the app reads getLastActiveHwndFromOtherInstances() and calls SetForegroundWindow on it\n3. If no other instance has an active window (returns 0), nothing happens (no crash, no error)\n4. If the other instance's window is dead (IsWindow returns 0), nothing happens\n5. The cross-stack toggle works: click active window B in Stack 2 → shows window A from Stack 1\n6. Normal activation (clicking a non-active window) still works as before\n7. node --check src/main/main.js passes\n8. The app starts and runs without errors with both single and multiple instances","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-24T23:07:58Z","created_by":"unknown","updated_at":"2026-02-24T23:10:23Z","closed_at":"2026-02-24T23:10:23Z","close_reason":"494c1bb Wire up activeHwnd registry updates and cross-stack toggle in main.js","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-48q.2","depends_on_id":"StackWindowsElectron-48q","type":"parent-child","created_at":"2026-02-24T17:07:58Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-48q.3","title":"Fix cross-stack toggle: eliminate competing SetForegroundWindow calls","description":"## Problem\nThe cross-stack toggle doesn't work because three mechanisms compete:\n\n1. **promoteToActive()** in window-manager.js (line 220-225): When the window is already active AND forceNativeForeground=true, it calls SetForegroundWindow(same window) BEFORE returning false. This brings the current window to the front, defeating the toggle.\n\n2. **mainWindow.on('focus')** in main.js (line 104-117): When clicking the admin panel, this fires FIRST and calls SetForegroundWindow(activeHwnd), bringing the current stack's active window to the front before the onclick handler even runs.\n\n3. The ForegroundMonitor then detects the focus change and re-reports it, causing more noise.\n\n## Files\n- src/main/window-manager.js (modify)\n- src/main/main.js (modify)\n\n## What to do\n\n### 1. window-manager.js — promoteToActive() (~line 212-240):\nWhen the window is already active (this.activeHwnd === hwndNum), do NOT call SetForegroundWindow. Just return false and let the caller decide what to do. Change:\n\n```js\nif (this.activeHwnd === hwndNum) {\n  // Already active in our stack, but may be behind other windows.\n  // If explicitly requested, bring to foreground anyway.\n  if (forceNativeForeground) {\n    if (api.IsIconic(hwndNum)) {\n      api.ShowWindow(hwndNum, SW_RESTORE);\n    }\n    api.SetForegroundWindow(hwndNum);\n  }\n  return false;\n}\n```\n\nTo:\n```js\nif (this.activeHwnd === hwndNum) {\n  // Already active — return false so caller can decide (e.g. cross-stack toggle)\n  return false;\n}\n```\n\n### 2. main.js — mainWindow.on('focus') handler (~line 104-117):\nRemove the SetForegroundWindow call entirely. The on('focus') handler should ONLY update the registry timestamp, not bring any window to the front. This prevents it from competing with the cross-stack toggle.\n\nChange from:\n```js\nmainWindow.on('focus', () =\u003e {\n  if (!windowManager) return;\n  const activeHwnd = windowManager.getActiveHwnd();\n  if (activeHwnd \u003e 0) {\n    try {\n      if (api.IsWindow(activeHwnd) !== 0) {\n        api.SetForegroundWindow(activeHwnd);\n        instanceRegistry.updateActiveHwnd(activeHwnd);\n      }\n    } catch (e) {}\n  }\n});\n```\n\nTo:\n```js\nmainWindow.on('focus', () =\u003e {\n  if (!windowManager) return;\n  const activeHwnd = windowManager.getActiveHwnd();\n  if (activeHwnd \u003e 0) {\n    instanceRegistry.updateActiveHwnd(activeHwnd);\n  }\n});\n```\n\n### 3. main.js — activate-window IPC handler (~line 241-269):\nThe else branch is correct but needs to also bring the CURRENT window to the front when there is NO other instance to toggle to (single-instance fallback). Update the else branch:\n\n```js\n} else {\n  // Already active — try cross-stack toggle\n  const otherHwnd = instanceRegistry.getLastActiveHwndFromOtherInstances();\n  if (otherHwnd \u003e 0) {\n    try {\n      if (api.IsWindow(otherHwnd) !== 0) {\n        api.SetForegroundWindow(otherHwnd);\n      }\n    } catch (e) {\n      // Silently ignore\n    }\n  } else {\n    // No other instance — just bring current window to front (original behavior)\n    try {\n      if (api.IsWindow(hwnd) !== 0) {\n        api.SetForegroundWindow(hwnd);\n      }\n    } catch (e) {\n      // Silently ignore\n    }\n  }\n}\n```\n\n## Don't\n- Don't modify instance-registry.js\n- Don't modify the renderer (index.html)\n- Don't modify the ForegroundMonitor\n- Don't remove the instanceRegistry.updateActiveHwnd calls added in 48q.2\n- Don't change the if (changed) branch — only modify the else branch and the on('focus') handler","acceptance_criteria":"1. promoteToActive() no longer calls SetForegroundWindow when the window is already active — it just returns false\n2. mainWindow.on('focus') only updates the registry timestamp, does NOT call SetForegroundWindow\n3. The activate-window else branch calls SetForegroundWindow on the other instance's window when available\n4. When no other instance exists (single-instance mode), clicking the active window still brings it to the front (fallback)\n5. Cross-stack toggle works: click active window B in Stack 2 → shows window A from Stack 1\n6. Normal activation (clicking a non-active window) still works — promoteToActive returns true and the if branch handles it\n7. node --check passes for both files\n8. No console errors during operation","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-25T03:21:11Z","created_by":"unknown","updated_at":"2026-02-25T03:22:37Z","closed_at":"2026-02-25T03:22:37Z","close_reason":"bfda37f fix: eliminate competing SetForegroundWindow calls for cross-stack toggle","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-48q.3","depends_on_id":"StackWindowsElectron-48q","type":"parent-child","created_at":"2026-02-24T21:21:11Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-48q.4","title":"Fix cross-stack toggle v2: use suppress flag instead of removing on-focus behavior","description":"## Problem\nThe previous fix (48q.3) removed SetForegroundWindow from mainWindow.on('focus'), which broke the basic behavior: clicking the admin panel no longer brings the active window to the front. We need BOTH behaviors:\n- Click on admin panel (header, empty space) → bring active window to front (original behavior)\n- Click on an already-active window item → cross-stack toggle (new behavior)\n\nThe race condition is: on('focus') fires BEFORE the onclick IPC handler. So on('focus') brings the current window to front, then the IPC toggle tries to bring the other window, but it's too late.\n\n## Solution: suppress flag\nUse a module-level flag _suppressFocusBringToFront that the activate-window IPC handler sets to true BEFORE calling promoteToActive, and clears after. The on('focus') handler checks this flag and skips SetForegroundWindow when it's set.\n\n## Files\n- src/main/main.js (modify)\n\n## What to do\n\n### 1. Add a module-level flag near the other module-level variables (~line 25, near _cleanedUp):\n```js\nlet _suppressFocusBringToFront = false;\n```\n\n### 2. Restore mainWindow.on('focus') to bring window to front, but check the flag (~line 104):\n```js\nmainWindow.on('focus', () =\u003e {\n  if (!windowManager) return;\n  const activeHwnd = windowManager.getActiveHwnd();\n  if (activeHwnd \u003e 0) {\n    instanceRegistry.updateActiveHwnd(activeHwnd);\n    if (!_suppressFocusBringToFront) {\n      try {\n        if (api.IsWindow(activeHwnd) !== 0) {\n          api.SetForegroundWindow(activeHwnd);\n        }\n      } catch (e) {\n        // Silently ignore\n      }\n    }\n  }\n});\n```\n\n### 3. In the activate-window IPC handler (~line 234), set the flag before promoteToActive and clear it after the entire handler completes:\n```js\nipcMain.handle('activate-window', async (event, hwnd) =\u003e {\n  try {\n    hwnd = validateHwnd(hwnd);\n    _suppressFocusBringToFront = true;\n    const changed = windowManager.promoteToActive(hwnd, true);\n    if (changed) {\n      syncMonitor();\n      doLayout();\n      sendStateUpdate();\n      persistence.save(windowManager.getState());\n      instanceRegistry.updateActiveHwnd(hwnd);\n    } else {\n      // Already active — try cross-stack toggle\n      const otherHwnd = instanceRegistry.getLastActiveHwndFromOtherInstances();\n      if (otherHwnd \u003e 0) {\n        try {\n          if (api.IsWindow(otherHwnd) !== 0) {\n            api.SetForegroundWindow(otherHwnd);\n          }\n        } catch (e) {\n          // Silently ignore\n        }\n      } else {\n        // No other instance — bring current window to front\n        try {\n          if (api.IsWindow(hwnd) !== 0) {\n            api.SetForegroundWindow(hwnd);\n          }\n        } catch (e) {\n          // Silently ignore\n        }\n      }\n    }\n    return { success: true };\n  } catch (e) {\n    console.error('activate-window error:', e);\n    return { success: false, error: e.message };\n  } finally {\n    // Clear flag after a short delay to ensure on('focus') has already fired\n    setTimeout(() =\u003e { _suppressFocusBringToFront = false; }, 100);\n  }\n});\n```\n\nIMPORTANT: Use a finally block with setTimeout to clear the flag. The on('focus') event fires synchronously when the BrowserWindow gains focus (which happens when the user clicks on it). The IPC handler runs asynchronously after. So the flag must be set BEFORE the IPC handler body runs. But since IPC handlers are async and the click on the admin panel triggers on('focus') synchronously... we need a different approach.\n\nActually, the correct timing is:\n1. User clicks on a window item in the admin panel\n2. The BrowserWindow already has focus (user is clicking WITHIN the panel), so on('focus') does NOT fire again\n3. The onclick handler fires → IPC activate-window\n\nSo on('focus') only fires when the admin panel GAINS focus (e.g., clicking from another app or another admin panel). When clicking within the same panel, on('focus') does NOT re-fire.\n\nThis means the race only happens when:\n- User is in Pila 1's panel, clicks on Pila 2's panel on a window item\n- on('focus') of Pila 2 fires (Pila 2 gains focus) → brings Pila 2's active window to front\n- Then onclick fires → IPC activate-window\n\nSo the suppress flag approach IS correct. Set it at the START of the IPC handler, clear it in finally with setTimeout(100ms).\n\nBUT WAIT — the IPC handler is async and runs AFTER on('focus'). So by the time _suppressFocusBringToFront = true runs, on('focus') has ALREADY fired. The flag is too late.\n\n## REVISED APPROACH: Set the flag from the RENDERER side before the IPC call.\n\nAdd a new IPC channel 'prepare-activate' that sets the flag, then the renderer calls it before activate-window.\n\nActually, that's overengineered. Simpler approach:\n\n## FINAL APPROACH: Debounce the on('focus') SetForegroundWindow with a short delay, and let activate-window cancel it.\n\n```js\nlet _focusBringTimer = null;\n\nmainWindow.on('focus', () =\u003e {\n  if (!windowManager) return;\n  const activeHwnd = windowManager.getActiveHwnd();\n  if (activeHwnd \u003e 0) {\n    instanceRegistry.updateActiveHwnd(activeHwnd);\n    // Delay bringing window to front — activate-window IPC can cancel this\n    if (_focusBringTimer) clearTimeout(_focusBringTimer);\n    _focusBringTimer = setTimeout(() =\u003e {\n      _focusBringTimer = null;\n      try {\n        if (api.IsWindow(activeHwnd) !== 0) {\n          api.SetForegroundWindow(activeHwnd);\n        }\n      } catch (e) {}\n    }, 150);\n  }\n});\n```\n\nThen in activate-window IPC handler, cancel the timer at the start:\n```js\nipcMain.handle('activate-window', async (event, hwnd) =\u003e {\n  try {\n    hwnd = validateHwnd(hwnd);\n    // Cancel any pending on('focus') bring-to-front\n    if (_focusBringTimer) {\n      clearTimeout(_focusBringTimer);\n      _focusBringTimer = null;\n    }\n    const changed = windowManager.promoteToActive(hwnd, true);\n    // ... rest unchanged\n```\n\nThis way:\n- Click on admin panel empty space → on('focus') fires → 150ms later brings window to front ✅\n- Click on window item in another panel → on('focus') fires → schedules 150ms timer → IPC handler fires → cancels timer → does toggle ✅\n\nUse 150ms delay. This is imperceptible to the user but enough for the IPC handler to fire and cancel.\n\n## Don't\n- Don't modify window-manager.js (promoteToActive stays as-is from 48q.3)\n- Don't modify instance-registry.js\n- Don't modify the renderer\n- Don't add new IPC channels\n- Don't remove the instanceRegistry.updateActiveHwnd calls","acceptance_criteria":"1. Clicking on the admin panel (header, empty space, NOT on a window item) brings the active window to the foreground after ~150ms delay\n2. Clicking on an already-active window item triggers the cross-stack toggle (brings other stack's window to front) instead of refreshing\n3. Clicking on a non-active window item activates it normally (promoteToActive returns true path)\n4. Single-instance mode: clicking already-active window brings it to front (no other instance to toggle to)\n5. The _focusBringTimer is properly cleaned up (cleared in activate-window handler, and should be cleared in performCleanup too)\n6. node --check src/main/main.js passes\n7. No console errors during operation","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-25T03:30:09Z","created_by":"unknown","updated_at":"2026-02-25T03:31:34Z","closed_at":"2026-02-25T03:31:34Z","close_reason":"934cb7c fix: debounce focus bring-to-front to allow cross-stack toggle","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-48q.4","depends_on_id":"StackWindowsElectron-48q","type":"parent-child","created_at":"2026-02-24T21:30:08Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-8oa","title":"Add rename-mode toggle button to managed stack header","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\nAdd a toggle button next to the managed window count (#managedCount) that enables/disables rename mode. When OFF (default), clicking a window title activates the window normally. When ON, clicking a title enters edit mode.\n\n### 1. Add CSS styles (inside existing \u003cstyle\u003e block, after .color-picker-btn:hover)\n\n```css\n.rename-toggle {\n  background: none;\n  border: 1px solid #444;\n  color: #666;\n  font-size: 9px;\n  padding: 2px 8px;\n  border-radius: 999px;\n  cursor: pointer;\n  transition: all 0.15s ease;\n  -webkit-app-region: no-drag;\n  margin-right: 6px;\n}\n\n.rename-toggle:hover {\n  border-color: #888;\n  color: #aaa;\n}\n\n.rename-toggle.active {\n  border-color: #f90;\n  color: #f90;\n  background: rgba(255, 153, 0, 0.1);\n}\n```\n\n### 2. Add the toggle button in HTML\n\nChange the managed stack section-header (line 399-402) from:\n```html\n\u003cdiv class=\"section-header\"\u003e\n  \u003cspan id=\"managedSubtitle\"\u003eMANAGED STACK\u003c/span\u003e\n  \u003cspan id=\"managedCount\"\u003e0\u003c/span\u003e\n\u003c/div\u003e\n```\n\nTo:\n```html\n\u003cdiv class=\"section-header\"\u003e\n  \u003cspan id=\"managedSubtitle\"\u003eMANAGED STACK\u003c/span\u003e\n  \u003cdiv style=\"display: flex; align-items: center; gap: 4px;\"\u003e\n    \u003cbutton id=\"renameToggleBtn\" class=\"rename-toggle\" onclick=\"toggleRenameMode()\" title=\"Toggle rename mode\"\u003e✏️ Rename\u003c/button\u003e\n    \u003cspan id=\"managedCount\"\u003e0\u003c/span\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n```\n\n### 3. Add JS state variable and toggle function\n\nAdd after the existing `let customSizeEnabled = false;` line (line 426):\n```js\nlet renameModeEnabled = false;\n```\n\nAdd the toggle function after the `onBackgroundColorChange` function:\n```js\nfunction toggleRenameMode() {\n  renameModeEnabled = !renameModeEnabled;\n  const btn = document.getElementById('renameToggleBtn');\n  if (renameModeEnabled) {\n    btn.classList.add('active');\n  } else {\n    btn.classList.remove('active');\n  }\n  // Re-render to apply/remove contentEditable\n  renderManaged();\n}\n```\n\n### 4. Modify renderManaged() — CREATE branch (the else block starting ~line 643)\n\nWhen creating the displayName span, make contentEditable conditional on renameModeEnabled:\n\nChange:\n```js\ndisplayName.contentEditable = 'true';\n```\nTo:\n```js\ndisplayName.contentEditable = renameModeEnabled ? 'true' : 'false';\n```\n\nThe click stopPropagation on displayName should ALSO be conditional. Change:\n```js\n// Prevent click from activating the window while editing\ndisplayName.addEventListener('click', (e) =\u003e {\n  e.stopPropagation();\n});\n```\nTo:\n```js\n// Only prevent click propagation (window activation) when rename mode is on\ndisplayName.addEventListener('click', (e) =\u003e {\n  if (renameModeEnabled) {\n    e.stopPropagation();\n  }\n});\n```\n\nThe dblclick handler should also be conditional:\n```js\ndisplayName.addEventListener('dblclick', (e) =\u003e {\n  if (!renameModeEnabled) return;\n  e.stopPropagation();\n  const selection = window.getSelection();\n  const range = document.createRange();\n  range.selectNodeContents(displayName);\n  selection.removeAllRanges();\n  selection.addRange(range);\n});\n```\n\nThe blur handler should only save when rename mode is on:\n```js\ndisplayName.addEventListener('blur', () =\u003e {\n  if (!renameModeEnabled) return;\n  const newName = displayName.textContent.trim();\n  renameWindowTitle(win.hwnd, newName || null);\n});\n```\n\nThe keydown handler should also check:\n```js\ndisplayName.addEventListener('keydown', (e) =\u003e {\n  if (!renameModeEnabled) return;\n  if (e.key === 'Enter') {\n    e.preventDefault();\n    displayName.blur();\n  }\n  if (e.key === 'Escape') {\n    e.preventDefault();\n    displayName.textContent = win.customTitle || win.title || 'Untitled';\n    displayName.blur();\n  }\n});\n```\n\n### 5. Modify renderManaged() — UPDATE branch (the if(item) block starting ~line 596)\n\nWhen updating existing elements, also update the contentEditable state of the display-name:\n\nAfter the existing `if (displayEl \u0026\u0026 document.activeElement !== displayEl) {` block, add:\n```js\nif (displayEl) {\n  displayEl.contentEditable = renameModeEnabled ? 'true' : 'false';\n}\n```\n\n### 6. Remove the hover style when rename mode is off\n\nAdd this CSS rule to make the hover effect only visible in rename mode. Actually, simpler: the .display-name hover effect is harmless when not editable. But to make it clearer, change:\n```css\n.managed-title .display-name:hover {\n  background: rgba(255, 255, 255, 0.08);\n}\n```\nTo:\n```css\n.managed-title .display-name[contenteditable='true']:hover {\n  background: rgba(255, 255, 255, 0.08);\n}\n```\nThis way the hover highlight only shows when rename mode is active.\n\n## Don't\n- Don't change any backend files (main.js, preload.js, window-manager.js)\n- Don't change the renameWindowTitle function\n- Don't remove any existing rename functionality — just gate it behind the toggle\n- Don't persist the rename mode state — it resets to OFF on every app launch","acceptance_criteria":"1. A '✏️ Rename' toggle button appears to the left of the managed count number\n2. The button is OFF by default (no active class, gray appearance)\n3. When OFF: clicking a window title activates the window (normal behavior)\n4. When OFF: the title text is NOT editable (contentEditable=false)\n5. When ON: the button shows orange highlight (active class)\n6. When ON: clicking a title enters edit mode (contentEditable=true)\n7. When ON: double-click selects all text, Enter saves, Escape reverts\n8. Toggling OFF while editing does not cause errors\n9. The hover highlight on titles only appears when rename mode is ON\n10. No backend files modified","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-23T21:19:06Z","created_by":"unknown","updated_at":"2026-02-23T21:21:03Z","closed_at":"2026-02-23T21:21:03Z","close_reason":"a5e2e76 Add rename-mode toggle button to managed stack header","labels":["scope:small"]}
{"id":"StackWindowsElectron-9r5","title":"Epic: Bug fixes and optimization pass","description":"## Goal\nFix all critical, high, and medium bugs found during the comprehensive code audit. Improve stability, correctness, and UX.\n\n## Scope\n- 5 CRITICAL issues (crashes, data loss, race conditions)\n- 7 HIGH issues (broken features, stuck windows, UX-breaking)\n- 13 MEDIUM issues (suboptimal behavior, missing validation, accessibility)\n\n## Key Areas\n1. Win32 API correctness (type misuse, null dereferences, negative dimensions)\n2. Shutdown/cleanup reliability (double cleanup, race conditions)\n3. Instance registry race conditions\n4. Renderer UX (drag region blocking edits, stale closures, double renders)\n5. Animation reliability (single timer, concurrent animations)\n6. Input validation and security hardening","status":"closed","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-24T07:02:17Z","created_by":"unknown","updated_at":"2026-02-24T13:20:03Z","closed_at":"2026-02-24T13:20:03Z","close_reason":"Closed","labels":["scope:medium"]}
{"id":"StackWindowsElectron-9r5.1","title":"Fix layoutStack null dereference and negative availableWidth","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\n\n### Bug 1: screenBounds.displayRightEdge null dereference (line 553)\nLine 547 creates a fallback: `const workArea = screenBounds || { ... }`. But line 553 accesses `screenBounds.displayRightEdge` directly instead of `workArea.displayRightEdge`. If screenBounds is null/undefined, this crashes.\n\n**Fix:** Change line 553 from:\n```js\nif (screenBounds.displayRightEdge != null) {\n```\nTo:\n```js\nif (workArea.displayRightEdge != null) {\n```\n\nAlso add `displayRightEdge: null` to the fallback object on line 547 so the fallback path is explicit.\n\n### Bug 2: availableWidth can go negative (line 549)\nIf the controller window is dragged to the right edge of the screen, `startX` exceeds `displayRightEdge`, making `availableWidth` negative. Negative width passed to SetWindowPos causes undefined behavior.\n\n**Fix:** After calculating `availableWidth` (around line 556), add a clamp:\n```js\nif (availableWidth \u003c 200) {\n  console.warn('layoutStack: not enough space to the right of controller, skipping layout');\n  return;\n}\n```\n\n## Don't\n- Don't change the layoutStack signature\n- Don't change animation logic\n- Don't change any other method","acceptance_criteria":"1. layoutStack(null) does not crash — uses fallback gracefully\n2. layoutStack({x:1800, y:0, width:300, height:1080, displayRightEdge:1920}) with startX \u003e displayRightEdge returns early without calling SetWindowPos\n3. availableWidth is never negative when passed to window positioning\n4. Normal layout behavior unchanged when controller is in a valid position\n5. node --check passes","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-24T07:02:34Z","created_by":"unknown","updated_at":"2026-02-24T13:12:01Z","closed_at":"2026-02-24T13:12:01Z","close_reason":"dad3617 fix: layoutStack null dereference and negative availableWidth","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-9r5.1","depends_on_id":"StackWindowsElectron-9r5","type":"parent-child","created_at":"2026-02-24T01:02:34Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-9r5.10","title":"Fix active window height going negative with many windows","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nWhen there are many inactive windows (26+ at 40px HEADER_HEIGHT in 1040px height), `activeHeight = effectiveHeight - (inactiveCount * HEADER_HEIGHT)` goes negative. The fallback gives the active window full height, covering all strips and making them unclickable.\n\n### Fix: Cap the strip area and dynamically reduce header height\n\nIn layoutStack(), after calculating `inactiveCount` (around line 580), add:\n\n```js\n// Cap strip area to max 60% of effectiveHeight, reduce header height if needed\nconst maxStripArea = Math.floor(effectiveHeight * 0.6);\nlet effectiveHeaderHeight = HEADER_HEIGHT;\nif (inactiveCount * effectiveHeaderHeight \u003e maxStripArea) {\n  effectiveHeaderHeight = Math.max(Math.floor(maxStripArea / inactiveCount), 10); // min 10px per strip\n}\n```\n\nThen use `effectiveHeaderHeight` instead of `HEADER_HEIGHT` in the strip positioning and active height calculations within layoutStack.\n\n## Don't\n- Don't change the HEADER_HEIGHT constant (it's still the default)\n- Don't change the layout for small numbers of windows (\u003c 15)\n- Don't change animation logic","acceptance_criteria":"1. With 30 managed windows, all strip headers are visible (not covered by active window)\n2. Active window height is always at least 40% of effectiveHeight\n3. Strip headers shrink proportionally when there are too many windows\n4. Strip headers never go below 10px\n5. Normal behavior unchanged for small stacks (\u003c 15 windows)\n6. node --check passes","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-24T07:05:15Z","created_by":"unknown","updated_at":"2026-02-24T13:14:16Z","closed_at":"2026-02-24T13:14:16Z","close_reason":"5308514 Fix active window height going negative with many windows","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-9r5.10","depends_on_id":"StackWindowsElectron-9r5","type":"parent-child","created_at":"2026-02-24T01:05:14Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-9r5.11","title":"Fix renderer: paste sanitization and blur-on-remove spurious rename","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\n\n### Bug 1: No paste sanitization in contentEditable fields\nPasting rich HTML content (from Word, web pages) into the stack title or window rename fields causes visual glitches. Only plain text should be accepted.\n\n**Fix:** Add a paste event handler to both contentEditable elements.\n\nFor the stack title h1 (after the existing keydown handler, around line 505):\n```js\nstackTitle.addEventListener('paste', (e) =\u003e {\n  e.preventDefault();\n  const text = (e.clipboardData || window.clipboardData).getData('text/plain');\n  document.execCommand('insertText', false, text.substring(0, 100));\n});\n```\n\nFor the displayName span in renderManaged CREATE branch (after the keydown handler):\n```js\ndisplayName.addEventListener('paste', (e) =\u003e {\n  e.preventDefault();\n  const text = (e.clipboardData || window.clipboardData).getData('text/plain');\n  document.execCommand('insertText', false, text.substring(0, 200));\n});\n```\n\n### Bug 2: Blur fires spurious rename when clicking Remove\nWhen rename mode is ON and the user is editing a name, clicking Remove causes blur (which saves the partial name) THEN the remove. The rename is wasted.\n\n**Fix:** In the Remove button onclick handler (CREATE branch), set a flag before removing:\n```js\nremoveBtn.onclick = (e) =\u003e {\n  e.stopPropagation();\n  // If a displayName is focused, blur it without saving\n  const focused = item.querySelector('.display-name:focus');\n  if (focused) {\n    // Temporarily disable rename mode to prevent blur from saving\n    const wasEnabled = renameModeEnabled;\n    renameModeEnabled = false;\n    focused.blur();\n    renameModeEnabled = wasEnabled;\n  }\n  removeWindow(win.hwnd);\n};\n```\n\n## Don't\n- Don't change the blur handler logic (it already checks renameModeEnabled)\n- Don't change the IPC handlers\n- Don't add npm dependencies","acceptance_criteria":"1. Pasting rich HTML into stack title inserts only plain text\n2. Pasted text in stack title is limited to 100 chars\n3. Pasting rich HTML into window rename inserts only plain text\n4. Pasted text in window rename is limited to 200 chars\n5. Clicking Remove while editing does NOT save the partial rename\n6. The window is still removed correctly after clicking Remove","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-24T07:05:34Z","created_by":"unknown","updated_at":"2026-02-24T13:14:19Z","closed_at":"2026-02-24T13:14:19Z","close_reason":"22a0f6f Fix paste sanitization and blur-on-remove spurious rename","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-9r5.11","depends_on_id":"StackWindowsElectron-9r5","type":"parent-child","created_at":"2026-02-24T01:05:34Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-9r5.12","title":"Add koffi callback try/finally and GetWindowRect return value checks","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\n\n### Fix 1: Wrap koffi callback in try/finally in getAvailableWindows\nThe koffi callback is registered at the start and unregistered at the end. If an error occurs between register and unregister (outside the EnumWindows try/catch), the callback leaks.\n\n**Fix:** Wrap the entire getAvailableWindows body in try/finally:\n```js\ngetAvailableWindows(excludeHwnds = new Set()) {\n  const callback = koffi.register(...);\n  try {\n    // ... existing logic (EnumWindows, etc.)\n    return windows;\n  } finally {\n    koffi.unregister(callback);\n  }\n}\n```\n\n### Fix 2: Check GetWindowRect return value\nIn addWindow() and getAvailableWindows(), GetWindowRect is called but its BOOL return value is not checked. If it fails, the rect contains garbage/zeros.\n\n**Fix:** In addWindow (around line 143):\n```js\nconst rect = { left: 0, top: 0, right: 0, bottom: 0 };\nconst success = api.GetWindowRect(hwndNum, rect);\nif (!success) {\n  console.warn('GetWindowRect failed for hwnd:', hwndNum);\n}\n```\n\n### Fix 3: Add IsWindow check in addWindow\nBefore doing anything with the hwnd, verify it's still valid:\n```js\nif (!api.IsWindow(hwndNum)) return;\n```\n\n## Don't\n- Don't change the getAvailableWindows return format\n- Don't change addWindow's public API\n- Don't change animation logic","acceptance_criteria":"1. koffi.unregister is always called even if an error occurs (try/finally)\n2. GetWindowRect return value is checked in addWindow\n3. addWindow verifies IsWindow before proceeding\n4. Existing behavior unchanged for valid windows\n5. node --check passes","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-24T07:05:50Z","created_by":"unknown","updated_at":"2026-02-24T13:14:58Z","closed_at":"2026-02-24T13:14:58Z","close_reason":"7a5c7f5 Add koffi callback try/finally and GetWindowRect return value checks","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-9r5.12","depends_on_id":"StackWindowsElectron-9r5","type":"parent-child","created_at":"2026-02-24T01:05:49Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-9r5.13","title":"Add sendStateUpdate fields for stackName, hideAvailable, dimensions, backgroundColor","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nThe `sendStateUpdate()` function only sends `managed` and `activeHwnd`. The renderer's `onStateUpdate` handler expects `stackName`, `hideAvailable`, `customWidth`, `customHeight`, and `backgroundColor` as well. These fields are only sent via the `get-managed-windows` IPC response (pull-based), not via push updates.\n\n### Fix: Update sendStateUpdate to include all state fields\n\nChange sendStateUpdate from:\n```js\nfunction sendStateUpdate() {\n  if (mainWindow \u0026\u0026 !mainWindow.isDestroyed()) {\n    const dims = windowManager.getCustomDimensions();\n    mainWindow.webContents.send('state-update', {\n      managed: windowManager.getManagedWindows(),\n      activeHwnd: windowManager.getActiveHwnd(),\n      stackName: windowManager.stackName,\n      hideAvailable: windowManager.hideAvailable,\n      customWidth: dims.customWidth,\n      customHeight: dims.customHeight,\n      backgroundColor: windowManager.getBackgroundColor()\n    });\n  }\n}\n```\n\nVerify this is already the case. If sendStateUpdate is missing any of these fields, add them. The renderer's onStateUpdate handler already handles all these fields — it just needs them to be sent.\n\n## Don't\n- Don't change the renderer\n- Don't change IPC handlers\n- Don't add new IPC channels","acceptance_criteria":"1. sendStateUpdate sends: managed, activeHwnd, stackName, hideAvailable, customWidth, customHeight, backgroundColor\n2. All 7 fields are present in every state-update push event\n3. node --check passes","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":10,"created_at":"2026-02-24T07:06:06Z","created_by":"unknown","updated_at":"2026-02-24T13:14:12Z","closed_at":"2026-02-24T13:14:12Z","close_reason":"0e3c7d4 sendStateUpdate already sends all 7 required fields; node --check passes","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-9r5.13","depends_on_id":"StackWindowsElectron-9r5","type":"parent-child","created_at":"2026-02-24T01:06:05Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-9r5.2","title":"Fix HWND_NOTOPMOST type: change hWndInsertAfter from size_t to intptr","description":"## Files\n- src/main/win32.js (modify)\n\n## What to do\n`HWND_TOPMOST` (-1) and `HWND_NOTOPMOST` (-2) are negative sentinel values passed to `SetWindowPos` and `DeferWindowPos`. These parameters are declared as `size_t` (unsigned), which may cause koffi to clamp or misinterpret the negative values. Win32 expects these as pointer-width signed values.\n\n### Fix 1: Change `hWndInsertAfter` parameter type in SetWindowPos\nIn the `lib.func` declaration for SetWindowPos (around line 33), change:\n```\n'BOOL SetWindowPos(size_t hWnd, size_t hWndInsertAfter, ...)'\n```\nTo:\n```\n'BOOL SetWindowPos(size_t hWnd, intptr hWndInsertAfter, ...)'\n```\n\n### Fix 2: Same for DeferWindowPos\nIn the `lib.func` declaration for DeferWindowPos (around line 35), change the second `size_t` (hWndInsertAfter) to `intptr`:\n```\n'size_t DeferWindowPos(size_t hWinPosInfo, size_t hWnd, intptr hWndInsertAfter, ...)'\n```\n\n### Fix 3: Fix EnumWindowsProc return type\nChange the callback prototype (around line 21) from:\n```\n'bool EnumWindowsProc(intptr hwnd, intptr lParam)'\n```\nTo:\n```\n'int EnumWindowsProc(intptr hwnd, intptr lParam)'\n```\nWin32 BOOL is a 4-byte int, not a 1-byte C99 bool.\n\n## Don't\n- Don't change any constant values\n- Don't change any other function declarations\n- Don't change exports","acceptance_criteria":"1. SetWindowPos declaration uses intptr for hWndInsertAfter parameter\n2. DeferWindowPos declaration uses intptr for hWndInsertAfter parameter\n3. EnumWindowsProc callback uses int return type (not bool)\n4. All other declarations unchanged\n5. node --check src/main/win32.js passes\n6. node --check src/main/window-manager.js passes (imports still work)","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":10,"created_at":"2026-02-24T07:02:51Z","created_by":"unknown","updated_at":"2026-02-24T13:12:38Z","closed_at":"2026-02-24T13:12:38Z","close_reason":"dad3617 Fix HWND_NOTOPMOST type: change hWndInsertAfter from size_t to intptr","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-9r5.2","depends_on_id":"StackWindowsElectron-9r5","type":"parent-child","created_at":"2026-02-24T01:02:50Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-9r5.3","title":"Fix double cleanup on shutdown — add guard flag","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nBoth `window-all-closed` and `before-quit` handlers run the same cleanup: `saveSync`, `restoreAll`, `cleanupFile`, `unregister`. Electron fires `before-quit` first, then `window-all-closed`. The double execution creates zombie registry files and wastes resources.\n\n### Fix: Add a module-level guard flag\n\nAdd after the existing variable declarations (around line 19):\n```js\nlet _cleanedUp = false;\n```\n\nCreate a shared cleanup function:\n```js\nfunction performCleanup() {\n  if (_cleanedUp) return;\n  _cleanedUp = true;\n\n  if (foregroundMonitor) foregroundMonitor.stop();\n  if (cleanupTimer) clearInterval(cleanupTimer);\n  if (saveTimer) clearInterval(saveTimer);\n  if (_layoutDebounceTimer) clearTimeout(_layoutDebounceTimer);\n  if (_saveDebounceTimer) {\n    clearTimeout(_saveDebounceTimer);\n    _saveDebounceTimer = null;\n  }\n\n  if (windowManager) {\n    persistence.saveSync(windowManager.getState());\n    windowManager.restoreAll();\n  }\n\n  persistence.cleanupFile();\n  instanceRegistry.unregister();\n}\n```\n\nThen simplify both handlers:\n```js\napp.on('window-all-closed', () =\u003e {\n  performCleanup();\n  app.quit();\n});\n\napp.on('before-quit', () =\u003e {\n  performCleanup();\n});\n```\n\n## Don't\n- Don't change the cleanup logic itself (save, restore, cleanupFile, unregister)\n- Don't change any IPC handlers\n- Don't remove the app.quit() call from window-all-closed","acceptance_criteria":"1. A _cleanedUp guard flag exists\n2. performCleanup() is called from both handlers but only executes once\n3. window-all-closed still calls app.quit()\n4. All timers are cleared in performCleanup\n5. saveSync, restoreAll, cleanupFile, unregister are called exactly once during shutdown\n6. node --check passes","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-24T07:03:06Z","created_by":"unknown","updated_at":"2026-02-24T13:12:19Z","closed_at":"2026-02-24T13:12:19Z","close_reason":"8770af5 fix: add _cleanedUp guard to prevent double cleanup on shutdown","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-9r5.3","depends_on_id":"StackWindowsElectron-9r5","type":"parent-child","created_at":"2026-02-24T01:03:06Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-9r5.4","title":"Fix DeferWindowPos failure: add fallback to individual SetWindowPos calls","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nWhen `DeferWindowPos` fails mid-batch (returns NULL/0), the entire deferred operation is abandoned and no windows are moved. The code currently just breaks out of the loop and skips `EndDeferWindowPos`, leaving windows frozen at intermediate positions.\n\n### Fix: In _animateLayout tick function (around lines 486-502)\n\nWhen `DeferWindowPos` returns 0 (falsy), instead of just breaking, fall back to individual `SetWindowPos` calls for the remaining windows in that frame:\n\n```js\nif (!currentHWinPosInfo) {\n  // DeferWindowPos failed — fall back to individual SetWindowPos for remaining\n  console.warn('DeferWindowPos failed, falling back to SetWindowPos');\n  for (let j = i; j \u003c targetLayouts.length; j++) {\n    const fb = targetLayouts[j];\n    try {\n      api.SetWindowPos(fb.hwnd, HWND_TOP, fb.x, fb.y, fb.cx, fb.cy, SWP_NOACTIVATE | SWP_NOZORDER);\n    } catch (e) {\n      // Skip this window\n    }\n  }\n  currentHWinPosInfo = 0;\n  break;\n}\n```\n\n### Also fix the same pattern in the final snap (around lines 509-517)\n\nApply the same fallback pattern if DeferWindowPos fails in the final snap batch.\n\n### Also add IsWindow check in restoreAll() (around line 265-273)\n\nAdd at the start of the restoreAll loop:\n```js\nif (!api.IsWindow(entry.hwnd)) continue;\n```\n\n## Don't\n- Don't change the animation timing or easing\n- Don't change the DeferWindowPos batch strategy (it's correct when it works)\n- Don't change layoutStack calculations","acceptance_criteria":"1. When DeferWindowPos fails mid-batch, remaining windows are positioned via individual SetWindowPos calls\n2. Windows are never left frozen at intermediate positions due to DeferWindowPos failure\n3. restoreAll() skips invalid HWNDs via IsWindow check\n4. Normal animation path (DeferWindowPos succeeds) is unchanged\n5. node --check passes","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-24T07:03:27Z","created_by":"unknown","updated_at":"2026-02-24T13:12:33Z","closed_at":"2026-02-24T13:12:33Z","close_reason":"035ef8b Fix DeferWindowPos failure: add fallback to individual SetWindowPos calls","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-9r5.4","depends_on_id":"StackWindowsElectron-9r5","type":"parent-child","created_at":"2026-02-24T01:03:26Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-9r5.5","title":"Fix per-window restore animation timer (use Map instead of single timer)","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nCurrently `_animateRestore` uses a single `_restoreAnimationTimer`. Removing two windows rapidly cancels the first animation, leaving it at an intermediate position.\n\n### Fix: Replace single timer with a Map of per-window timers\n\n1. Change the constructor: replace `this._restoreAnimationTimer = null;` with:\n```js\nthis._restoreAnimationTimers = new Map(); // Map\u003chwnd, timerId\u003e\n```\n\n2. Change `_stopRestoreAnimation()` to accept an optional hwnd:\n```js\n_stopRestoreAnimation(hwnd) {\n  if (hwnd != null) {\n    const timer = this._restoreAnimationTimers.get(hwnd);\n    if (timer) {\n      clearTimeout(timer);\n      this._restoreAnimationTimers.delete(hwnd);\n    }\n  } else {\n    // Stop all\n    for (const timer of this._restoreAnimationTimers.values()) {\n      clearTimeout(timer);\n    }\n    this._restoreAnimationTimers.clear();\n  }\n}\n```\n\n3. In `_animateRestore`, use the hwnd to key the timer:\n- At the start, call `this._stopRestoreAnimation(entry.hwnd)` instead of `this._stopRestoreAnimation()`\n- When setting the timer: `this._restoreAnimationTimers.set(entry.hwnd, setTimeout(tick, ...))`\n- On animation complete or error: `this._restoreAnimationTimers.delete(entry.hwnd)`\n\n4. In `restoreAll()`, call `this._stopRestoreAnimation()` (no args = stop all) at the start.\n\n## Don't\n- Don't change animation duration, easing, or frame rate\n- Don't change _animateLayout (the layout animation is separate and fine)\n- Don't change removeWindow logic beyond what's needed","acceptance_criteria":"1. Removing two windows rapidly animates BOTH back to their original positions\n2. Each window has its own independent restore timer\n3. _stopRestoreAnimation() with no args stops all timers\n4. _stopRestoreAnimation(hwnd) stops only that window's timer\n5. restoreAll() stops all restore animations before doing instant restore\n6. No memory leak — timers are cleaned up on completion\n7. node --check passes","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-24T07:03:42Z","created_by":"unknown","updated_at":"2026-02-24T13:13:09Z","closed_at":"2026-02-24T13:13:09Z","close_reason":"e602bf0 Fix per-window restore animation timer (use Map instead of single timer)","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-9r5.5","depends_on_id":"StackWindowsElectron-9r5","type":"parent-child","created_at":"2026-02-24T01:03:42Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-9r5.6","title":"Fix renderer: stack title editing blocked by drag region + state overwrite","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\n\n### Bug 1: -webkit-app-region: drag blocks contentEditable on stack title\nThe header div has `-webkit-app-region: drag` (CSS line 30). The h1#stackTitle inside it is contenteditable but does NOT have `-webkit-app-region: no-drag`. Clicking the title starts dragging the window instead of editing.\n\n**Fix:** Add to the CSS, after the existing `h1[contenteditable='true']` rule:\n```css\nh1[contenteditable='true'] {\n  -webkit-app-region: no-drag;\n}\n```\n\n### Bug 2: State update overwrites title while user is editing\nIn the `onStateUpdate` callback (around line 948-950), the code overwrites `stackTitle.textContent` without checking if the user is currently editing it. The foreground monitor fires every 200ms, so the user's typing gets destroyed.\n\n**Fix:** Add a guard before overwriting. Change:\n```js\nif (data.stackName) {\n  const upperName = data.stackName.toUpperCase();\n  if (stackTitle \u0026\u0026 stackTitle.textContent !== upperName) {\n    stackTitle.textContent = upperName;\n  }\n  if (managedSubtitle \u0026\u0026 managedSubtitle.textContent !== upperName) {\n    managedSubtitle.textContent = upperName;\n  }\n}\n```\nTo:\n```js\nif (data.stackName) {\n  const upperName = data.stackName.toUpperCase();\n  if (stackTitle \u0026\u0026 stackTitle.textContent !== upperName \u0026\u0026 document.activeElement !== stackTitle) {\n    stackTitle.textContent = upperName;\n  }\n  if (managedSubtitle \u0026\u0026 managedSubtitle.textContent !== upperName) {\n    managedSubtitle.textContent = upperName;\n  }\n}\n```\n\n### Bug 3: user-select: none on body breaks text selection in contentEditable\nAdd `user-select: text` to the focused state of editable elements:\n```css\nh1[contenteditable='true']:focus {\n  user-select: text;\n}\n\n.managed-title .display-name[contenteditable='true']:focus {\n  user-select: text;\n}\n```\n\n## Don't\n- Don't change the header drag behavior for non-editable areas\n- Don't change the saveStackTitle function\n- Don't change any JS logic beyond the guard addition","acceptance_criteria":"1. Clicking the stack title h1 enters edit mode (does NOT drag the window)\n2. Typing in the stack title is NOT overwritten by state updates\n3. Text can be selected inside contentEditable fields when focused\n4. The header area outside the h1 still allows window dragging\n5. managedSubtitle still updates from state (it's not editable)","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-24T07:04:02Z","created_by":"unknown","updated_at":"2026-02-24T13:12:05Z","closed_at":"2026-02-24T13:12:05Z","close_reason":"28056dd Fix renderer: stack title editing blocked by drag region + state overwrite","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-9r5.6","depends_on_id":"StackWindowsElectron-9r5","type":"parent-child","created_at":"2026-02-24T01:04:01Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-9r5.7","title":"Fix renderer: stale closures in rename handlers + renameWindowTitle missing local update","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\n\n### Bug 1: Stale closures in blur/keydown handlers\nWhen a managed window item is CREATED (else branch of renderManaged), the blur and keydown event listeners capture `win` from the forEach closure. These listeners are never rebound when the element is UPDATED. If the window's customTitle changes externally, pressing Escape restores the stale value.\n\n**Fix:** In the Escape keydown handler, read the current title from the DOM's data attribute instead of the closure. Add a data attribute when creating the element:\n```js\ndisplayName.dataset.currentCustomTitle = win.customTitle || '';\ndisplayName.dataset.currentTitle = win.title || 'Untitled';\n```\n\nIn the UPDATE branch, keep these attributes in sync:\n```js\nif (displayEl) {\n  displayEl.dataset.currentCustomTitle = win.customTitle || '';\n  displayEl.dataset.currentTitle = win.title || 'Untitled';\n}\n```\n\nChange the Escape handler to read from data attributes:\n```js\nif (e.key === 'Escape') {\n  e.preventDefault();\n  const ct = displayName.dataset.currentCustomTitle;\n  const t = displayName.dataset.currentTitle;\n  displayName.textContent = ct || t || 'Untitled';\n  displayName.blur();\n}\n```\n\n### Bug 2: renameWindowTitle does not update local state — causes flicker\nAfter calling the IPC, the local `managedWindows` array is stale until the next state-update arrives. If a render happens in between, the old name flickers back.\n\n**Fix:** After the IPC call in `renameWindowTitle`, optimistically update the local array:\n```js\nasync function renameWindowTitle(hwnd, newTitle) {\n  try {\n    // Optimistic local update\n    const entry = managedWindows.find(w =\u003e w.hwnd === hwnd);\n    if (entry) {\n      entry.customTitle = newTitle || null;\n    }\n    await window.electronAPI.renameWindow(hwnd, newTitle);\n  } catch (e) {\n    console.error('Failed to rename:', e);\n  }\n}\n```\n\n## Don't\n- Don't change the blur handler's save logic (it correctly uses win.hwnd which is stable)\n- Don't change the IPC handler or preload\n- Don't change the rename toggle logic","acceptance_criteria":"1. Pressing Escape during rename reverts to the CURRENT customTitle/title, not a stale one\n2. data-current-custom-title and data-current-title attributes are set on displayName elements\n3. These attributes are updated in the UPDATE branch of renderManaged\n4. After renaming, the local managedWindows entry is updated optimistically\n5. No flicker between old and new name after rename\n6. Blur handler still saves correctly via IPC","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":25,"created_at":"2026-02-24T07:04:24Z","created_by":"unknown","updated_at":"2026-02-24T13:17:20Z","closed_at":"2026-02-24T13:17:20Z","close_reason":"7d4cacf Fix stale closures in rename handlers + optimistic local update","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-9r5.7","depends_on_id":"StackWindowsElectron-9r5","type":"parent-child","created_at":"2026-02-24T01:04:23Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-9r5.8","title":"Fix renderer: eliminate double renders and add renderManaged debounce","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\n\n### Bug 1: Double render on add/remove/activate\n`addWindow()`, `removeWindow()`, and `activateWindow()` all call `await refreshManaged()` explicitly. But the main process IPC handlers also call `sendStateUpdate()`, which pushes a state-update event that triggers `renderManaged()` again. This causes 2 renders per operation.\n\n**Fix:** Remove the explicit `refreshManaged()` calls from `addWindow()`, `removeWindow()`, and `activateWindow()`. Rely on the push-based `onStateUpdate` for managed list updates. Keep `refreshAvailable()` in add/remove since available windows change.\n\n```js\nasync function addWindow(hwnd, title) {\n  try {\n    await window.electronAPI.addWindow(hwnd, title);\n    await refreshAvailable();\n  } catch (e) {\n    console.error('Failed to add:', e);\n  }\n}\n\nasync function removeWindow(hwnd) {\n  try {\n    await window.electronAPI.removeWindow(hwnd);\n    await refreshAvailable();\n  } catch (e) {\n    console.error('Failed to remove:', e);\n  }\n}\n\nasync function activateWindow(hwnd) {\n  try {\n    await window.electronAPI.activateWindow(hwnd);\n  } catch (e) {\n    console.error('Failed to activate:', e);\n  }\n}\n```\n\n### Bug 2: No debounce on renderManaged — DOM thrashing\nThe foreground monitor fires state updates every 200ms. Each triggers a full renderManaged(). Add requestAnimationFrame coalescing:\n\n```js\nlet _renderManagedPending = false;\n\nfunction scheduleRenderManaged() {\n  if (_renderManagedPending) return;\n  _renderManagedPending = true;\n  requestAnimationFrame(() =\u003e {\n    _renderManagedPending = false;\n    renderManaged();\n  });\n}\n```\n\nThen replace all calls to `renderManaged()` (except inside renderManaged itself) with `scheduleRenderManaged()`. Specifically in:\n- `onStateUpdate` callback\n- `refreshManaged()`\n- `toggleRenameMode()`\n\n### Bug 3: init() sequential awaits\nChange:\n```js\nasync function init() {\n  await refreshManaged();\n  await refreshAvailable();\n}\n```\nTo:\n```js\nasync function init() {\n  await Promise.all([refreshManaged(), refreshAvailable()]);\n}\n```\n\n## Don't\n- Don't change the IPC handlers in main.js\n- Don't change the onStateUpdate listener registration\n- Don't remove refreshAvailable from add/remove (available list needs explicit refresh)","acceptance_criteria":"1. addWindow no longer calls refreshManaged — relies on push state update\n2. removeWindow no longer calls refreshManaged — relies on push state update\n3. activateWindow no longer calls refreshManaged — relies on push state update\n4. renderManaged is coalesced via requestAnimationFrame — no DOM thrashing\n5. init() uses Promise.all for parallel startup\n6. Available windows list still refreshes after add/remove\n7. UI still updates correctly on all operations (via onStateUpdate push)","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":25,"created_at":"2026-02-24T07:04:43Z","created_by":"unknown","updated_at":"2026-02-24T13:19:39Z","closed_at":"2026-02-24T13:19:39Z","close_reason":"52e510f Fix double renders, add RAF debounce, parallel init","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-9r5.8","depends_on_id":"StackWindowsElectron-9r5","type":"parent-child","created_at":"2026-02-24T01:04:43Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-9r5.8","depends_on_id":"StackWindowsElectron-9r5.13","type":"blocks","created_at":"2026-02-24T01:06:12Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-9r5.9","title":"Add IPC input validation and enable sandbox","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\n\n### 1. Add input validation to IPC handlers\n\nAdd a helper function at the top of main.js (after imports):\n```js\nfunction validateHwnd(hwnd) {\n  const n = Number(hwnd);\n  if (!Number.isFinite(n) || n \u003c= 0) throw new Error('Invalid hwnd: ' + hwnd);\n  return n;\n}\n```\n\nApply it in these IPC handlers:\n- `add-window`: validate hwnd, validate title is string and limit to 500 chars\n- `remove-window`: validate hwnd\n- `activate-window`: validate hwnd\n- `rename-window`: validate hwnd, validate customTitle is string or null, limit to 200 chars\n\nFor `set-custom-dimensions`: validate width/height are null or positive numbers \u003e= 200.\nFor `set-background-color`: validate color matches /^#[0-9a-fA-F]{6}$/.\nFor `resize-app`: validate width/height are positive numbers.\n\n### 2. Enable sandbox in webPreferences\n\nChange `sandbox: false` to `sandbox: true` in createWindow(). The preload only uses `contextBridge` and `ipcRenderer`, which are available in sandboxed mode.\n\n## Don't\n- Don't change the IPC handler logic beyond adding validation at the top\n- Don't change preload.js\n- Don't add npm dependencies","acceptance_criteria":"1. add-window rejects non-finite/negative hwnd values\n2. add-window truncates title to 500 chars\n3. rename-window truncates customTitle to 200 chars\n4. set-custom-dimensions rejects non-null values below 200\n5. set-background-color rejects non-hex-color strings\n6. sandbox: true is set in webPreferences\n7. All existing functionality still works\n8. node --check passes","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-24T07:04:59Z","created_by":"unknown","updated_at":"2026-02-24T13:14:30Z","closed_at":"2026-02-24T13:14:30Z","close_reason":"20a9294 Add IPC input validation and enable sandbox","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-9r5.9","depends_on_id":"StackWindowsElectron-9r5","type":"parent-child","created_at":"2026-02-24T01:04:59Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-a7t","title":"Epic: Admin panel UX compactness and window-focus improvements","description":"## Goals\nThis epic improves the admin panel UX in three areas:\n\n1. **Auto-focus active window on admin panel focus**: When the user clicks on the admin panel (BrowserWindow), the app should automatically bring the last active managed window to the foreground. This ensures that switching between admin panels (or clicking on the admin) doesn't lose the user's context — the window they were working with stays visible.\n\n2. **Compact admin panel layout**: Reduce vertical space consumed by window items, section headers, and the main header. The admin panel should feel tighter and more space-efficient.\n\n3. **Clean window display names**: When a window has been renamed (customTitle), show ONLY the custom name — hide the original Win32 title subtitle. Also remove the text badges ('ACTIVE', 'strip N') since the background color already communicates the active state.\n\n## Current Problems\n- No mainWindow.on('focus') handler exists — clicking the admin panel does nothing to maintain the active managed window's visibility\n- Window items have generous padding (8px 12px) and section headers are tall\n- Renamed windows show both the custom name AND the original title underneath\n- Text badges ('● ACTIVE', '▬ strip 0') take horizontal space and are redundant with the green/blue background color indicators\n\n## What Success Looks Like\n1. Clicking the admin panel brings the active managed window to the foreground automatically\n2. The managed window list is visually more compact (less vertical space per item)\n3. Renamed windows show only the custom name, no original title hint\n4. No text badges visible — active/inactive state communicated purely via background color and border\n\n## Key Constraints\n- Must not break existing DOM-diffing logic in renderManaged()\n- The isActive logic in the backend (window-manager.js) must remain unchanged — only the UI representation changes\n- Must not break rename mode functionality\n- Must remain vanilla JS, no frameworks","status":"closed","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-24T22:21:35Z","created_by":"unknown","updated_at":"2026-02-24T22:47:30Z","closed_at":"2026-02-24T22:47:30Z","close_reason":"Closed","labels":["scope:medium"]}
{"id":"StackWindowsElectron-a7t.1","title":"Auto-focus active managed window when admin panel receives focus","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nAdd a mainWindow.on('focus') event handler inside the createWindow() function (after line 101, near the other mainWindow.on handlers).\n\nWhen the admin BrowserWindow receives focus:\n1. Check if windowManager exists and has an activeHwnd \u003e 0\n2. Check if the active window is still alive via api.IsWindow(activeHwnd)\n3. If alive, call api.SetForegroundWindow(activeHwnd) to bring the managed window to the foreground\n4. This requires importing the win32 api — add: const api = require('./win32'); at the top of main.js (if not already imported)\n\nThe handler should look approximately like:\n```js\nmainWindow.on('focus', () =\u003e {\n  if (!windowManager) return;\n  const activeHwnd = windowManager.getActiveHwnd();\n  if (activeHwnd \u003e 0) {\n    try {\n      const api = require('./win32');\n      if (api.IsWindow(activeHwnd) !== 0) {\n        api.SetForegroundWindow(activeHwnd);\n      }\n    } catch (e) {\n      // Silently ignore — window may have been closed\n    }\n  }\n});\n```\n\nIMPORTANT: The api require should be at the top of the file, not inside the handler. Check if win32 is already imported at the top of main.js. If not, add it.\n\n## Don't\n- Don't modify window-manager.js\n- Don't modify the renderer (index.html)\n- Don't add any new IPC channels\n- Don't call doLayout() or sendStateUpdate() from this handler — it's purely a SetForegroundWindow call\n- Don't add a debounce — the focus event fires rarely enough","acceptance_criteria":"1. When the admin panel BrowserWindow receives OS focus (user clicks on it), the active managed window is automatically brought to the foreground via SetForegroundWindow\n2. If there is no active managed window (activeHwnd === 0), nothing happens\n3. If the active managed window has been closed (IsWindow returns 0), nothing happens — no crash\n4. The handler is registered inside createWindow() alongside the existing 'resize' and 'closed' handlers\n5. No new IPC channels are added\n6. The app starts and runs without errors","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-24T22:21:50Z","created_by":"unknown","updated_at":"2026-02-24T22:46:00Z","closed_at":"2026-02-24T22:46:00Z","close_reason":"1489e66 Auto-focus active managed window on admin panel focus","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-a7t.1","depends_on_id":"StackWindowsElectron-a7t","type":"parent-child","created_at":"2026-02-24T16:21:50Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-a7t.2","title":"Remove active/strip text badges from managed window items","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\nRemove the text badges ('● ACTIVE' and '▬ strip N') from the managed window items in the renderManaged() function. The active/inactive state is already communicated via background color (#0a1a0a green tint for active) and border-left color (#4f4 green for active, #48f blue for inactive).\n\n### Changes in renderManaged() — UPDATE existing elements section (~lines 712-725):\nDelete the entire badge update block. Currently:\n```js\n// Update badge\nlet badge = titleEl ? titleEl.querySelector('.active-badge, .strip-badge') : null;\nif (!badge) {\n  badge = document.createElement('span');\n  if (titleEl) titleEl.appendChild(badge);\n}\nif (isActive) {\n  badge.className = 'active-badge';\n  badge.textContent = '● ACTIVE';\n} else {\n  badge.className = 'strip-badge';\n  const bgIndex = managedWindows.filter(w =\u003e w.hwnd !== activeHwnd).findIndex(w =\u003e w.hwnd === win.hwnd);\n  badge.textContent = '▬ strip ' + bgIndex;\n}\n```\nReplace with code that REMOVES any existing badge:\n```js\n// Remove badge if present (no longer displayed)\nconst badge = titleEl ? titleEl.querySelector('.active-badge, .strip-badge') : null;\nif (badge) badge.remove();\n```\n\n### Changes in renderManaged() — CREATE new elements section (~lines 814-825):\nDelete the entire block that creates badges for new elements. Currently:\n```js\nif (isActive) {\n  const badge = document.createElement('span');\n  badge.className = 'active-badge';\n  badge.textContent = '● ACTIVE';\n  title.appendChild(badge);\n} else {\n  const badge = document.createElement('span');\n  badge.className = 'strip-badge';\n  const bgIndex = managedWindows.filter(w =\u003e w.hwnd !== activeHwnd).findIndex(w =\u003e w.hwnd === win.hwnd);\n  badge.textContent = '▬ strip ' + bgIndex;\n  title.appendChild(badge);\n}\n```\nSimply delete this entire if/else block. Do NOT replace it with anything.\n\n### CSS cleanup (~lines 241-252):\nRemove or comment out the .active-badge and .strip-badge CSS rules since they are no longer used:\n```css\n.active-badge { ... }\n.strip-badge { ... }\n```\n\n## Don't\n- Don't remove the .managed-item.active and .managed-item.inactive CSS classes — those provide the background color and border color\n- Don't change the isActive logic or the class assignment on the item element (line 677)\n- Don't modify any backend files (main.js, window-manager.js)\n- Don't change the click handler or rename functionality","acceptance_criteria":"1. No text badges ('● ACTIVE', '▬ strip N') appear in the managed window list\n2. Active windows still have green background (#0a1a0a) and green left border (#4f4)\n3. Inactive windows still have blue left border (#48f)\n4. The .active-badge and .strip-badge CSS rules are removed from the style block\n5. No JavaScript errors in the console when switching between windows\n6. The renderManaged() function still correctly updates existing elements and creates new ones without badge-related code","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-24T22:22:09Z","created_by":"unknown","updated_at":"2026-02-24T22:46:39Z","closed_at":"2026-02-24T22:46:39Z","close_reason":"bf682f7 Remove active/strip text badges from managed window items","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-a7t.2","depends_on_id":"StackWindowsElectron-a7t","type":"parent-child","created_at":"2026-02-24T16:22:08Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-a7t.3","title":"Hide original Win32 title when window has a custom name","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\nWhen a window has been renamed (customTitle is set), the UI currently shows both the custom name AND the original Win32 title as a small subtitle below it. The user wants to see ONLY the custom name.\n\n### Changes in renderManaged() — UPDATE existing elements section (~lines 700-709):\nCurrently the code shows the original title when customTitle is set:\n```js\nif (origEl) {\n  if (win.customTitle) {\n    origEl.textContent = win.title || '';\n    origEl.style.display = 'block';\n  } else {\n    origEl.textContent = '';\n    origEl.style.display = 'none';\n  }\n}\n```\nChange to ALWAYS hide the original title:\n```js\nif (origEl) {\n  origEl.textContent = '';\n  origEl.style.display = 'none';\n}\n```\n\n### Changes in renderManaged() — CREATE new elements section (~lines 803-812):\nCurrently the code creates the original-title span and shows it when customTitle is set:\n```js\nconst origTitle = document.createElement('span');\norigTitle.className = 'original-title';\nif (win.customTitle) {\n  origTitle.textContent = win.title || '';\n  origTitle.style.display = 'block';\n} else {\n  origTitle.style.display = 'none';\n}\ntitle.appendChild(origTitle);\n```\nChange to always hide it:\n```js\nconst origTitle = document.createElement('span');\norigTitle.className = 'original-title';\norigTitle.style.display = 'none';\ntitle.appendChild(origTitle);\n```\n\nNote: We keep the DOM element in place (hidden) rather than removing it entirely, to avoid breaking the DOM-diffing logic that queries for '.original-title'. This is the safest approach.\n\n## Don't\n- Don't remove the .original-title CSS rule — keep it for potential future use\n- Don't remove the origTitle DOM element creation — just keep it hidden\n- Don't modify the rename functionality or the customTitle storage\n- Don't modify any backend files","acceptance_criteria":"1. When a window has a customTitle set, ONLY the custom name is visible — no original Win32 title subtitle appears\n2. When a window has NO customTitle, the Win32 title is shown as before (as the display-name)\n3. The .original-title span still exists in the DOM (hidden) to avoid breaking querySelector calls\n4. Rename mode still works correctly — editing and saving custom names functions as before\n5. No JavaScript errors in the console","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-24T22:22:22Z","created_by":"unknown","updated_at":"2026-02-24T22:46:06Z","closed_at":"2026-02-24T22:46:06Z","close_reason":"eedbeb8 Hide original Win32 title when window has a custom name","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-a7t.3","depends_on_id":"StackWindowsElectron-a7t","type":"parent-child","created_at":"2026-02-24T16:22:22Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-a7t.4","title":"Compact admin panel layout — reduce padding and heights","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\nReduce vertical space in the admin panel to make it more compact. All changes are CSS-only in the inline \u003cstyle\u003e block.\n\n### 1. Header (.header) — ~line 27:\nChange padding from 12px to 6px 12px (reduce vertical padding only):\n```css\n.header {\n  padding: 6px 12px;\n  border-bottom: 1px solid #333;\n  -webkit-app-region: drag;\n}\n```\n\n### 2. Header h1 (.header h1) — ~line 33:\nReduce font-size from 14px to 12px:\n```css\n.header h1 {\n  font-size: 12px;\n  font-weight: 600;\n  letter-spacing: 0.5px;\n}\n```\n\n### 3. Section headers (.section-header) — ~line 66:\nReduce padding from 8px 12px to 4px 12px:\n```css\n.section-header {\n  padding: 4px 12px;\n  font-size: 11px;\n  font-weight: 600;\n  color: #888;\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  border-bottom: 1px solid #222;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  -webkit-app-region: no-drag;\n}\n```\n\n### 4. Window items (.window-item) — ~line 103:\nReduce padding from 8px 12px to 4px 12px:\n```css\n.window-item {\n  padding: 4px 12px;\n  border-bottom: 1px solid #111;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  -webkit-app-region: no-drag;\n}\n```\n\n### 5. Window list (.window-list) — ~line 97:\nReduce padding from 4px 0 to 2px 0:\n```css\n.window-list {\n  flex: 1;\n  overflow-y: auto;\n  padding: 2px 0;\n}\n```\n\n### 6. Header subtitle (.header .subtitle) — ~line 39:\nReduce margin-top from 2px to 1px:\n```css\n.header .subtitle {\n  font-size: 10px;\n  color: #666;\n  margin-top: 1px;\n}\n```\n\n## Don't\n- Don't change any colors, borders, or font-families\n- Don't change any JavaScript logic\n- Don't change the layout direction (flex-direction) of any element\n- Don't modify any backend files\n- Don't change the managed-title font-size (keep at 12px) — only structural padding changes","acceptance_criteria":"1. The .header has padding: 6px 12px (was 12px)\n2. The .header h1 has font-size: 12px (was 14px)\n3. The .section-header has padding: 4px 12px (was 8px 12px)\n4. The .window-item has padding: 4px 12px (was 8px 12px)\n5. The .window-list has padding: 2px 0 (was 4px 0)\n6. The .header .subtitle has margin-top: 1px (was 2px)\n7. The overall admin panel looks visually more compact with less vertical whitespace\n8. No layout breakage — all elements still align correctly\n9. No JavaScript errors","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-24T22:22:40Z","created_by":"unknown","updated_at":"2026-02-24T22:46:42Z","closed_at":"2026-02-24T22:46:42Z","close_reason":"bf682f7 Compact admin panel layout — reduce padding and heights","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-a7t.4","depends_on_id":"StackWindowsElectron-a7t","type":"parent-child","created_at":"2026-02-24T16:22:39Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-b1s","title":"Epic: Multi-instance isolation - each app instance manages its own independent window group","description":"## Goal\nWhen the user launches multiple instances of StackWindowsElectron, each instance should manage its own independent group of windows without interfering with other running instances.\n\n## Current Problem\n- There is a single persistence file: window-group.json\n- On startup, loadState() reconnects ALL saved windows regardless of whether another instance is already managing them\n- The 'Available Windows' list shows ALL system windows, including those already managed by another instance\n- No concept of instance identity or group isolation exists\n\n## What Success Looks Like\n1. Each new instance starts FRESH (empty managed stack) - no auto-loading of windows from other instances\n2. Each instance persists to its OWN file (e.g., window-group-\u003cinstanceId\u003e.json)\n3. The 'Available Windows' list EXCLUDES windows already managed by another running instance\n4. When an instance quits, it cleans up its persistence file and restores its windows\n5. Instances can coexist without layout conflicts\n\n## Key Constraints\n- Must NOT break single-instance usage (first launch still works exactly as before)\n- Instance ID should be generated at launch time (UUID or timestamp-based)\n- Cross-instance communication via a shared registry file (not IPC between Electron processes)\n- No new dependencies allowed\n- Backward compatible: old window-group.json should still load for the first instance","status":"closed","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-23T18:49:21Z","created_by":"unknown","updated_at":"2026-02-25T17:15:33Z","closed_at":"2026-02-25T17:15:33Z","close_reason":"Closed","labels":["needs-integration-review","scope:medium"]}
{"id":"StackWindowsElectron-b1s.1","title":"Add instance registry module (instance-registry.js)","description":"## Files\n- src/main/instance-registry.js (create)\n\n## What to do\nCreate a new module that manages a shared registry of running instances. The registry is a JSON file at \u003cuserData\u003e/instance-registry.json.\n\n### Registry file format:\n```json\n{\n  \"instances\": {\n    \"\u003cinstanceId\u003e\": {\n      \"pid\": 12345,\n      \"startedAt\": \"2026-02-23T...\",\n      \"managedHwnds\": [123, 456, 789]\n    }\n  }\n}\n```\n\n### Class: InstanceRegistry\nConstructor: `new InstanceRegistry()`\n\nMethods:\n- `init()` — Sets filePath to `\u003cuserData\u003e/instance-registry.json`. Generates a unique instanceId using `crypto.randomUUID()`. Calls `_register()` to add this instance to the registry. Returns the instanceId.\n- `_register()` — Reads registry file (or creates empty), adds this instance entry with pid=process.pid, startedAt=now, managedHwnds=[]. Writes file. Before writing, calls `_pruneDeadInstances()`.\n- `_pruneDeadInstances(registry)` — For each instance in registry.instances, check if the PID is still alive using `process.kill(pid, 0)\" wrapped in try/catch (signal 0 doesn't kill, just checks). Remove entries whose PID is dead. Return cleaned registry.\n- `updateManagedHwnds(hwnds)` — Reads registry, updates this instance's managedHwnds array, writes file. Debounce writes to max once per 2 seconds.\n- `getOtherInstancesHwnds()` — Reads registry, prunes dead instances, returns a Set\u003cnumber\u003e of ALL managedHwnds from OTHER instances (not this one).\n- `unregister()` — Removes this instance from registry file. Synchronous (for use in quit handlers). If this was the last instance, delete the registry file.\n- `getInstanceId()` — Returns this instance's ID string.\n\n### File I/O safety:\n- All reads: try/catch, return empty registry on failure\n- All writes: write to temp file first, then rename (atomic write pattern)\n- Use fs.readFileSync/writeFileSync for simplicity (registry is tiny)\n\n## Don't\n- Don't use any IPC or network communication between instances\n- Don't add any npm dependencies\n- Don't use file locking libraries — the atomic write pattern is sufficient\n- Don't export anything except { InstanceRegistry }","acceptance_criteria":"1. File src/main/instance-registry.js exists and exports { InstanceRegistry }\n2. init() generates a unique instanceId (UUID format) and registers in the JSON file\n3. _pruneDeadInstances removes entries whose PID is no longer running\n4. getOtherInstancesHwnds() returns a Set of hwnds from other live instances only\n5. unregister() synchronously removes this instance; deletes file if last instance\n6. updateManagedHwnds() debounces writes to max once per 2 seconds\n7. All file I/O is wrapped in try/catch — never throws\n8. No new npm dependencies added","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-23T18:49:48Z","created_by":"unknown","updated_at":"2026-02-23T18:57:30Z","closed_at":"2026-02-23T18:57:30Z","close_reason":"fc50e05 Add instance registry module","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-b1s.1","depends_on_id":"StackWindowsElectron-b1s","type":"parent-child","created_at":"2026-02-23T12:49:47Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-b1s.1","depends_on_id":"StackWindowsElectron-b1s.4","type":"blocks","created_at":"2026-02-23T12:50:38Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-b1s.1","depends_on_id":"StackWindowsElectron-b1s.6","type":"blocks","created_at":"2026-02-23T12:51:07Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-b1s.2","title":"Make Persistence instance-aware (per-instance file)","description":"## Files\n- src/main/persistence.js (modify)\n\n## What to do\nModify the Persistence class so each app instance saves to its own file instead of the shared window-group.json.\n\n### Changes to constructor:\nNo changes needed.\n\n### Changes to init():\nAdd an optional `instanceId` parameter: `init(instanceId)`\n- If instanceId is provided, set `this.filePath` to `\u003cuserData\u003e/window-group-\u003cinstanceId\u003e.json`\n- If instanceId is null/undefined (backward compat), use the old path `\u003cuserData\u003e/window-group.json`\n- Store instanceId as `this.instanceId = instanceId || null`\n- Log the chosen file path\n\n### New method: cleanupFile()\n- Synchronous method for use in quit handlers\n- If `this.instanceId` is set (instance-aware mode), DELETE the persistence file (`fs.unlinkSync`)\n- If `this.instanceId` is null (legacy mode), do NOT delete (preserve backward compat)\n- Wrap in try/catch, log errors but never throw\n\n### No changes to save(), saveSync(), load(), clear()\nThese methods already work with this.filePath, so they'll automatically use the instance-specific file.\n\n## Don't\n- Don't change the save/saveSync/load/clear method signatures or behavior\n- Don't change the JSON format (still version 2)\n- Don't delete the legacy window-group.json file — it may be used by a first-instance fallback\n- Don't add any npm dependencies","acceptance_criteria":"1. init('abc-123') sets filePath to \u003cuserData\u003e/window-group-abc-123.json\n2. init() with no args still uses \u003cuserData\u003e/window-group.json (backward compat)\n3. cleanupFile() deletes the instance-specific file when instanceId is set\n4. cleanupFile() does NOT delete when instanceId is null\n5. cleanupFile() never throws (wrapped in try/catch)\n6. save/saveSync/load/clear still work unchanged\n7. No new npm dependencies","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-23T18:50:02Z","created_by":"unknown","updated_at":"2026-02-23T18:58:11Z","closed_at":"2026-02-23T18:58:11Z","close_reason":"4193f19 Make Persistence instance-aware with init(instanceId) and cleanupFile()","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-b1s.2","depends_on_id":"StackWindowsElectron-b1s","type":"parent-child","created_at":"2026-02-23T12:50:01Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-b1s.2","depends_on_id":"StackWindowsElectron-b1s.4","type":"blocks","created_at":"2026-02-23T12:50:38Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-b1s.3","title":"Filter available windows to exclude other instances' managed windows","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nModify WindowManager.getAvailableWindows() to accept an optional Set of HWNDs to exclude (windows managed by other instances).\n\n### Changes to getAvailableWindows():\nNew signature: `getAvailableWindows(excludeHwnds = new Set())`\n\nInside the EnumWindows callback, after the existing `if (managedHwnds.has(hwndNum)) return true;` check, add:\n```js\nif (excludeHwnds.has(hwndNum)) return true;\n```\n\nThis filters out windows that other running instances are already managing.\n\n### No other changes to window-manager.js\nThe rest of the class stays exactly the same.\n\n## Don't\n- Don't change any other method in WindowManager\n- Don't import InstanceRegistry in window-manager.js — the caller (main.js) will pass the exclude set\n- Don't change the return format of getAvailableWindows()\n- Don't change addWindow() — a user CAN still force-add a window even if another instance has it (edge case, acceptable)","acceptance_criteria":"1. getAvailableWindows() still works with no arguments (returns all available windows)\n2. getAvailableWindows(new Set([123, 456])) excludes hwnds 123 and 456 from results\n3. The exclude check happens AFTER the managedHwnds check (line order matters for perf)\n4. No other methods in WindowManager are changed\n5. No new imports added to window-manager.js","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-23T18:50:13Z","created_by":"unknown","updated_at":"2026-02-23T18:56:56Z","closed_at":"2026-02-23T18:56:56Z","close_reason":"c7b3ded Add excludeHwnds parameter to getAvailableWindows","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-b1s.3","depends_on_id":"StackWindowsElectron-b1s","type":"parent-child","created_at":"2026-02-23T12:50:13Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-b1s.3","depends_on_id":"StackWindowsElectron-b1s.4","type":"blocks","created_at":"2026-02-23T12:50:38Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-b1s.4","title":"Integrate instance registry into main.js startup and shutdown","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nWire up InstanceRegistry and instance-aware Persistence in main.js so each instance starts fresh and cleans up on exit.\n\n### New import at top:\n```js\nconst { InstanceRegistry } = require('./instance-registry');\n```\n\n### New module-level variable:\n```js\nlet instanceRegistry = null;\n```\n\n### Changes to app.whenReady() block (lines 269-330):\n\n**Replace the initialization section (lines 270-288) with:**\n```js\n// 1. Initialize instance registry\ninstanceRegistry = new InstanceRegistry();\nconst instanceId = instanceRegistry.init();\n\n// 2. Initialize persistence with instance-specific file\npersistence = new Persistence();\npersistence.init(instanceId);\n\n// 3. Initialize window manager — starts EMPTY, no loadState()\nwindowManager = new WindowManager();\n\n// NOTE: We intentionally do NOT call persistence.load() or windowManager.loadState().\n// Each new instance starts with an empty managed stack.\n// The user adds windows manually to this instance's group.\n```\n\n**Remove the savedState loading block entirely** (lines 278-288 and 294-296). Each instance starts fresh. No bounds restoration either (each instance positions itself independently).\n\n**Update the get-available-windows IPC handler** to pass exclude set:\n```js\nipcMain.handle('get-available-windows', async () =\u003e {\n  try {\n    const excludeHwnds = instanceRegistry.getOtherInstancesHwnds();\n    return windowManager.getAvailableWindows(excludeHwnds);\n  } catch (e) {\n    console.error('get-available-windows error:', e);\n    return [];\n  }\n});\n```\n\n**Update the refresh IPC handler** similarly:\n```js\nipcMain.handle('refresh', async () =\u003e {\n  try {\n    const excludeHwnds = instanceRegistry.getOtherInstancesHwnds();\n    return windowManager.getAvailableWindows(excludeHwnds);\n  } catch (e) {\n    console.error('refresh error:', e);\n    return [];\n  }\n});\n```\n\n**Update the add-window IPC handler** to sync registry after adding:\nAfter `persistence.save(windowManager.getState());`, add:\n```js\ninstanceRegistry.updateManagedHwnds(windowManager.getManagedHwnds());\n```\n\n**Update the remove-window IPC handler** similarly — add registry sync after persistence save.\n\n**Update the activate-window IPC handler** — no registry change needed (activation doesn't change the set of managed hwnds).\n\n**Update the cleanup timer** (removeDeadWindows block) — after persistence save, add:\n```js\ninstanceRegistry.updateManagedHwnds(windowManager.getManagedHwnds());\n```\n\n**Remove the auto-save timer** (lines 325-329) — it's redundant since we save on every meaningful change. Or keep it but also sync registry in it.\n\n### Changes to window-all-closed handler:\nBefore `app.quit()`, add:\n```js\npersistence.cleanupFile();\ninstanceRegistry.unregister();\n```\n\n### Changes to before-quit handler:\nAfter the persistence saveSync, add:\n```js\npersistence.cleanupFile();\ninstanceRegistry.unregister();\n```\n\n## Don't\n- Don't call persistence.load() or windowManager.loadState() — instances start empty\n- Don't restore saved bounds — each instance positions itself via createWindow() defaults\n- Don't change createWindow(), doLayout(), sendStateUpdate(), or foreground monitor logic\n- Don't change the IPC handler signatures (renderer API stays the same)\n- Don't remove the debouncedSave function — it's still used by foreground monitor callbacks","acceptance_criteria":"1. App starts with empty managed stack (no windows loaded from persistence)\n2. InstanceRegistry is initialized before Persistence\n3. Persistence uses instance-specific file path (window-group-\u003cid\u003e.json)\n4. get-available-windows and refresh IPC handlers pass excludeHwnds from registry\n5. add-window and remove-window IPC handlers sync registry after persistence save\n6. Cleanup timer syncs registry when dead windows are removed\n7. window-all-closed calls persistence.cleanupFile() and instanceRegistry.unregister()\n8. before-quit calls persistence.cleanupFile() and instanceRegistry.unregister()\n9. No changes to createWindow, doLayout, sendStateUpdate, or foreground monitor\n10. App launches and runs without errors when started with npm start","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-23T18:50:39Z","created_by":"unknown","updated_at":"2026-02-23T19:00:21Z","closed_at":"2026-02-23T19:00:21Z","close_reason":"520cdf3 Integrate instance registry into main.js startup and shutdown","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-b1s.4","depends_on_id":"StackWindowsElectron-b1s","type":"parent-child","created_at":"2026-02-23T12:50:38Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-b1s.4","depends_on_id":"StackWindowsElectron-b1s.5","type":"blocks","created_at":"2026-02-23T12:50:49Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-b1s.4","depends_on_id":"StackWindowsElectron-b1s.6","type":"blocks","created_at":"2026-02-23T12:51:07Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-b1s.5","title":"Show instance ID in controller window title for visual distinction","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nWhen multiple instances are running, the user needs to visually distinguish them. Add the instance ID (short form) to the BrowserWindow title.\n\n### Changes to createWindow() function:\nAfter the line `title: 'Stack Windows',` — this stays as the default.\n\n### Changes to app.whenReady() block:\nAfter createWindow() is called and instanceRegistry is initialized, set the window title:\n```js\nconst shortId = instanceId.substring(0, 8);\nmainWindow.setTitle('Stack Windows [' + shortId + ']');\n```\n\nThis gives titles like: `Stack Windows [a1b2c3d4]`\n\n### No other changes needed.\n\n## Don't\n- Don't change the renderer HTML title element\n- Don't change the stack name logic\n- Don't add the full UUID — only first 8 chars for readability","acceptance_criteria":"1. Controller window title shows 'Stack Windows [XXXXXXXX]' where X is first 8 chars of instanceId\n2. Each instance shows a different short ID\n3. No changes to renderer HTML\n4. No changes to stack name logic","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":10,"created_at":"2026-02-23T18:50:50Z","created_by":"unknown","updated_at":"2026-02-23T19:01:15Z","closed_at":"2026-02-23T19:01:15Z","close_reason":"b48fe5f Show instance ID in controller window title","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-b1s.5","depends_on_id":"StackWindowsElectron-b1s","type":"parent-child","created_at":"2026-02-23T12:50:49Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-b1s.6","title":"Handle stale registry cleanup on startup","description":"## Files\n- src/main/instance-registry.js (modify — if not already handled in task .1)\n- src/main/main.js (modify)\n\n## What to do\nEnsure that if the app crashes or is force-killed (without running quit handlers), stale entries in the instance registry are cleaned up on the next startup.\n\n### This is mostly already handled by _pruneDeadInstances() in task .1, but verify:\n\n1. In InstanceRegistry._register(), _pruneDeadInstances() is called BEFORE adding the new instance. This means every startup cleans up dead entries from crashed instances.\n\n2. In InstanceRegistry.getOtherInstancesHwnds(), _pruneDeadInstances() is called BEFORE collecting hwnds. This means every 'Available Windows' refresh also cleans up.\n\n### Additional cleanup in main.js app.whenReady():\nAfter instanceRegistry.init(), add cleanup of orphaned persistence files:\n```js\n// Clean up orphaned persistence files from crashed instances\nconst userDataPath = app.getPath('userData');\nconst fs = require('fs');\ntry {\n  const files = fs.readdirSync(userDataPath);\n  const registry = instanceRegistry._readRegistry(); // need to expose or inline\n  const liveIds = new Set(Object.keys(registry.instances || {}));\n  \n  for (const file of files) {\n    const match = file.match(/^window-group-(.+)\\.json$/);\n    if (match \u0026\u0026 !liveIds.has(match[1])) {\n      fs.unlinkSync(path.join(userDataPath, file));\n      console.log('Cleaned up orphaned persistence file:', file);\n    }\n  }\n} catch (e) {\n  console.error('Failed to clean orphaned files:', e);\n}\n```\n\n### Expose _readRegistry as a public method:\nIn instance-registry.js, rename `_readRegistry()` to have a public accessor or add:\n```js\ngetRegistry() { return this._readRegistry(); }\n```\n\n## Don't\n- Don't delete window-group.json (the legacy file without instance ID)\n- Don't add complex file locking — simple read+delete is fine\n- Don't make this blocking — if cleanup fails, log and continue","acceptance_criteria":"1. On startup, orphaned window-group-\u003cid\u003e.json files from dead instances are deleted\n2. The legacy window-group.json file is NEVER deleted by this cleanup\n3. Live instance files (whose instance is still in the registry with a live PID) are NOT deleted\n4. Cleanup errors are logged but don't prevent app startup\n5. getRegistry() or equivalent public method exists on InstanceRegistry","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":25,"created_at":"2026-02-23T18:51:07Z","created_by":"unknown","updated_at":"2026-02-23T19:01:37Z","closed_at":"2026-02-23T19:01:37Z","close_reason":"5932da7 Add orphaned persistence file cleanup on startup","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-b1s.6","depends_on_id":"StackWindowsElectron-b1s","type":"parent-child","created_at":"2026-02-23T12:51:07Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5","title":"Epic: Dimensiones personalizables de ventanas + Fix multi-monitor","description":"Las ventanas administradas actualmente ocupan todo el espacio libre de la pantalla. Cuando se usa un segundo monitor en proyeccion ampliada (monitor secundario a la izquierda del principal), las ventanas se extienden abarcando ambos monitores. Causa raiz: layoutStack() usa getPrimaryDisplay() hardcodeado en vez de detectar el monitor donde corre la app. Objetivo: (1) Corregir deteccion de monitor para que las ventanas solo ocupen el monitor donde esta la pila administrativa. (2) Permitir al usuario personalizar ancho y alto de las ventanas administradas desde la UI, aplicando esas dimensiones a todas las ventanas del stack. (3) Persistir las dimensiones custom. Exito: el usuario puede redimensionar sus ventanas administradas y la app funciona correctamente en configuraciones multi-monitor.","status":"closed","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-20T23:13:23Z","created_by":"unknown","updated_at":"2026-02-25T17:15:29Z","closed_at":"2026-02-25T17:15:29Z","close_reason":"Closed","labels":["needs-integration-review","scope:medium"]}
{"id":"StackWindowsElectron-fv5.1","title":"Fix deteccion de monitor - layoutStack usa getPrimaryDisplay hardcodeado","description":"## Files\n- src/main/main.js (modify)\n- src/main/window-manager.js (modify)\n\n## What to do\n### main.js - getWorkArea() y doLayout()\n- Cambiar getWorkArea() para que reciba opcionalmente un punto {x, y} y use screen.getDisplayNearestPoint() en vez de screen.getPrimaryDisplay(). Si no recibe punto, usar getPrimaryDisplay() como fallback.\n- En doLayout(), obtener bounds de mainWindow, luego llamar screen.getDisplayNearestPoint({ x: bounds.x, y: bounds.y }) para obtener el display correcto. Pasar el workArea de ESE display.\n- Agregar propiedad displayRightEdge al objeto que se pasa a layoutStack: displayRightEdge = display.workArea.x + display.workArea.width\n\n### window-manager.js - layoutStack()\n- Eliminar la linea 232: const primaryDisplay = require('electron').screen.getPrimaryDisplay()\n- Eliminar la linea 233: const screenRightEdge = primaryDisplay.workArea.x + primaryDisplay.workArea.width\n- En su lugar, leer screenBounds.displayRightEdge para calcular availableWidth: const availableWidth = screenBounds.displayRightEdge - startX\n- Si displayRightEdge no viene en screenBounds (backward compat), fallback a calcular con el ancho de pantalla: availableWidth = 1920 - startX\n\n## Don't\n- No cambiar la logica de strips ni de ventana activa\n- No tocar foreground-monitor.js\n- No importar electron/screen dentro de window-manager.js (recibirlo como parametro)","acceptance_criteria":"1. Cuando la app corre en un monitor secundario (izquierda del principal), las ventanas administradas ocupan solo el espacio libre de ESE monitor, no se extienden al primario. 2. Cuando la app corre en el monitor primario, el comportamiento es identico al actual. 3. availableWidth nunca es negativo ni mayor que el ancho del monitor donde esta la app.","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-20T23:13:39Z","created_by":"unknown","updated_at":"2026-02-20T23:17:31Z","closed_at":"2026-02-20T23:17:31Z","close_reason":"64e47a3 Fix multi-monitor: use getDisplayNearestPoint instead of getPrimaryDisplay","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.1","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:13:39Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.2","title":"Agregar estado customWidth/customHeight al WindowManager","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\n### Constructor\n- Agregar this.customWidth = null y this.customHeight = null. null significa usar todo el espacio disponible (comportamiento actual).\n\n### Nuevos metodos\n- setCustomDimensions(width, height): Si width no es null, clampear a Math.max(200, Number(width)). Si height no es null, clampear a Math.max(200, Number(height)). Si es null, guardar null. Guardar en this.customWidth y this.customHeight.\n- getCustomDimensions(): retorna { customWidth: this.customWidth, customHeight: this.customHeight }\n\n### getState()\n- Incluir customWidth: this.customWidth y customHeight: this.customHeight en el objeto retornado.\n\n### loadState()\n- Leer savedState.customWidth y savedState.customHeight. Si existen y no son null, asignarlos (con el mismo clamp de 200 minimo). Si no existen, dejar null.\n\n## Don't\n- No modificar layoutStack() todavia (eso es otra tarea)\n- No tocar la UI\n- No tocar preload.js ni main.js","acceptance_criteria":"1. setCustomDimensions(800, 600) guarda los valores; getCustomDimensions() retorna { customWidth: 800, customHeight: 600 }. 2. setCustomDimensions(null, null) resetea ambos a null. 3. setCustomDimensions(50, 50) clampea a { customWidth: 200, customHeight: 200 }. 4. getState() incluye customWidth y customHeight. 5. loadState({ customWidth: 900, customHeight: 700, windows: [] }) restaura los valores correctamente.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-20T23:13:48Z","created_by":"unknown","updated_at":"2026-02-20T23:17:52Z","closed_at":"2026-02-20T23:17:52Z","close_reason":"c03d80b Add customWidth/customHeight state to WindowManager","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.2","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:13:48Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.3","title":"Fix bug mainWindow null en restauracion de bounds al iniciar","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nEn app.whenReady(), hay un bug critico: en las lineas 220-228 se intenta hacer mainWindow.setBounds(savedState.bounds) pero createWindow() se llama DESPUES en la linea 240, por lo que mainWindow es null en ese punto.\n\n### Fix\n- Mover el bloque de restauracion de bounds (lineas 220-228) DESPUES de la llamada a createWindow() (linea 240).\n- El orden correcto debe ser:\n  1. persistence.init() + persistence.load()\n  2. windowManager = new WindowManager() + windowManager.loadState()\n  3. createWindow()  \u003c-- crea mainWindow\n  4. if (savedState.bounds) mainWindow.setBounds(savedState.bounds)  \u003c-- ahora mainWindow existe\n  5. foregroundMonitor.start()\n  6. registerIPC()\n\n## Don't\n- No cambiar la logica de persistencia\n- No cambiar el orden de inicializacion de windowManager o foregroundMonitor respecto a createWindow, solo mover el setBounds despues de createWindow\n- No agregar try/catch innecesarios, el bloque ya tiene validacion de savedState.bounds","acceptance_criteria":"1. La app no crashea al iniciar con un window-group.json que contiene bounds validos. 2. La app no crashea al iniciar con un window-group.json que tiene bounds: null. 3. Los bounds guardados se restauran correctamente al reiniciar (la ventana aparece en la posicion/tamano guardado).","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":10,"created_at":"2026-02-20T23:13:58Z","created_by":"unknown","updated_at":"2026-02-20T23:17:44Z","closed_at":"2026-02-20T23:17:44Z","close_reason":"235af5b fix: move setBounds after createWindow to prevent null mainWindow crash","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.3","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:13:58Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.4","title":"Integrar dimensiones custom en layoutStack","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nEn layoutStack(), despues de calcular availableWidth y availableHeight (ya corregidos por la tarea de fix multi-monitor), aplicar las dimensiones custom:\n\n### Ancho efectivo\n- Si this.customWidth !== null: effectiveWidth = Math.min(this.customWidth, availableWidth)\n- Si this.customWidth === null: effectiveWidth = availableWidth (comportamiento actual)\n\n### Alto efectivo\n- Si this.customHeight !== null: effectiveHeight = Math.min(this.customHeight, availableHeight)\n- Si this.customHeight === null: effectiveHeight = availableHeight (comportamiento actual)\n\n### Aplicar a SetWindowPos\n- Reemplazar todas las referencias a availableWidth por effectiveWidth en las llamadas a SetWindowPos (tanto para strips como para ventana activa)\n- Reemplazar availableHeight por effectiveHeight donde corresponda\n- La ventana activa: activeHeight = effectiveHeight - (inactiveCount * HEADER_HEIGHT)\n- Los strips: se posicionan con effectiveWidth de ancho y effectiveHeight de alto (para que el cuerpo quede oculto detras de la ventana activa)\n\n### Posicionamiento\n- startX no cambia (las ventanas siguen alineadas al borde derecho de la pila administrativa)\n\n## Don't\n- No cambiar el orden Z ni la logica de activacion (promoteToActive, etc)\n- No centrar las ventanas horizontalmente\n- No modificar HEADER_HEIGHT ni CONTROLLER_WIDTH","acceptance_criteria":"1. Con customWidth=800 y customHeight=600, todas las ventanas administradas tienen maximo 800px de ancho y el conjunto ocupa maximo 600px de alto. 2. Con customWidth=null y customHeight=null, se usa todo el espacio disponible del monitor (comportamiento identico al actual). 3. El ancho custom nunca excede el espacio disponible real del monitor (Math.min). 4. Los strips siguen mostrando HEADER_HEIGHT px de preview cada uno.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":40,"created_at":"2026-02-20T23:14:13Z","created_by":"unknown","updated_at":"2026-02-20T23:18:59Z","closed_at":"2026-02-20T23:18:59Z","close_reason":"Implemented effectiveWidth/effectiveHeight in layoutStack using Math.min(customDim, available)","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.4","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:14:12Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.4","depends_on_id":"StackWindowsElectron-fv5.1","type":"blocks","created_at":"2026-02-20T17:15:34Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.4","depends_on_id":"StackWindowsElectron-fv5.2","type":"blocks","created_at":"2026-02-20T17:15:35Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.5","title":"IPC handlers y preload para dimensiones custom","description":"## Files\n- src/main/main.js (modify)\n- src/main/preload.js (modify)\n\n## What to do\n### main.js - Nuevos IPC handlers\nAgregar dentro de registerIPC():\n\n1. ipcMain.handle('set-custom-dimensions', async (event, width, height) =\u003e { ... })\n   - Llamar windowManager.setCustomDimensions(width, height)\n   - Llamar doLayout()\n   - Llamar sendStateUpdate()\n   - Llamar persistence.save(windowManager.getState())\n   - Retornar { success: true }\n   - Wrap en try/catch, retornar { success: false, error: e.message } en caso de error\n\n2. ipcMain.handle('get-custom-dimensions', async () =\u003e { ... })\n   - Retornar windowManager.getCustomDimensions()\n\n### main.js - sendStateUpdate()\n- Agregar customWidth y customHeight al objeto enviado via state-update:\n  const dims = windowManager.getCustomDimensions();\n  Incluir ...dims en el objeto del send (customWidth: dims.customWidth, customHeight: dims.customHeight)\n\n### preload.js\n- Agregar al objeto expuesto por contextBridge:\n  setCustomDimensions: (width, height) =\u003e ipcRenderer.invoke('set-custom-dimensions', width, height)\n  getCustomDimensions: () =\u003e ipcRenderer.invoke('get-custom-dimensions')\n\n## Don't\n- No tocar la UI (index.html)\n- No modificar handlers IPC existentes\n- No cambiar la firma de sendStateUpdate()","acceptance_criteria":"1. Desde la consola del renderer, window.electronAPI.setCustomDimensions(800, 600) cambia las dimensiones y re-aplica el layout sin error. 2. window.electronAPI.getCustomDimensions() retorna { customWidth: 800, customHeight: 600 }. 3. El evento state-update recibido en el renderer incluye customWidth y customHeight. 4. window.electronAPI.setCustomDimensions(null, null) resetea al comportamiento por defecto.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-20T23:14:22Z","created_by":"unknown","updated_at":"2026-02-20T23:19:35Z","closed_at":"2026-02-20T23:19:35Z","close_reason":"0c14c0f Add IPC handlers and preload for custom dimensions","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.5","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:14:22Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.5","depends_on_id":"StackWindowsElectron-fv5.2","type":"blocks","created_at":"2026-02-20T17:15:35Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.6","title":"Persistencia de dimensiones custom en window-group.json","description":"## Files\n- src/main/persistence.js (modify)\n\n## What to do\n### save()\n- En el objeto data que se escribe a JSON, agregar:\n  customWidth: state.customWidth || null\n  customHeight: state.customHeight || null\n- Posicionar estos campos despues de hideAvailable y antes de bounds\n\n### load()\n- En el objeto retornado, incluir:\n  customWidth: data.customWidth || null\n  customHeight: data.customHeight || null\n- En la migracion v1 a v2, retornar customWidth: null y customHeight: null\n\n### Compatibilidad\n- NO cambiar la version del formato (sigue siendo version: 2)\n- Los campos nuevos son opcionales: si el JSON guardado no los tiene, retornar null para ambos sin error\n- La migracion v1 -\u003e v2 debe seguir funcionando\n\n## Don't\n- No cambiar el nombre del archivo (window-group.json)\n- No agregar validacion de tipos complejos, solo || null es suficiente\n- No romper la estructura existente del JSON","acceptance_criteria":"1. Guardar con dimensiones custom (800, 600) y recargar: los valores se restauran correctamente. 2. Cargar un JSON v2 antiguo (sin customWidth/customHeight): retorna null para ambos sin error. 3. Cargar un JSON v1 (array de windows): retorna null para customWidth/customHeight sin error. 4. El JSON guardado contiene los campos customWidth y customHeight.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-20T23:14:31Z","created_by":"unknown","updated_at":"2026-02-20T23:19:20Z","closed_at":"2026-02-20T23:19:20Z","close_reason":"90c736b persist customWidth/customHeight in window-group.json","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.6","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:14:31Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.6","depends_on_id":"StackWindowsElectron-fv5.2","type":"blocks","created_at":"2026-02-20T17:15:35Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.7","title":"UI - Controles de ancho y alto en el renderer","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\n### Nueva seccion HTML\nAgregar una seccion colapsable 'DIMENSIONS' entre el header y la seccion 'MANAGED STACK'. Estructura:\n\n1. section-header con titulo 'DIMENSIONS' y boton toggle para colapsar/expandir\n2. Contenido colapsable con:\n   - Un checkbox/toggle 'Custom size' (desactivado = usar todo el espacio disponible)\n   - Dos campos en linea cuando el toggle esta activo:\n     - Input numerico 'Width' con min=200, step=10, placeholder con el ancho disponible actual\n     - Input numerico 'Height' con min=200, step=10, placeholder con el alto disponible actual\n   - Boton 'Apply' que llama window.electronAPI.setCustomDimensions(widthValue, heightValue)\n   - Boton 'Reset' que llama window.electronAPI.setCustomDimensions(null, null) y desactiva el toggle\n\n### CSS\n- Estilo consistente con el diseno existente: fondo negro (#000), texto blanco, bordes #333\n- Inputs numericos: fondo #111, borde #444, texto blanco, ancho ~70px cada uno\n- Labels: font-size 10px, color #888, uppercase\n- Seccion colapsada por defecto al iniciar\n\n### JavaScript\n- Variable global customSizeEnabled = false\n- Al recibir state-update con customWidth/customHeight no-null, activar el toggle y llenar los inputs\n- Al recibir state-update con customWidth/customHeight null, desactivar el toggle\n- El boton Apply solo se habilita cuando ambos inputs tienen valores \u003e= 200\n- Funcion toggleDimensionsSection() para colapsar/expandir (similar a toggleAvailableVisibility pero sin resize de la app)\n\n## Don't\n- No usar frameworks (mantener vanilla JS/HTML/CSS inline)\n- No agregar sliders ni range inputs, solo inputs numericos type=number\n- No permitir valores menores a 200 (validar en el onclick de Apply)\n- No modificar las secciones existentes de Managed Stack ni Available Windows\n- No llamar a resizeApp desde esta seccion","acceptance_criteria":"1. La seccion DIMENSIONS aparece entre el header y MANAGED STACK. 2. El toggle Custom size activa/desactiva los inputs. 3. Ingresar 800x600 y hacer clic en Apply llama setCustomDimensions(800, 600) y las ventanas se redimensionan. 4. Reset vuelve al comportamiento de pantalla completa (setCustomDimensions(null, null)). 5. Los valores persisten al recargar la app (se restauran desde state-update). 6. La seccion se puede colapsar/expandir. 7. Estilo visual consistente con el resto de la app.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-20T23:14:48Z","created_by":"unknown","updated_at":"2026-02-20T23:21:23Z","closed_at":"2026-02-20T23:21:23Z","close_reason":"Implemented DIMENSIONS collapsible section with custom size toggle, width/height inputs, Apply/Reset buttons, and state sync in src/renderer/index.html","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.7","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:14:48Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.7","depends_on_id":"StackWindowsElectron-fv5.5","type":"blocks","created_at":"2026-02-20T17:15:36Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-h6u","title":"Epic: Reduce CPU spike on window switch (~25%% to \u003c5%%)","description":"## Goals\nWhen the user switches between managed windows, CPU usage spikes from 1-3%% idle to ~25%% (saturating one core). This epic targets reducing that spike to under 5%%.\n\n## Root Causes Identified\n1. **Animation at 60fps via FFI** - _animateLayout() runs setTimeout(tick, 1000/60) for 200ms, making ~12 frames x N windows x 3 FFI calls per frame = ~60+ FFI calls crossing JS-\u003eC-\u003ekernel boundary in 200ms\n2. **Synchronous disk write on every focus change** - persistence.save() uses fs.writeFileSync() blocking the event loop on every window switch\n3. **Redundant persistence saves** - save() is called on every focus change AND every 10s auto-save timer, with no debouncing between them\n\n## Success Criteria\n- CPU spike on window switch drops from ~25%% to \u003c5%% with 3 managed windows\n- Animation remains visually smooth (no perceptible jank)\n- Window state is still persisted reliably (no data loss on crash)\n- No new dependencies added\n\n## Key Constraints\n- Must remain pure vanilla JS (no frameworks, no TypeScript)\n- Must not break existing Win32 FFI bridge (koffi/user32.dll)\n- Animation must remain in Electron main process\n- Must maintain backward compatibility with persistence format v2\n- All changes testable by running the app and managing 2-3 windows","status":"closed","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-22T06:22:03Z","created_by":"unknown","updated_at":"2026-02-25T17:15:32Z","closed_at":"2026-02-25T17:15:32Z","close_reason":"Closed","labels":["needs-integration-review","scope:medium"]}
{"id":"StackWindowsElectron-h6u.1","title":"Reduce animation frame rate from 60fps to 30fps","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nIn _animateLayout() at line 476, the animation loop schedules frames at 60fps:\n  setTimeout(tick, 1000 / 60)  // ~16.67ms per frame\n\nChange this to 30fps:\n  setTimeout(tick, 1000 / 30)  // ~33.33ms per frame\n\nThis halves the number of FFI calls (BeginDeferWindowPos + DeferWindowPos*N + EndDeferWindowPos) from ~12 frames to ~6 frames over the 200ms animation duration. Each FFI call crosses the JS-\u003eC-\u003ekernel boundary which is the primary CPU cost.\n\nSimilarly, in _animateRestore() at line 347, change the restore animation frame rate:\n  setTimeout(tick, 1000 / 60)  →  setTimeout(tick, 1000 / 30)\n\n### Why 30fps is sufficient\n- The animation duration is only 200ms (barely perceptible)\n- Window repositioning via SetWindowPos has inherent latency from the Windows compositor\n- 30fps gives 6 frames over 200ms which is enough for smooth cubic ease-out\n- The final snap frame ensures pixel-perfect positioning regardless of frame count\n\n### Implementation\n1. Find line 476 in _animateLayout(): change 1000 / 60 to 1000 / 30\n2. Find line 347 in _animateRestore(): change 1000 / 60 to 1000 / 30\n3. No other changes needed - the timestamp-based progress calculation automatically adapts\n\n## Don't\n- Don't change the animation duration (200ms layout, 250ms restore)\n- Don't change the easing function\n- Don't change the DeferWindowPos batching logic\n- Don't change the final snap logic\n- Don't add any new dependencies\n- Don't modify any other files","acceptance_criteria":"1. Line 476 in _animateLayout uses setTimeout(tick, 1000 / 30) instead of 1000 / 60\n2. Line 347 in _animateRestore uses setTimeout(tick, 1000 / 30) instead of 1000 / 60\n3. App launches without errors\n4. Switching between 3 managed windows still animates smoothly (no visible jank)\n5. Animation still completes in ~200ms (duration unchanged)\n6. CPU spike during window switch is measurably lower than before (fewer FFI calls per animation)","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-22T06:22:29Z","created_by":"unknown","updated_at":"2026-02-22T06:37:28Z","closed_at":"2026-02-22T06:37:28Z","close_reason":"5b37b67 Reduce animation frame rate from 60fps to 30fps","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-h6u.1","depends_on_id":"StackWindowsElectron-h6u","type":"parent-child","created_at":"2026-02-22T00:22:28Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-h6u.2","title":"Replace fs.writeFileSync with async fs.promises.writeFile in persistence.save()","description":"## Files\n- src/main/persistence.js (modify)\n\n## What to do\nCurrently persistence.save() at line 33-48 uses fs.writeFileSync() which blocks the Node.js event loop during disk I/O. This is called on every window focus change, contributing to the CPU spike.\n\n### Changes to persistence.js\n\n1. Change save() from synchronous to async:\n   - Change method signature: save(state) → async save(state)\n   - Replace fs.writeFileSync(this.filePath, ...) with await fs.promises.writeFile(this.filePath, ...)\n   - Keep the same JSON.stringify(data, null, 2) formatting\n   - Keep the same try/catch error handling\n\n2. Add a write guard to prevent concurrent writes:\n   - Add this._writing = false in constructor\n   - At the start of save(), if this._writing is true, store the state in this._pendingState and return\n   - Set this._writing = true before the write\n   - After the write completes, set this._writing = false\n   - If this._pendingState is set, call save(this._pendingState) and clear this._pendingState\n   - This ensures the latest state is always eventually written without overlapping writes\n\n3. Add a synchronous saveSync(state) method:\n   - Move the current synchronous logic to saveSync()\n   - This is needed for app quit (before-quit, window-all-closed) where we MUST write synchronously before the process exits\n\n### Why this matters\nfs.writeFileSync blocks the event loop for the entire duration of the disk write. On a typical SSD this is 1-5ms, but on slower drives or when the OS is busy, it can be 10-50ms. During animation (which runs at 30fps = 33ms per frame), a 10ms block means dropping a frame.\n\n## Don't\n- Don't change the JSON format or structure\n- Don't change the file path logic\n- Don't change the load() method (it can stay synchronous - only runs at startup)\n- Don't change the clear() method\n- Don't add any new dependencies\n- Don't change the version number in the saved data","acceptance_criteria":"1. save() is an async method using await fs.promises.writeFile\n2. saveSync() exists as a synchronous fallback using fs.writeFileSync\n3. Concurrent save() calls don't produce corrupted files (write guard prevents overlapping writes)\n4. The latest state is always eventually written (pending state is flushed after current write)\n5. App launches without errors and window-group.json is written correctly\n6. App quit still saves state reliably (uses saveSync path)\n7. No change to the JSON format or file location","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":25,"created_at":"2026-02-22T06:22:48Z","created_by":"unknown","updated_at":"2026-02-22T06:37:30Z","closed_at":"2026-02-22T06:37:30Z","close_reason":"5b37b67 Replace fs.writeFileSync with async fs.promises.writeFile in persistence.save()","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-h6u.2","depends_on_id":"StackWindowsElectron-h6u","type":"parent-child","created_at":"2026-02-22T00:22:47Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-h6u.3","title":"Switch main.js callers to use async save() and saveSync() for quit paths","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nAfter persistence.save() becomes async (task h6u.2), all callers in main.js need to be updated. Currently persistence.save() is called in 8 places in main.js. Some can be fire-and-forget async, others (quit handlers) must use saveSync().\n\n### Calls that should use async save() (fire-and-forget, no await needed):\nThese are in event handlers where we don't need to wait for the write to complete:\n\n1. Line 112 in onManagedWindowFocused(): persistence.save(windowManager.getState())\n2. Line 151 in add-window handler: persistence.save(windowManager.getState())\n3. Line 165 in remove-window handler: persistence.save(windowManager.getState())\n4. Line 181 in activate-window handler: persistence.save(windowManager.getState())\n5. Line 200 in update-stack-name handler: persistence.save(windowManager.getState())\n6. Line 207 in toggle-available-visibility handler: persistence.save(windowManager.getState())\n7. Line 229 in set-custom-dimensions handler: persistence.save(windowManager.getState())\n8. Line 249 in set-background-color handler: persistence.save(windowManager.getState())\n9. Line 315 in auto-save timer (setInterval every 10s): persistence.save(windowManager.getState())\n\nAll of these are already fire-and-forget (return value is not used). Since save() is now async, these will return a Promise that resolves in the background. No change needed to these lines - they will work as-is because calling an async function without await just runs it in the background.\n\n### Calls that MUST use saveSync() (synchronous quit paths):\nThese are in quit handlers where the process may exit immediately after:\n\n1. Line 327 in window-all-closed handler: change to persistence.saveSync(windowManager.getState())\n2. Line 338 in before-quit handler: change to persistence.saveSync(windowManager.getState())\n\n### Also update the resize handler:\n3. Line 52-53 in mainWindow resize handler: the save call here fires on every resize pixel. Keep it as async save() but this is fine since the debounce in task h6u.4 will handle coalescing.\n\n## Don't\n- Don't add await to the fire-and-forget save() calls (unnecessary, would slow down the handlers)\n- Don't change the logic of any handler (only the save method name for quit paths)\n- Don't modify persistence.js (that's task h6u.2)\n- Don't modify window-manager.js\n- Don't change the auto-save timer interval","acceptance_criteria":"1. Lines 327 and 338 (quit handlers) use persistence.saveSync() instead of persistence.save()\n2. All other persistence.save() calls remain as-is (they work as fire-and-forget with async)\n3. App launches without errors\n4. Quitting the app (closing window or Ctrl+C) still saves state to window-group.json\n5. Window state is correctly persisted after add/remove/activate operations\n6. No unhandled promise rejection warnings in console","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-22T06:23:09Z","created_by":"unknown","updated_at":"2026-02-22T06:40:06Z","closed_at":"2026-02-22T06:40:06Z","close_reason":"986b906 Switch quit handlers to use saveSync() for reliable state persistence","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-h6u.3","depends_on_id":"StackWindowsElectron-h6u","type":"parent-child","created_at":"2026-02-22T00:23:08Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-h6u.3","depends_on_id":"StackWindowsElectron-h6u.2","type":"blocks","created_at":"2026-02-22T00:24:24Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-h6u.4","title":"Add debounced persistence save wrapper in main.js","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nCurrently every window focus change triggers an immediate persistence.save(). With 3 managed windows and rapid Alt-Tab, this can fire 5+ saves per second. Add a debounce wrapper so saves are coalesced.\n\n### Implementation\n\n1. Add a module-level debounce wrapper at the top of main.js (near the other timer variables around line 14-15):\n   let _saveDebounceTimer = null;\n   const SAVE_DEBOUNCE_MS = 2000; // 2 seconds\n\n   function debouncedSave() {\n     if (_saveDebounceTimer) clearTimeout(_saveDebounceTimer);\n     _saveDebounceTimer = setTimeout(() =\u003e {\n       _saveDebounceTimer = null;\n       if (windowManager) {\n         persistence.save(windowManager.getState());\n       }\n     }, SAVE_DEBOUNCE_MS);\n   }\n\n2. Replace persistence.save(windowManager.getState()) with debouncedSave() in these HIGH-FREQUENCY callers:\n   - onManagedWindowFocused() (line 112) - fires on every Alt-Tab\n   - mainWindow resize handler (line 52-53) - fires on every resize pixel\n\n3. Keep IMMEDIATE persistence.save() for these USER-INITIATED actions (low frequency, user expects immediate save):\n   - add-window handler (line 151)\n   - remove-window handler (line 165)\n   - activate-window handler (line 181)\n   - update-stack-name handler (line 200)\n   - toggle-available-visibility handler (line 207)\n   - set-custom-dimensions handler (line 229)\n   - set-background-color handler (line 249)\n\n4. Keep the auto-save timer at 10s (line 313-317) as a safety net.\n\n5. Clean up _saveDebounceTimer in window-all-closed handler (line 320):\n   if (_saveDebounceTimer) clearTimeout(_saveDebounceTimer);\n\n6. In the quit handlers (window-all-closed, before-quit), flush any pending debounced save immediately by clearing the timer and calling saveSync():\n   if (_saveDebounceTimer) {\n     clearTimeout(_saveDebounceTimer);\n     _saveDebounceTimer = null;\n   }\n   // saveSync is already called in these handlers (from task h6u.3)\n\n## Don't\n- Don't debounce user-initiated actions (add, remove, activate, etc.)\n- Don't change the auto-save timer interval\n- Don't modify persistence.js\n- Don't modify window-manager.js\n- Don't use lodash or any external debounce library","acceptance_criteria":"1. A debouncedSave() function exists with 2000ms debounce delay\n2. onManagedWindowFocused uses debouncedSave() instead of direct persistence.save()\n3. mainWindow resize handler uses debouncedSave() instead of direct persistence.save()\n4. User-initiated actions (add, remove, activate, etc.) still use immediate persistence.save()\n5. _saveDebounceTimer is cleaned up in window-all-closed handler\n6. Rapid Alt-Tab between 3 windows produces at most 1 save per 2 seconds (not 5+ per second)\n7. App launches without errors; state is still persisted correctly","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-22T06:23:27Z","created_by":"unknown","updated_at":"2026-02-22T06:40:37Z","closed_at":"2026-02-22T06:40:37Z","close_reason":"1dac10f Add debounced persistence save wrapper in main.js","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-h6u.4","depends_on_id":"StackWindowsElectron-h6u","type":"parent-child","created_at":"2026-02-22T00:23:27Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-h6u.4","depends_on_id":"StackWindowsElectron-h6u.2","type":"blocks","created_at":"2026-02-22T00:24:24Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-h6u.5","title":"Reduce default animation duration from 200ms to 100ms","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nThe current animation duration is 200ms (set via this.animationDuration in the constructor at line 28). At 30fps (after task h6u.1), this means ~6 frames of FFI calls. Reducing to 100ms cuts it to ~3 frames, further halving the CPU cost.\n\n### Changes\n\n1. In the WindowManager constructor (line 28), change the default animation duration:\n   this.animationDuration = options.animationDuration || 100;  // was 200\n\n2. In the constructor (line 30), change the default restore animation duration:\n   this.restoreAnimationDuration = options.restoreAnimationDuration || 150;  // was 250\n\n### Why 100ms is sufficient\n- 200ms was chosen for visual smoothness, but with cubic ease-out easing, 100ms still looks smooth because most of the motion happens in the first 50ms\n- Window managers like Windows 11 Snap use ~150ms animations\n- The user is switching focus, so their attention is on the target window, not the animation\n- The final snap frame ensures pixel-perfect positioning regardless of duration\n\n### Fallback\nThe durations are configurable via constructor options, so if 100ms feels too fast, it can be tuned back up without code changes (just pass options to new WindowManager({ animationDuration: 150 }) in main.js).\n\n## Don't\n- Don't change the easing function\n- Don't change the frame rate (that's task h6u.1)\n- Don't change the animation logic\n- Don't change main.js (it uses defaults)\n- Don't remove the options.animationDuration override capability","acceptance_criteria":"1. this.animationDuration defaults to 100 (was 200)\n2. this.restoreAnimationDuration defaults to 150 (was 250)\n3. App launches without errors\n4. Window switch animation completes in ~100ms (visually faster but still smooth)\n5. Window removal animation completes in ~150ms\n6. Passing options.animationDuration = 200 to constructor still works (override capability preserved)","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":10,"created_at":"2026-02-22T06:23:45Z","created_by":"unknown","updated_at":"2026-02-22T06:37:59Z","closed_at":"2026-02-22T06:37:59Z","close_reason":"6466c77 Reduce default animation duration from 200ms to 100ms","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-h6u.5","depends_on_id":"StackWindowsElectron-h6u","type":"parent-child","created_at":"2026-02-22T00:23:44Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-h6u.6","title":"Add skip-animation option to bypass animation entirely","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nAdd a constructor option to completely skip animation and snap windows to their target positions instantly. This is the nuclear option for users who want zero CPU overhead on window switch.\n\n### Changes to WindowManager constructor (line 14-31)\nAdd a new option:\n  this.skipAnimation = options.skipAnimation || false;\n\n### Changes to _animateLayout() (line 363)\nAt the very beginning of _animateLayout(), add an early-exit path:\n\n  if (this.skipAnimation) {\n    // Instant snap: single DeferWindowPos batch, no animation loop\n    const hWinPosInfo = api.BeginDeferWindowPos(targetLayouts.length);\n    if (hWinPosInfo) {\n      let hInfo = hWinPosInfo;\n      for (const target of targetLayouts) {\n        if (target.restore) {\n          api.ShowWindow(target.hwnd, SW_RESTORE);\n        }\n        hInfo = api.DeferWindowPos(hInfo, target.hwnd, HWND_TOP, target.x, target.y, target.cx, target.cy, target.flags);\n        if (!hInfo) break;\n      }\n      if (hInfo) api.EndDeferWindowPos(hInfo);\n    } else {\n      // Fallback: individual SetWindowPos\n      for (const target of targetLayouts) {\n        if (target.restore) api.ShowWindow(target.hwnd, SW_RESTORE);\n        api.SetWindowPos(target.hwnd, HWND_TOP, target.x, target.y, target.cx, target.cy, target.flags);\n      }\n    }\n    return;\n  }\n\n### Changes to _animateRestore() (line 288)\nAt the very beginning, add:\n\n  if (this.skipAnimation) {\n    this._restoreWindow(entry);\n    callback();\n    return;\n  }\n\n### No changes to main.js\nThe default is skipAnimation: false, so existing behavior is preserved. Users who want to enable it can modify main.js to pass { skipAnimation: true } to the WindowManager constructor.\n\n## Don't\n- Don't enable skipAnimation by default (must be opt-in)\n- Don't add UI controls for this option (internal only)\n- Don't change the animation logic when skipAnimation is false\n- Don't modify main.js\n- Don't modify any other files","acceptance_criteria":"1. this.skipAnimation defaults to false in constructor\n2. When skipAnimation is false, animation works exactly as before (no behavior change)\n3. When skipAnimation is true, _animateLayout snaps windows instantly with a single DeferWindowPos batch (no setTimeout loop)\n4. When skipAnimation is true, _animateRestore calls _restoreWindow directly and invokes callback\n5. App launches without errors with default options\n6. Manually testing with new WindowManager({ skipAnimation: true }) in main.js shows instant window positioning with no animation","status":"closed","priority":3,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-22T06:24:03Z","created_by":"unknown","updated_at":"2026-02-22T06:38:54Z","closed_at":"2026-02-22T06:38:54Z","close_reason":"e110b65 Add skipAnimation option to bypass animation entirely","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-h6u.6","depends_on_id":"StackWindowsElectron-h6u","type":"parent-child","created_at":"2026-02-22T00:24:02Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-lh1","title":"Epic: Configurable gap between admin panel and managed windows","description":"## Goals\nAdd a configurable horizontal gap (in pixels) between the admin panel (BrowserWindow) and the managed windows. Currently the managed windows start immediately at the right edge of the admin panel (startX = bounds.x + bounds.width). The user wants a space between them so they can resize the admin panel without covering windows from other stack instances.\n\n## Current Layout\n```\n[Admin Panel 300px][Window A fills rest of monitor]\n                   ^ startX = bounds.x + bounds.width (no gap)\n```\n\n## Desired Layout\n```\n[Admin Panel 300px]  gap  [Window A]\n                   ^      ^ startX = bounds.x + bounds.width + stackGap\n```\n\n## Implementation Pattern\nFollow the exact same pattern as customWidth/customHeight:\n1. WindowManager stores stackGap (default 0, min 0, max 500)\n2. layoutStack() adds stackGap to startX and subtracts it from availableWidth\n3. IPC handler set-stack-gap / get-stack-gap\n4. Preload bridge exposes setStackGap / getStackGap\n5. UI: add a GAP input field in the DIMENSIONS section (alongside width/height)\n6. Persistence: save/load stackGap in getState/loadState\n7. State updates: include stackGap in sendStateUpdate\n\n## Key Constraints\n- Must follow the existing customWidth/customHeight pattern exactly\n- Gap of 0 = current behavior (no gap)\n- Gap must be clamped so windows still have at least 200px of space\n- Must persist across sessions\n- Must be part of the DIMENSIONS section UI (not a new section)","status":"closed","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-25T16:23:50Z","created_by":"unknown","updated_at":"2026-02-25T16:30:01Z","closed_at":"2026-02-25T16:30:01Z","close_reason":"Closed","labels":["scope:small"]}
{"id":"StackWindowsElectron-lh1.1","title":"Add stackGap property to WindowManager with persistence and layout integration","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\n\n### 1. Add stackGap property in constructor (~line 14, after backgroundColor):\n```js\nthis.stackGap = 0; // pixels of horizontal gap between controller and managed windows\n```\n\n### 2. Modify layoutStack() (~line 596):\nAfter calculating startX (line 601), add the gap:\n```js\nconst startX = workArea.x + workArea.width + this.stackGap;\n```\nAnd subtract the gap from availableWidth (line 608):\n```js\nconst availableWidth = displayRightEdge - startX;\n```\nThis already works because startX now includes the gap, so availableWidth is automatically reduced. No other change needed in layoutStack.\n\n### 3. Add setStackGap(gap) method (after setCustomDimensions, ~line 749):\n```js\n/**\n * Set the horizontal gap between the controller panel and managed windows.\n * @param {number} gap - Gap in pixels (0 = no gap, clamped to 0-500)\n */\nsetStackGap(gap) {\n  this.stackGap = gap !== null \u0026\u0026 gap !== undefined\n    ? Math.max(0, Math.min(500, Math.round(Number(gap))))\n    : 0;\n}\n```\n\n### 4. Add getStackGap() method (after setStackGap):\n```js\n/**\n * Get the current stack gap.\n * @returns {number}\n */\ngetStackGap() {\n  return this.stackGap;\n}\n```\n\n### 5. Add stackGap to getState() (~line 762):\nAdd after customHeight line:\n```js\nstackGap: this.stackGap,\n```\n\n### 6. Add stackGap to loadState() (~line 782):\nAfter the customHeight restoration block (~line 801), add:\n```js\nif (savedState.stackGap !== null \u0026\u0026 savedState.stackGap !== undefined) {\n  this.stackGap = Math.max(0, Math.min(500, Math.round(Number(savedState.stackGap))));\n} else {\n  this.stackGap = 0;\n}\n```\n\n## Don't\n- Don't modify main.js, preload.js, or index.html (those are separate tasks)\n- Don't change the CONTROLLER_WIDTH or HEADER_HEIGHT constants\n- Don't change any existing methods besides layoutStack, getState, and loadState","acceptance_criteria":"1. WindowManager has a stackGap property initialized to 0 in the constructor\n2. layoutStack() uses this.stackGap to offset startX: startX = workArea.x + workArea.width + this.stackGap\n3. setStackGap(gap) clamps the value to 0-500 and rounds to integer\n4. setStackGap(null) or setStackGap(undefined) resets to 0\n5. getStackGap() returns the current value\n6. getState() includes stackGap in the returned object\n7. loadState() restores stackGap from saved state (clamped 0-500), defaults to 0 if missing\n8. node --check src/main/window-manager.js passes","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-25T16:24:09Z","created_by":"unknown","updated_at":"2026-02-25T16:26:53Z","closed_at":"2026-02-25T16:26:53Z","close_reason":"c71d52c Add stackGap property to WindowManager with persistence and layout integration","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-lh1.1","depends_on_id":"StackWindowsElectron-lh1","type":"parent-child","created_at":"2026-02-25T10:24:08Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-lh1.1","depends_on_id":"StackWindowsElectron-lh1.2","type":"blocks","created_at":"2026-02-25T10:24:23Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-lh1.2","title":"Add IPC handler and preload bridge for stackGap","description":"## Files\n- src/main/main.js (modify)\n- src/main/preload.js (modify)\n\n## What to do\n\n### 1. main.js — Add IPC handler for set-stack-gap (after the set-background-color handler, ~line 313):\n```js\nipcMain.handle('set-stack-gap', async (event, gap) =\u003e {\n  try {\n    if (gap !== null \u0026\u0026 (typeof gap !== 'number' || !Number.isFinite(gap) || gap \u003c 0)) {\n      throw new Error('Invalid gap: must be null or a non-negative number');\n    }\n    windowManager.setStackGap(gap);\n    doLayout();\n    sendStateUpdate();\n    persistence.save(windowManager.getState());\n    return { success: true };\n  } catch (e) {\n    console.error('set-stack-gap error:', e);\n    return { success: false, error: e.message };\n  }\n});\n```\n\n### 2. main.js — Add stackGap to sendStateUpdate() (~line 119):\nAdd stackGap to the state-update payload, after backgroundColor:\n```js\nstackGap: windowManager.getStackGap()\n```\n\n### 3. main.js — Add stackGap to get-managed-windows handler (~line 173):\nAdd stackGap to the returned object, after backgroundColor:\n```js\nstackGap: windowManager.getStackGap()\n```\n\n### 4. preload.js — Add setStackGap bridge (after setBackgroundColor, ~line 37):\n```js\n// Stack gap (space between controller and managed windows)\nsetStackGap: (gap) =\u003e ipcRenderer.invoke('set-stack-gap', gap),\n```\n\n## Don't\n- Don't modify window-manager.js (already done in lh1.1)\n- Don't modify index.html (separate task)\n- Don't add a get-stack-gap handler (the value is already sent via state-update and get-managed-windows)","acceptance_criteria":"1. IPC handler 'set-stack-gap' exists and calls windowManager.setStackGap(gap), then doLayout(), sendStateUpdate(), and persistence.save()\n2. Invalid gap values (negative, non-number, non-finite) throw an error and return { success: false }\n3. sendStateUpdate() includes stackGap in the state-update payload\n4. get-managed-windows handler includes stackGap in the response\n5. preload.js exposes window.electronAPI.setStackGap(gap)\n6. node --check passes for both main.js and preload.js","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":25,"created_at":"2026-02-25T16:24:23Z","created_by":"unknown","updated_at":"2026-02-25T16:28:05Z","closed_at":"2026-02-25T16:28:05Z","close_reason":"50bf515 Add IPC handler and preload bridge for stackGap","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-lh1.2","depends_on_id":"StackWindowsElectron-lh1","type":"parent-child","created_at":"2026-02-25T10:24:23Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-lh1.2","depends_on_id":"StackWindowsElectron-lh1.3","type":"blocks","created_at":"2026-02-25T10:24:46Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-lh1.3","title":"Add GAP input to DIMENSIONS section in renderer UI","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\nAdd a GAP input field to the existing DIMENSIONS section, following the exact same pattern as WIDTH and HEIGHT.\n\n### 1. HTML — Add GAP field inside dimsInputs div (~line 411, after the HEIGHT dims-field):\nAdd a third dims-field for GAP right after the HEIGHT field and before the closing \u003c/div\u003e of dimsInputs:\n```html\n\u003cdiv class=\"dims-field\"\u003e\n  \u003clabel class=\"dims-input-label\"\u003eGAP\u003c/label\u003e\n  \u003cinput type=\"number\" id=\"stackGapInput\" min=\"0\" max=\"500\" step=\"10\" placeholder=\"0\"\u003e\n\u003c/div\u003e\n```\n\nThe dimsInputs div should now contain three fields: WIDTH, HEIGHT, GAP.\n\n### 2. JavaScript — Modify applyCustomDimensions() (~line 515):\nAfter reading w and h, also read the gap value and send it:\n```js\nasync function applyCustomDimensions() {\n  const w = parseInt(document.getElementById('customWidthInput').value);\n  const h = parseInt(document.getElementById('customHeightInput').value);\n  const gap = parseInt(document.getElementById('stackGapInput').value);\n  if (!w || w \u003c 200 || !h || h \u003c 200) {\n    return; // Don't apply invalid values\n  }\n  try {\n    await window.electronAPI.setCustomDimensions(w, h);\n    if (!isNaN(gap) \u0026\u0026 gap \u003e= 0) {\n      await window.electronAPI.setStackGap(gap);\n    }\n  } catch (e) {\n    console.error('Failed to set custom dimensions:', e);\n  }\n}\n```\n\n### 3. JavaScript — Modify resetCustomDimensions() (~line 528):\nAlso reset the gap input and send gap=0:\n```js\nasync function resetCustomDimensions() {\n  try {\n    await window.electronAPI.setCustomDimensions(null, null);\n    await window.electronAPI.setStackGap(0);\n    document.getElementById('customWidthInput').value = '';\n    document.getElementById('customHeightInput').value = '';\n    document.getElementById('stackGapInput').value = '';\n    document.getElementById('customSizeToggle').checked = false;\n    document.getElementById('dimsInputs').classList.add('hidden');\n    document.getElementById('dimsButtons').classList.add('hidden');\n    customSizeEnabled = false;\n  } catch (e) {\n    console.error('Failed to reset dimensions:', e);\n  }\n}\n```\n\n### 4. JavaScript — Sync gap from state updates (~line 945, in the onStateUpdate handler):\nInside the block that syncs customWidth/customHeight (around line 965-990), add gap sync after the existing dimension sync:\n```js\n// Sync stack gap from state\nif (data.stackGap !== undefined) {\n  const gapInput = document.getElementById('stackGapInput');\n  if (gapInput \u0026\u0026 document.activeElement !== gapInput) {\n    gapInput.value = data.stackGap || '';\n  }\n}\n```\n\n### 5. JavaScript — Sync gap on initial load:\nIn the getManagedWindows() initial load block (search for 'getManagedWindows'), after syncing customWidth/customHeight, add:\n```js\nif (data.stackGap !== undefined \u0026\u0026 data.stackGap \u003e 0) {\n  document.getElementById('stackGapInput').value = data.stackGap;\n}\n```\n\n## Don't\n- Don't modify any backend files (main.js, window-manager.js, preload.js)\n- Don't create a new section — add the GAP field inside the existing DIMENSIONS section\n- Don't change the existing WIDTH/HEIGHT fields or their behavior\n- Don't make GAP required — it's optional, default 0 means no gap","acceptance_criteria":"1. A GAP input field appears in the DIMENSIONS section alongside WIDTH and HEIGHT\n2. The GAP input has min=0, max=500, step=10, placeholder='0'\n3. Clicking Apply sends both setCustomDimensions(w, h) and setStackGap(gap)\n4. Clicking Reset clears the GAP input and sends setStackGap(0)\n5. The GAP value syncs from state updates (onStateUpdate handler)\n6. The GAP value syncs on initial load from getManagedWindows response\n7. If GAP is empty or 0, no gap is applied (default behavior)\n8. No JavaScript errors in the console","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-25T16:24:46Z","created_by":"unknown","updated_at":"2026-02-25T16:29:34Z","closed_at":"2026-02-25T16:29:34Z","close_reason":"fa63b26 Add GAP input to DIMENSIONS section in renderer UI","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-lh1.3","depends_on_id":"StackWindowsElectron-lh1","type":"parent-child","created_at":"2026-02-25T10:24:46Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-ly9","title":"Epic: Rename managed windows in the stack","description":"## Goal\nAllow the user to rename any managed window in the stack to a custom alias. Currently the title shown is whatever Win32 reports (often a browser tab name or irrelevant text). The user wants to set their own label for better control.\n\n## Current Problem\n- Window titles come from Win32 GetWindowTextW and are stored as-is in managedWindows[].title\n- There is no way to edit them from the UI\n- The title persisted is whatever the OS reports, which may be a random browser tab\n\n## What Success Looks Like\n1. Each managed window item in the UI has a way to rename it (double-click on title text)\n2. The custom name is stored in the managedWindows entry as 'customTitle'\n3. The UI displays customTitle when set, falling back to the original title\n4. The custom name persists across the session (saved in the persistence file)\n5. The rename is inline — no modal dialogs\n\n## Key Constraints\n- Must not break existing UI layout or DOM-diffing logic\n- The original Win32 title should still be stored (for reference), the custom title is an overlay\n- No new dependencies","status":"closed","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-23T21:06:37Z","created_by":"unknown","updated_at":"2026-02-25T17:15:29Z","closed_at":"2026-02-25T17:15:29Z","close_reason":"Closed","labels":["needs-integration-review","scope:small"]}
{"id":"StackWindowsElectron-ly9.1","title":"Add renameWindow method to WindowManager","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\n\n### 1. Add a new field 'customTitle' to managed window entries\n\nIn addWindow() (line 147-151), add `customTitle: null` to the entry object:\n```js\nconst entry = {\n  hwnd: hwndNum,\n  title: title || this._getWindowTitle(hwndNum) || 'Untitled',\n  customTitle: null,   // \u003c-- NEW: user-defined alias, null = use original title\n  processId: pidBuf[0],\n  originalRect: { ... }\n};\n```\n\n### 2. Add renameWindow(hwnd, customTitle) method\n\n```js\n/**\n * Set a custom display name for a managed window.\n * Pass null or empty string to clear the custom name (revert to Win32 title).\n * @param {number} hwnd\n * @param {string|null} customTitle\n * @returns {boolean} true if the window was found and renamed\n */\nrenameWindow(hwnd, customTitle) {\n  const hwndNum = Number(hwnd);\n  const entry = this.managedWindows.find(w =\u003e w.hwnd === hwndNum);\n  if (!entry) return false;\n  entry.customTitle = (customTitle \u0026\u0026 customTitle.trim()) || null;\n  return true;\n}\n```\n\n### 3. Update getManagedWindows() to include customTitle\n\nChange the return map (line 638) to also include customTitle:\n```js\ngetManagedWindows() {\n  return this.managedWindows.map(w =\u003e ({\n    hwnd: w.hwnd,\n    title: w.title,\n    customTitle: w.customTitle || null,\n    processId: w.processId\n  }));\n}\n```\n\n### 4. Update getState() to persist customTitle\n\nChange the windows map in getState() (line 679) to include customTitle:\n```js\nwindows: this.managedWindows.map(w =\u003e ({\n  hwnd: w.hwnd,\n  title: w.title,\n  customTitle: w.customTitle || null,\n  processId: w.processId,\n  originalRect: w.originalRect\n}))\n```\n\n### 5. Update loadState() to restore customTitle\n\nIn the loadState() loop (line 732), add customTitle when pushing:\n```js\nthis.managedWindows.push({\n  hwnd: hwndNum,\n  title: title,\n  customTitle: saved.customTitle || null,   // \u003c-- NEW\n  processId: saved.processId || 0,\n  originalRect: saved.originalRect || { left: 100, top: 100, right: 900, bottom: 700 }\n});\n```\n\n## Don't\n- Don't change the title field itself — it always holds the Win32 title\n- Don't change any layout, animation, or Win32 API logic\n- Don't add imports","acceptance_criteria":"1. renameWindow(hwnd, 'My App') sets customTitle on the matching entry and returns true\n2. renameWindow(hwnd, '') clears customTitle to null\n3. renameWindow(invalidHwnd, 'x') returns false\n4. getManagedWindows() includes customTitle field (null when not set)\n5. getState() includes customTitle in serialized windows array\n6. loadState() restores customTitle from saved data\n7. addWindow() initializes customTitle as null\n8. No other methods changed","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-23T21:06:56Z","created_by":"unknown","updated_at":"2026-02-23T21:09:11Z","closed_at":"2026-02-23T21:09:11Z","close_reason":"32635f8 Add renameWindow method to WindowManager","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-ly9.1","depends_on_id":"StackWindowsElectron-ly9","type":"parent-child","created_at":"2026-02-23T15:06:56Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-ly9.1","depends_on_id":"StackWindowsElectron-ly9.3","type":"blocks","created_at":"2026-02-23T15:07:45Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-ly9.2","title":"Add rename-window IPC handler and preload bridge","description":"## Files\n- src/main/main.js (modify)\n- src/main/preload.js (modify)\n\n## What to do\n\n### 1. Add IPC handler in main.js registerIPC() function\n\nAdd this new handler inside registerIPC(), after the existing 'activate-window' handler:\n\n```js\nipcMain.handle('rename-window', async (event, hwnd, customTitle) =\u003e {\n  try {\n    const found = windowManager.renameWindow(hwnd, customTitle);\n    if (found) {\n      sendStateUpdate();\n      persistence.save(windowManager.getState());\n    }\n    return { success: found };\n  } catch (e) {\n    console.error('rename-window error:', e);\n    return { success: false, error: e.message };\n  }\n});\n```\n\n### 2. Add preload bridge in preload.js\n\nAdd this line inside the contextBridge.exposeInMainWorld object, after the activateWindow entry:\n\n```js\n// Rename a managed window's display title\nrenameWindow: (hwnd, customTitle) =\u003e ipcRenderer.invoke('rename-window', hwnd, customTitle),\n```\n\n## Don't\n- Don't change any existing IPC handlers\n- Don't change sendStateUpdate() — it already sends getManagedWindows() which will include customTitle from task .1\n- Don't add any validation beyond what WindowManager.renameWindow() already does","acceptance_criteria":"1. IPC handler 'rename-window' exists in main.js registerIPC()\n2. Handler calls windowManager.renameWindow(hwnd, customTitle)\n3. Handler calls sendStateUpdate() and persistence.save() on success\n4. Handler returns { success: true/false }\n5. preload.js exposes renameWindow(hwnd, customTitle) via electronAPI\n6. No existing IPC handlers modified\n7. node --check passes on both files","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-23T21:07:09Z","created_by":"unknown","updated_at":"2026-02-23T21:08:52Z","closed_at":"2026-02-23T21:08:52Z","close_reason":"ad7b6c1 Add rename-window IPC handler and preload bridge","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-ly9.2","depends_on_id":"StackWindowsElectron-ly9","type":"parent-child","created_at":"2026-02-23T15:07:09Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-ly9.2","depends_on_id":"StackWindowsElectron-ly9.3","type":"blocks","created_at":"2026-02-23T15:07:45Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-ly9.3","title":"Add inline rename UI to managed window items in renderer","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\nMake the title text of each managed window item double-clickable to rename it inline. The interaction is identical to how the stack name (h1#stackTitle) already works with contenteditable.\n\n### 1. Add CSS styles (inside the existing \u003cstyle\u003e block)\n\nAdd these styles after the existing `.managed-item.inactive` rule (around line 181):\n\n```css\n.managed-title {\n  font-size: 12px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  flex: 1;\n  margin-right: 8px;\n  cursor: pointer;\n}\n\n.managed-title .display-name {\n  cursor: pointer;\n  padding: 1px 3px;\n  border: 1px solid transparent;\n  border-radius: 3px;\n  transition: background 0.15s, border-color 0.15s;\n}\n\n.managed-title .display-name:hover {\n  background: rgba(255, 255, 255, 0.08);\n}\n\n.managed-title .display-name[contenteditable='true']:focus {\n  background: #222;\n  border-color: #555;\n  outline: none;\n  cursor: text;\n  white-space: normal;\n  overflow: visible;\n  text-overflow: clip;\n}\n\n.managed-title .original-title {\n  font-size: 9px;\n  color: #555;\n  display: block;\n  margin-top: 1px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n```\n\n### 2. Add renameWindow JS function (in the \u003cscript\u003e block)\n\nAdd this function after the existing `activateWindow()` function (around line 763):\n\n```js\nasync function renameWindowTitle(hwnd, newTitle) {\n  try {\n    await window.electronAPI.renameWindow(hwnd, newTitle);\n  } catch (e) {\n    console.error('Failed to rename:', e);\n  }\n}\n```\n\n### 3. Modify renderManaged() — UPDATE existing element path (the `if (item)` branch, around line 554)\n\nReplace the title text update section. Currently it does:\n```js\nconst titleEl = item.querySelector('.title');\ntitleEl.textContent = win.title || 'Untitled';\n```\n\nReplace with:\n```js\nconst titleEl = item.querySelector('.managed-title');\nif (titleEl) {\n  const displayEl = titleEl.querySelector('.display-name');\n  const origEl = titleEl.querySelector('.original-title');\n  const displayText = win.customTitle || win.title || 'Untitled';\n  // Only update if not currently being edited\n  if (displayEl \u0026\u0026 document.activeElement !== displayEl) {\n    displayEl.textContent = displayText;\n  }\n  if (origEl) {\n    // Show original title hint only when a custom name is set\n    if (win.customTitle) {\n      origEl.textContent = win.title || '';\n      origEl.style.display = 'block';\n    } else {\n      origEl.textContent = '';\n      origEl.style.display = 'none';\n    }\n  }\n}\n```\n\nAlso update the badge logic — change `titleEl.querySelector('.active-badge, .strip-badge')` to `item.querySelector('.active-badge, .strip-badge')` since the badge will now be inside the actions area instead. Actually, simpler: keep the badge appended to the displayEl. Change:\n```js\nlet badge = titleEl.querySelector('.active-badge, .strip-badge');\n```\nto:\n```js\nlet badge = item.querySelector('.active-badge, .strip-badge');\n```\nAnd append the badge to the actions div instead of the title. Actually, the simplest approach: put the badge AFTER the display-name span, inside the managed-title container. So:\n```js\nlet badge = titleEl.querySelector('.active-badge, .strip-badge');\nif (!badge) {\n  badge = document.createElement('span');\n  titleEl.appendChild(badge);\n}\n```\nThis keeps badges working as before.\n\n### 4. Modify renderManaged() — CREATE new element path (the `else` branch, around line 583)\n\nReplace the title creation block. Currently:\n```js\nconst title = document.createElement('span');\ntitle.className = 'title';\ntitle.textContent = win.title || 'Untitled';\n```\n\nReplace with:\n```js\nconst title = document.createElement('div');\ntitle.className = 'managed-title';\n\nconst displayName = document.createElement('span');\ndisplayName.className = 'display-name';\ndisplayName.contentEditable = 'true';\ndisplayName.spellcheck = false;\ndisplayName.textContent = win.customTitle || win.title || 'Untitled';\n\n// Double-click selects all text for easy replacement\ndisplayName.addEventListener('dblclick', (e) =\u003e {\n  e.stopPropagation();\n  const selection = window.getSelection();\n  const range = document.createRange();\n  range.selectNodeContents(displayName);\n  selection.removeAllRanges();\n  selection.addRange(range);\n});\n\n// Blur saves the rename\ndisplayName.addEventListener('blur', () =\u003e {\n  const newName = displayName.textContent.trim();\n  renameWindowTitle(win.hwnd, newName || null);\n});\n\n// Enter confirms (blur triggers save)\ndisplayName.addEventListener('keydown', (e) =\u003e {\n  if (e.key === 'Enter') {\n    e.preventDefault();\n    displayName.blur();\n  }\n  if (e.key === 'Escape') {\n    e.preventDefault();\n    displayName.textContent = win.customTitle || win.title || 'Untitled';\n    displayName.blur();\n  }\n});\n\n// Prevent click from activating the window while editing\ndisplayName.addEventListener('click', (e) =\u003e {\n  e.stopPropagation();\n});\n\ntitle.appendChild(displayName);\n\n// Show original Win32 title as a hint when custom name is set\nconst origTitle = document.createElement('span');\norigTitle.className = 'original-title';\nif (win.customTitle) {\n  origTitle.textContent = win.title || '';\n  origTitle.style.display = 'block';\n} else {\n  origTitle.style.display = 'none';\n}\ntitle.appendChild(origTitle);\n```\n\nThen the badge creation stays the same but is appended to `title` (the managed-title div).\n\n### 5. Update the item.onclick handler\n\nThe existing item.onclick activates the window. We need to make sure clicking the contenteditable span does NOT trigger activation. The `displayName.addEventListener('click', e.stopPropagation())` above handles this.\n\n## Don't\n- Don't use a modal/prompt dialog — must be inline contenteditable\n- Don't remove the badge (ACTIVE/strip) display logic\n- Don't change the available windows section rendering\n- Don't change the remove button logic\n- Don't break the DOM-diffing (existingItems Map keyed by hwnd)","acceptance_criteria":"1. Double-clicking a managed window title makes it editable inline\n2. Pressing Enter or clicking away saves the custom name via renameWindow IPC\n3. Pressing Escape reverts to the previous name without saving\n4. When a custom name is set, the original Win32 title shows as a small gray hint below\n5. When no custom name is set, only the Win32 title shows (no hint)\n6. Clicking the editable title does NOT activate the window (stopPropagation)\n7. The ACTIVE/strip badges still display correctly\n8. The Remove button still works\n9. DOM-diffing still works (no duplicate elements on state updates)\n10. No modal dialogs used","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-23T21:07:46Z","created_by":"unknown","updated_at":"2026-02-23T21:10:56Z","closed_at":"2026-02-23T21:10:56Z","close_reason":"52e42b5 Add inline rename UI to managed window items","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-ly9.3","depends_on_id":"StackWindowsElectron-ly9","type":"parent-child","created_at":"2026-02-23T15:07:45Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-vzm","title":"Epic: Fix flicker, broken transitions, dangerous code \u0026 outdated deps","description":"## Why\nThe app suffers from visible window flicker and broken/interrupted transitions when managing windows. Root causes identified:\n1. Focus cycle between mainWindow and managed windows (SetForegroundWindow loop)\n2. Animation at 30 FPS via setTimeout (not synced to display refresh)\n3. Animations cancelled by overlapping timers (cleanup every 2s, foreground poll every 200ms)\n4. Z-order fights between DeferWindowPos and SetForegroundWindow\n5. Persistence doesn't save/load stackGap (data loss)\n6. Several dangerous code patterns (race conditions, memory leaks, unreliable PID checks)\n7. Electron 28 is 12 major versions behind (security + perf)\n\n## Success looks like\n- No visible flicker when switching between managed windows\n- Smooth transitions when adding/removing/activating windows\n- stackGap persists across sessions\n- No race conditions or listener leaks\n- Electron upgraded to a supported LTS version\n\n## Scope\nAll files in src/main/ and src/renderer/index.html. No new features — purely bug fixes, hardening, and dependency update.","status":"open","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-26T05:08:33Z","created_by":"unknown","updated_at":"2026-02-26T05:08:33Z","labels":["scope:medium"]}
{"id":"StackWindowsElectron-vzm.1","title":"Fix focus cycle flicker — remove SetForegroundWindow from mainWindow focus handler","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nLines 104-116: The mainWindow 'focus' event handler calls api.SetForegroundWindow(activeHwnd) every time the controller panel gains focus. This creates a focus-stealing loop:\n1. User clicks mainWindow → mainWindow gets focus\n2. focus handler calls SetForegroundWindow(activeHwnd) → OS gives focus to managed window\n3. mainWindow is alwaysOnTop so it may re-trigger focus → goto 1\n\nThis is the PRIMARY cause of window flicker.\n\n**Fix:** Replace the focus handler with a guard that only brings the active window forward when the user hasn't interacted with the controller UI. Specifically:\n- Remove the SetForegroundWindow call from the 'focus' handler entirely.\n- Instead, add a 'blur' event handler on mainWindow that, when mainWindow loses focus to a NON-managed window, calls SetForegroundWindow on the activeHwnd (so clicking away from the controller still keeps the stack visible).\n- Add a debounce of 150ms to the blur handler to avoid rapid fire.\n\nThe key insight: the user clicking the controller panel SHOULD keep focus on the controller (so they can interact with buttons, rename, etc). Only when focus leaves to an unrelated window should we reassert the active managed window.\n\n## Don't\n- Don't add any new SetForegroundWindow calls in the focus handler\n- Don't change the ForegroundMonitor behavior\n- Don't modify window-manager.js","acceptance_criteria":"1. Clicking on the mainWindow controller panel does NOT cause any managed window to flash/flicker\n2. The mainWindow retains focus when clicked (user can interact with UI elements)\n3. When focus leaves mainWindow to a non-managed window, the active managed window is still brought forward\n4. No infinite focus loop occurs under any click sequence","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-26T05:08:50Z","created_by":"unknown","updated_at":"2026-02-26T05:16:09Z","closed_at":"2026-02-26T05:16:09Z","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-vzm.1","depends_on_id":"StackWindowsElectron-vzm","type":"parent-child","created_at":"2026-02-25T23:08:49Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-vzm.10","title":"Replace deprecated document.execCommand with modern clipboard API","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\nTwo paste handlers use the deprecated document.execCommand('insertText'):\n1. Line 570 (stackTitle paste handler)\n2. Line 771 (displayName paste handler in managed items)\n\nBoth do:\n```js\ne.preventDefault();\nconst text = (e.clipboardData || window.clipboardData).getData('text/plain');\ndocument.execCommand('insertText', false, text.substring(0, N));\n```\n\n**Fix:** Replace document.execCommand with the Selection/Range API which is the modern standard for inserting text into contenteditable elements:\n\n```js\ne.preventDefault();\nconst text = (e.clipboardData || window.clipboardData).getData('text/plain').substring(0, N);\nconst selection = window.getSelection();\nif (selection.rangeCount \u003e 0) {\n  const range = selection.getRangeAt(0);\n  range.deleteContents();\n  range.insertNode(document.createTextNode(text));\n  // Move cursor to end of inserted text\n  range.collapse(false);\n  selection.removeAllRanges();\n  selection.addRange(range);\n}\n```\n\nApply this pattern to BOTH paste handlers (line 570 with max 100 chars, line 771 with max 200 chars).\n\n## Don't\n- Don't change the paste event prevention (e.preventDefault must stay)\n- Don't change the max character limits (100 for stackTitle, 200 for displayName)\n- Don't use the async Clipboard API (we already have the data from the paste event)\n- Don't change any other event handlers","acceptance_criteria":"1. Neither paste handler uses document.execCommand\n2. Both use Selection/Range API to insert text\n3. stackTitle paste is limited to 100 characters\n4. displayName paste is limited to 200 characters\n5. Pasting text into stackTitle works correctly\n6. Pasting text into a managed window's display name works correctly\n7. Cursor is positioned after the pasted text\n8. App starts without errors","status":"open","priority":3,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-26T05:10:39Z","created_by":"unknown","updated_at":"2026-02-26T05:10:39Z","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-vzm.10","depends_on_id":"StackWindowsElectron-vzm","type":"parent-child","created_at":"2026-02-25T23:10:38Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-vzm.11","title":"Clean up stale nul file from project root","description":"## Files\n- nul (delete)\n- .gitignore (modify)\n\n## What to do\nThere is a file called 'nul' in the project root. On Windows, 'nul' is a reserved device name (like /dev/null on Unix). This file was likely created accidentally by a malformed shell redirect.\n\n**Fix:**\n1. Delete the 'nul' file from the repository: git rm nul\n2. Add 'nul' to .gitignore to prevent it from being recreated:\n   Append this line to .gitignore:\n   ```\n   # Windows reserved device names\n   nul\n   ```\n\n## Don't\n- Don't modify any source files\n- Don't change existing .gitignore entries","acceptance_criteria":"1. The 'nul' file is removed from the repository (git rm)\n2. 'nul' is added to .gitignore\n3. git status shows the file is staged for deletion\n4. No other files are modified","status":"open","priority":3,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":5,"created_at":"2026-02-26T05:10:44Z","created_by":"unknown","updated_at":"2026-02-26T05:10:44Z","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-vzm.11","depends_on_id":"StackWindowsElectron-vzm","type":"parent-child","created_at":"2026-02-25T23:10:44Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-vzm.12","title":"Upgrade Electron 28 to 35 LTS — security and performance","description":"## Files\n- package.json (modify)\n\n## What to do\nElectron 28.3.3 is installed (Chromium 120, Node 18.18). The latest LTS is Electron 35.x (Chromium 134, Node 22). Upgrading brings:\n- Security patches (28 is EOL, no longer receives security fixes)\n- Chromium compositor improvements (less flicker with DWM)\n- Better Win32 interop in newer V8/Node\n- Performance improvements in IPC\n\n**Fix:**\n1. Update package.json: change electron from '^28.2.0' to '^35.0.0'\n2. Delete node_modules and package-lock.json\n3. Run npm install\n4. Verify the app starts with 'npm start' (no crash on launch)\n5. Verify koffi still loads correctly (it's a native module, may need rebuild)\n6. If koffi fails to load, run: npx electron-rebuild\n\n**Breaking changes to check (Electron 28→35):**\n- BrowserWindow 'webPreferences.sandbox' default changed to true in Electron 30 (we already set it explicitly, so no issue)\n- contextBridge behavior unchanged\n- ipcMain/ipcRenderer API unchanged\n- No breaking changes affect our Win32/koffi usage\n\n## Don't\n- Don't upgrade to Electron 40 (too new, may have breaking changes with koffi)\n- Don't change any source code in this task\n- Don't change koffi version\n- Don't remove the sandbox: true setting (even though it's now default)","acceptance_criteria":"1. package.json has electron '^35.0.0'\n2. npm install completes without errors\n3. npm start launches the app without crash\n4. koffi loads and EnumWindows works (available windows list populates)\n5. Adding and removing a window from the stack works\n6. No console errors on startup related to deprecated Electron APIs","status":"open","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-26T05:10:57Z","created_by":"unknown","updated_at":"2026-02-26T05:10:57Z","labels":["scope:medium"],"dependencies":[{"issue_id":"StackWindowsElectron-vzm.12","depends_on_id":"StackWindowsElectron-vzm","type":"parent-child","created_at":"2026-02-25T23:10:57Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-vzm.12","depends_on_id":"StackWindowsElectron-vzm.1","type":"blocks","created_at":"2026-02-25T23:11:03Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-vzm.12","depends_on_id":"StackWindowsElectron-vzm.13","type":"blocks","created_at":"2026-02-25T23:16:59Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-vzm.12","depends_on_id":"StackWindowsElectron-vzm.14","type":"blocks","created_at":"2026-02-25T23:17:00Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-vzm.12","depends_on_id":"StackWindowsElectron-vzm.3","type":"blocks","created_at":"2026-02-25T23:11:04Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-vzm.12","depends_on_id":"StackWindowsElectron-vzm.5","type":"blocks","created_at":"2026-02-25T23:11:04Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-vzm.13","title":"Fix flicker — debounce SetForegroundWindow in focus handler","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nLines 104-116: The mainWindow 'focus' handler calls SetForegroundWindow(activeHwnd) immediately every time the controller gains focus. When mainWindow is alwaysOnTop, this can cause rapid focus ping-pong with the OS, producing visible flicker.\n\n**The logic stays the same** — when mainWindow gets focus, bring the active managed window forward. We only add a debounce to prevent rapid-fire calls.\n\n**Fix:**\n1. Add a module-level variable: let _focusDebounceTimer = null;\n2. In the 'focus' handler, wrap the existing SetForegroundWindow call in a 200ms debounce:\n```js\nmainWindow.on('focus', () =\u003e {\n  if (!windowManager) return;\n  if (_focusDebounceTimer) clearTimeout(_focusDebounceTimer);\n  _focusDebounceTimer = setTimeout(() =\u003e {\n    _focusDebounceTimer = null;\n    const activeHwnd = windowManager.getActiveHwnd();\n    if (activeHwnd \u003e 0) {\n      try {\n        if (api.IsWindow(activeHwnd) !== 0) {\n          api.SetForegroundWindow(activeHwnd);\n        }\n      } catch (e) { /* window may have been closed */ }\n    }\n  }, 200);\n});\n```\n3. Clear _focusDebounceTimer in performCleanup() alongside the other timers.\n\n**Same logic, just debounced.** The 200ms delay lets the OS settle focus before we reassert the managed window, breaking the ping-pong cycle.\n\n## Don't\n- Don't remove the SetForegroundWindow call\n- Don't change what the handler does (still brings active window forward)\n- Don't change ForegroundMonitor\n- Don't change window-manager.js","acceptance_criteria":"1. The focus handler still calls SetForegroundWindow on the active managed window\n2. Rapid focus events within 200ms only produce ONE SetForegroundWindow call\n3. _focusDebounceTimer is cleared in performCleanup()\n4. No other behavior changes\n5. App starts without errors","status":"open","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-26T05:16:28Z","created_by":"unknown","updated_at":"2026-02-26T05:16:28Z","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-vzm.13","depends_on_id":"StackWindowsElectron-vzm","type":"parent-child","created_at":"2026-02-25T23:16:28Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-vzm.14","title":"Remove layout animation — use instant snap to eliminate flicker and transition bugs","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nThe _animateLayout method (lines 404-587) runs a 30 FPS setTimeout animation loop with DeferWindowPos. This causes:\n- Flicker from Z-order fights between animation frames and SetForegroundWindow\n- Broken transitions when animations are cancelled mid-flight by timers\n- Visual stuttering from setTimeout not being vsync-aligned\n\nThe animation adds complexity but the actual duration is only 100ms (3 frames at 30fps). At that speed, the user barely perceives the animation — they mostly see the flicker it causes.\n\n**Fix: Force skipAnimation=true permanently and remove the animation loop code.**\n\n1. In the constructor (line 32), change: this.skipAnimation = true; (hardcode, ignore options)\n2. Remove these now-dead fields from the constructor:\n   - this._animationTimer (line 26)\n   - this._currentTargets (line 27)\n   - this.animationDuration (line 29)\n   - this.animationEasing (line 30)\n3. Remove these now-dead methods entirely:\n   - _applyEasing (lines 41-53) \n   - _stopAnimation (lines 284-290)\n4. In _animateLayout, remove everything AFTER the skipAnimation block (lines 429-587). The method becomes just the instant-snap DeferWindowPos batch (lines 407-428). Rename it to _applyLayout for clarity.\n5. Update the call site in layoutStack (line 676): change this._animateLayout(targetLayouts) to this._applyLayout(targetLayouts)\n6. Remove the redundant animation check (targetsKey, lines 431-437) — not needed without animation.\n\n**Keep _animateRestore as-is** — the restore animation when removing a window is a different path and runs independently (no timer conflicts).\n\n**Keep _restoreAnimationTimers, _stopRestoreAnimation, _animateRestore** — these are for the remove-window path only.\n\n## Don't\n- Don't change _animateRestore or restore animation\n- Don't change the DeferWindowPos/SetWindowPos logic in the skipAnimation block\n- Don't change layoutStack positioning math\n- Don't change the flags (SWP_NOACTIVATE, SWP_SHOWWINDOW, HWND_TOP)\n- Don't change the fallback path (individual SetWindowPos when BeginDeferWindowPos fails)","acceptance_criteria":"1. skipAnimation is hardcoded to true in constructor\n2. _animateLayout is renamed to _applyLayout and contains ONLY the instant-snap DeferWindowPos batch\n3. _applyEasing and _stopAnimation methods are removed\n4. _animationTimer, _currentTargets, animationDuration, animationEasing fields are removed\n5. layoutStack calls _applyLayout instead of _animateLayout\n6. _animateRestore still works (restore animation on remove is preserved)\n7. No flicker when switching between managed windows\n8. App starts without errors","status":"open","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-26T05:16:47Z","created_by":"unknown","updated_at":"2026-02-26T05:16:47Z","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-vzm.14","depends_on_id":"StackWindowsElectron-vzm","type":"parent-child","created_at":"2026-02-25T23:16:46Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-vzm.15","title":"Add known-limitation comment to _isPidAlive — no behavior change","description":"## Files\n- src/main/instance-registry.js (modify)\n\n## What to do\nThe _isPidAlive method (lines 127-134) uses process.kill(pid, 0) which can give false positives on Windows due to PID reuse. However, the actual risk is low (PID reuse within the same session is rare) and the alternative (execSync tasklist) would block the event loop.\n\n**Fix: Add a JSDoc comment documenting the limitation. No code change.**\n\nReplace the existing comment block above _isPidAlive with:\n```js\n/**\n * Check whether a PID is still alive using signal 0.\n * \n * Known limitation on Windows: process.kill(pid, 0) can return false\n * positives if Windows has reused the PID for a different process.\n * This is acceptable because:\n * 1. PID reuse within a single user session is rare\n * 2. The worst case is keeping a stale registry entry (harmless)\n * 3. The alternative (execSync tasklist) blocks the event loop ~100ms\n * \n * @param {number} pid\n * @returns {boolean}\n * @private\n */\n```\n\n## Don't\n- Don't change any code logic\n- Don't add child_process or tasklist\n- Don't change _pruneDeadInstances","acceptance_criteria":"1. _isPidAlive has an updated JSDoc comment explaining the Windows limitation\n2. No code logic is changed\n3. No new imports or dependencies\n4. App starts without errors","status":"open","priority":3,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":5,"created_at":"2026-02-26T05:16:55Z","created_by":"unknown","updated_at":"2026-02-26T05:16:55Z","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-vzm.15","depends_on_id":"StackWindowsElectron-vzm","type":"parent-child","created_at":"2026-02-25T23:16:54Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-vzm.2","title":"Fix animation framerate — increase to 60 FPS and reduce timer drift","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nLines 572 and 388: Animation ticks use setTimeout(tick, 1000/30) which gives ~33ms intervals (30 FPS). This is too slow for smooth window movement and causes visible stuttering because setTimeout is not synced to the display refresh.\n\n**Fix for _animateLayout (line 572):**\n- Change the frame interval from 1000/30 to 1000/60 (~16ms) for both _animateLayout and _animateRestore\n- Reduce the default animationDuration from 100ms to 80ms (fewer frames needed at higher FPS)\n- Reduce restoreAnimationDuration from 150ms to 120ms\n- Use performance.now() instead of Date.now() for more precise timing (sub-ms resolution)\n\n**Fix for _animateRestore (line 388):**\n- Same changes: 1000/60 interval, performance.now()\n\n**Both methods:**\n- Replace all Date.now() with performance.now() in the animation tick functions\n- Replace setTimeout intervals: 1000/30 → 1000/60\n\n## Don't\n- Don't change the easing functions\n- Don't change the DeferWindowPos/SetWindowPos logic\n- Don't change the skipAnimation path\n- Don't remove the redundant animation check (targetsKey comparison)\n- Don't change the Z-order flags","acceptance_criteria":"1. Animation tick interval is 1000/60 (~16ms) in both _animateLayout and _animateRestore\n2. Timing uses performance.now() instead of Date.now()\n3. Default animationDuration is 80ms, restoreAnimationDuration is 120ms\n4. skipAnimation path still works (instant snap, no animation loop)\n5. App starts without errors","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-26T05:09:00Z","created_by":"unknown","updated_at":"2026-02-26T05:16:10Z","closed_at":"2026-02-26T05:16:10Z","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-vzm.2","depends_on_id":"StackWindowsElectron-vzm","type":"parent-child","created_at":"2026-02-25T23:08:59Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-vzm.3","title":"Fix animation cancellation — guard layout calls during active animation","description":"## Files\n- src/main/main.js (modify)\n- src/main/window-manager.js (modify)\n\n## What to do\nMultiple timers trigger doLayout() which calls layoutStack() → _animateLayout(). When an animation is in progress and a new layout call arrives with DIFFERENT targets, the current animation is cancelled mid-frame (via _stopAnimation) and a new one starts from the current (mid-animation) position. This causes visual jumps.\n\nSources of interruption:\n- cleanupTimer every 2000ms (main.js:415) calls doLayoutDebounced → doLayout\n- ForegroundMonitor every 200ms (foreground-monitor.js:30) triggers onManagedWindowFocused → doLayoutDebounced\n- mainWindow resize (main.js:93) calls doLayout directly\n\n**Fix in window-manager.js:**\n- Add a method isAnimating() that returns true if _animationTimer is not null\n- In _animateLayout, when a new call arrives with DIFFERENT targets while animating: instead of cancelling, let the current animation finish its remaining frames but update the target positions mid-flight (retarget). Specifically:\n  - Store the new targets in a _pendingTargets field\n  - On the next tick of the current animation, if _pendingTargets is set, smoothly blend toward the new targets from the current interpolated position\n  - Clear _pendingTargets after adopting them\n\n**Fix in main.js:**\n- In the cleanupTimer callback (line 415): only call doLayoutDebounced if windowManager.isAnimating() is false. If animating, defer by setting a flag that doLayout checks after animation completes.\n- Increase doLayoutDebounced timeout from 16ms to 50ms to batch rapid successive calls.\n\n## Don't\n- Don't remove the redundant animation skip (same targetsKey check)\n- Don't change the ForegroundMonitor polling interval\n- Don't change the cleanupTimer interval (2000ms)\n- Don't modify the easing or DeferWindowPos logic","acceptance_criteria":"1. windowManager.isAnimating() returns true during animation, false otherwise\n2. doLayoutDebounced uses 50ms timeout instead of 16ms\n3. A layout call during active animation retargets instead of cancelling\n4. cleanupTimer does not interrupt active animations\n5. No visual jumps when switching windows rapidly\n6. App starts without errors","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-26T05:09:13Z","created_by":"unknown","updated_at":"2026-02-26T05:16:10Z","closed_at":"2026-02-26T05:16:10Z","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-vzm.3","depends_on_id":"StackWindowsElectron-vzm","type":"parent-child","created_at":"2026-02-25T23:09:13Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-vzm.3","depends_on_id":"StackWindowsElectron-vzm.2","type":"blocks","created_at":"2026-02-25T23:11:01Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-vzm.4","title":"Fix persistence not saving/loading stackGap — data loss bug","description":"## Files\n- src/main/persistence.js (modify)\n\n## What to do\nThe stackGap property is managed by WindowManager.getState() (which includes it) and WindowManager.loadState() (which reads it). However, Persistence.save() and Persistence.saveSync() both construct a 'data' object that OMITS stackGap. Similarly, Persistence.load() does not include stackGap in its return value.\n\n**Fix in save() (lines 70-80):**\nAdd stackGap to the data object:\n```\nstackGap: state.stackGap || 0,\n```\nPlace it after the backgroundColor line.\n\n**Fix in saveSync() (lines 105-115):**\nSame change — add stackGap to the data object.\n\n**Fix in load() (lines 159-167):**\nAdd stackGap to the returned object:\n```\nstackGap: data.stackGap || 0,\n```\n\n**Fix in version 1 migration (lines 140-151):**\nAdd stackGap: 0 to the migrated object.\n\n## Don't\n- Don't change the version number (keep version: 2)\n- Don't change any other persistence fields\n- Don't modify window-manager.js or main.js","acceptance_criteria":"1. persistence.save() writes stackGap to the JSON file\n2. persistence.saveSync() writes stackGap to the JSON file\n3. persistence.load() returns stackGap from the JSON file\n4. Version 1 migration includes stackGap: 0\n5. A round-trip test: set stackGap=20, save, load → stackGap is 20\n6. App starts without errors","status":"open","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-26T05:09:36Z","created_by":"unknown","updated_at":"2026-02-26T05:09:36Z","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-vzm.4","depends_on_id":"StackWindowsElectron-vzm","type":"parent-child","created_at":"2026-02-25T23:09:35Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-vzm.5","title":"Fix Z-order fight — skip HWND_TOP on intermediate animation frames","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nIn _animateLayout, intermediate animation frames already use SWP_NOZORDER (line 504) to skip Z-order changes. However, the FIRST frame (isFirstFrame=true) and the FINAL snap both use HWND_TOP. When SetForegroundWindow is called concurrently (from promoteToActive or addWindow), the Z-order set by DeferWindowPos fights with the Z-order set by SetForegroundWindow, causing flicker.\n\n**Fix:**\n1. In _animateLayout, change the first frame to ALSO use SWP_NOZORDER (like intermediate frames). Only the FINAL snap (progress \u003e= 1) should assert HWND_TOP. This reduces the number of Z-order changes from N+2 to just 1 per animation.\n\n2. In the final snap block (lines 548-569), add a 1ms setTimeout before executing the final DeferWindowPos. This gives any concurrent SetForegroundWindow call time to complete, avoiding the race.\n\n3. Remove the isFirstFrame variable entirely — it's no longer needed since all non-final frames use SWP_NOZORDER.\n\nSpecifically change lines 481-505:\n- Remove 'let isFirstFrame = true' (line 469)\n- Remove 'isFirstFrame = false' (line 543)  \n- Change the isIntermediate check to simply: const isIntermediate = progress \u003c 1;\n- This means ALL non-final frames skip Z-order work\n\n## Don't\n- Don't change the fallback SetWindowPos paths\n- Don't change the SWP_NOACTIVATE flag on any frame\n- Don't change the final snap logic (just wrap it in setTimeout)\n- Don't change _animateRestore (it uses HWND_NOTOPMOST which is correct)","acceptance_criteria":"1. All non-final animation frames use SWP_NOZORDER (no Z-order changes during animation)\n2. Only the final snap (progress \u003e= 1) asserts HWND_TOP\n3. isFirstFrame variable is removed\n4. Final snap is wrapped in a 1ms setTimeout\n5. No visible Z-order flicker when activating windows during animation\n6. App starts without errors","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":25,"created_at":"2026-02-26T05:09:48Z","created_by":"unknown","updated_at":"2026-02-26T05:16:11Z","closed_at":"2026-02-26T05:16:11Z","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-vzm.5","depends_on_id":"StackWindowsElectron-vzm","type":"parent-child","created_at":"2026-02-25T23:09:47Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-vzm.5","depends_on_id":"StackWindowsElectron-vzm.2","type":"blocks","created_at":"2026-02-25T23:11:02Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-vzm.6","title":"Fix race condition in persistence.save() — await recursive call","description":"## Files\n- src/main/persistence.js (modify)\n\n## What to do\nIn the save() method (lines 86-91), the finally block calls this.save(pending) without await:\n```js\nfinally {\n  this._writing = false;\n  if (this._pendingState !== null) {\n    const pending = this._pendingState;\n    this._pendingState = null;\n    this.save(pending); // ← missing await, unhandled promise\n  }\n}\n```\n\nIf the recursive save() rejects, the error is silently swallowed (unhandled promise rejection). This can cause data loss without any indication.\n\n**Fix:**\nAdd a .catch() handler to the recursive call since we can't await in finally reliably:\n```js\nthis.save(pending).catch(e =\u003e {\n  console.error('Failed to flush pending persistence state:', e);\n});\n```\n\nThis is preferred over await because:\n1. The caller of the original save() shouldn't wait for the pending flush\n2. We just need to ensure errors are logged, not propagated\n\n## Don't\n- Don't change the _writing guard logic\n- Don't change the _pendingState pattern\n- Don't add await (it would change the semantics for callers)\n- Don't modify saveSync()","acceptance_criteria":"1. The recursive this.save(pending) call has a .catch() error handler\n2. Errors in the pending save are logged to console.error\n3. The _writing guard still prevents concurrent writes\n4. No unhandled promise rejections when save fails\n5. App starts without errors","status":"open","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":10,"created_at":"2026-02-26T05:09:56Z","created_by":"unknown","updated_at":"2026-02-26T05:09:56Z","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-vzm.6","depends_on_id":"StackWindowsElectron-vzm","type":"parent-child","created_at":"2026-02-25T23:09:56Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-vzm.7","title":"Fix onStateUpdate listener leak — return cleanup function from preload","description":"## Files\n- src/main/preload.js (modify)\n- src/renderer/index.html (modify)\n\n## What to do\nIn preload.js (lines 44-46), onStateUpdate registers an ipcRenderer.on listener but never provides a way to remove it:\n```js\nonStateUpdate: (callback) =\u003e {\n  ipcRenderer.on('state-update', (event, data) =\u003e callback(data));\n}\n```\n\nIf the renderer page reloads, a new listener is added without removing the old one, causing duplicate event handling.\n\n**Fix in preload.js:**\n1. Change onStateUpdate to return a cleanup function:\n```js\nonStateUpdate: (callback) =\u003e {\n  const handler = (event, data) =\u003e callback(data);\n  ipcRenderer.on('state-update', handler);\n  return () =\u003e ipcRenderer.removeListener('state-update', handler);\n},\n```\n\n2. Add a new removeAllStateListeners method:\n```js\nremoveAllStateListeners: () =\u003e {\n  ipcRenderer.removeAllListeners('state-update');\n}\n```\n\n**Fix in index.html:**\nAt the top of the init() function (line 1027), call removeAllStateListeners before registering:\n```js\nasync function init() {\n  window.electronAPI.removeAllStateListeners();\n  // ... existing code\n}\n```\n\n## Don't\n- Don't change the state-update event name\n- Don't change the callback signature\n- Don't modify main.js","acceptance_criteria":"1. onStateUpdate returns a cleanup function that removes the specific listener\n2. removeAllStateListeners is exposed in the preload bridge\n3. init() calls removeAllStateListeners before registering the listener\n4. After a hypothetical page reload, only ONE listener is active\n5. App starts without errors","status":"open","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-26T05:10:04Z","created_by":"unknown","updated_at":"2026-02-26T05:10:04Z","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-vzm.7","depends_on_id":"StackWindowsElectron-vzm","type":"parent-child","created_at":"2026-02-25T23:10:04Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-vzm.8","title":"Fix unreliable PID check on Windows — use tasklist instead of signal 0","description":"## Files\n- src/main/instance-registry.js (modify)\n\n## What to do\nThe _isPidAlive method (lines 127-134) uses process.kill(pid, 0) to check if a process is alive. On Windows, this is unreliable because:\n1. Windows reuses PIDs aggressively — a dead instance's PID may belong to a completely different process\n2. process.kill on Windows uses TerminateProcess internally, and signal 0 behavior is emulated by Node.js, not the OS\n\n**Fix:**\nReplace _isPidAlive with a method that checks both PID existence AND process name:\n\n```js\n_isPidAlive(pid) {\n  try {\n    // First check: can we signal the process at all?\n    process.kill(pid, 0);\n  } catch (e) {\n    return false; // Process definitely doesn't exist\n  }\n  \n  // Second check: verify it's actually an Electron/node process\n  // to guard against PID reuse\n  try {\n    const { execSync } = require('child_process');\n    const output = execSync(\n      'tasklist /FI \"PID eq ' + pid + '\" /FO CSV /NH',\n      { encoding: 'utf-8', timeout: 2000, windowsHide: true }\n    ).trim();\n    // tasklist returns 'INFO: No tasks are running...' if PID not found\n    if (output.startsWith('\"INFO:') || output === '') return false;\n    // Check if the process name contains electron or node\n    const lower = output.toLowerCase();\n    return lower.includes('electron') || lower.includes('node') || lower.includes('stack');\n  } catch (e) {\n    // If tasklist fails, fall back to the signal-0 result (true)\n    return true;\n  }\n}\n```\n\n**Important:** Add require('child_process') at the top of the file with the other requires.\n\n## Don't\n- Don't change the _pruneDeadInstances logic\n- Don't change the registry file format\n- Don't make this async (it's called synchronously in _register and getOtherInstancesHwnds)\n- Don't remove the process.kill(pid, 0) first check (it's a fast pre-filter)","acceptance_criteria":"1. _isPidAlive uses both process.kill(pid, 0) AND tasklist to verify PID\n2. child_process is required at the top of the file\n3. tasklist is called with windowsHide: true and timeout: 2000\n4. If tasklist fails, falls back to true (safe default)\n5. PID reuse by a non-Electron process returns false\n6. App starts without errors","status":"closed","priority":3,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-26T05:10:17Z","created_by":"unknown","updated_at":"2026-02-26T05:16:11Z","closed_at":"2026-02-26T05:16:11Z","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-vzm.8","depends_on_id":"StackWindowsElectron-vzm","type":"parent-child","created_at":"2026-02-25T23:10:17Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-vzm.9","title":"Add input validation to update-stack-name IPC handler","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nThe 'update-stack-name' IPC handler (lines 284-288) accepts any value without validation:\n```js\nipcMain.handle('update-stack-name', async (event, name) =\u003e {\n  windowManager.setStackName(name); // no type check, no length limit\n  persistence.save(windowManager.getState());\n  return { success: true };\n});\n```\n\nEvery other IPC handler validates its inputs. This one should too.\n\n**Fix:**\nAdd validation before calling setStackName:\n```js\nipcMain.handle('update-stack-name', async (event, name) =\u003e {\n  try {\n    if (typeof name !== 'string' \u0026\u0026 name !== null \u0026\u0026 name !== undefined) {\n      throw new Error('Invalid name: must be a string, null, or undefined');\n    }\n    if (typeof name === 'string') name = name.slice(0, 200);\n    windowManager.setStackName(name);\n    persistence.save(windowManager.getState());\n    return { success: true };\n  } catch (e) {\n    console.error('update-stack-name error:', e);\n    return { success: false, error: e.message };\n  }\n});\n```\n\n## Don't\n- Don't change the setStackName method in window-manager.js\n- Don't change the preload bridge\n- Don't change other IPC handlers","acceptance_criteria":"1. update-stack-name validates that name is a string, null, or undefined\n2. String names are truncated to 200 characters\n3. Invalid types return { success: false, error: '...' }\n4. Handler is wrapped in try/catch like other handlers\n5. App starts without errors","status":"open","priority":3,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":10,"created_at":"2026-02-26T05:10:29Z","created_by":"unknown","updated_at":"2026-02-26T05:10:29Z","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-vzm.9","depends_on_id":"StackWindowsElectron-vzm","type":"parent-child","created_at":"2026-02-25T23:10:29Z","created_by":"unknown","metadata":"{}"}]}
