{"id":"StackWindowsElectron-17p","title":"Epic: Improve window transition animation system","description":"## Goals\nThis epic improves the Win32 window transition animation system in StackWindowsElectron. The current system uses a 200ms/12-frame setInterval-based animation with cubic ease-out to move real OS windows via DeferWindowPos. While functional, it has several issues:\n\n1. **Timing fragility**: setInterval at 16.67ms in Node.js is not guaranteed to fire on time, causing frame drops and choppy motion\n2. **No animation on removal**: removeWindow() and restoreAll() snap windows instantly, jarring contrast with smooth add/activate\n3. **Redundant Z-order work**: Every animation frame re-issues HWND_TOP for all windows, causing potential flicker\n4. **Rapid trigger jank**: Fast Alt-Tab restarts animation from scratch each time, resetting the 200ms duration\n5. **No CSS transitions in renderer**: Managed window list re-renders with innerHTML='', causing visual jumps\n6. **Stale code comments**: Comments claim no activate-window handler exists, but one does (line 165 main.js)\n\n## Success Criteria\n- Animation uses timestamp-based progress (performance.now/Date.now) instead of frame counting\n- Window removal is animated (slide back to original position)\n- Intermediate animation frames use SWP_NOZORDER to reduce flicker\n- Rapid layout triggers are debounced to prevent animation restart jank\n- Managed window list in renderer has CSS enter/exit transitions\n- All stale comments are corrected\n\n## Key Constraints\n- Must remain pure vanilla JS (no frameworks, no TypeScript)\n- Must not break existing Win32 FFI bridge (koffi/user32.dll)\n- Animation must remain in Electron main process (no requestAnimationFrame available)\n- Must maintain backward compatibility with persistence format v2\n- All changes must be testable by running the app and managing 2-3 windows","status":"open","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-22T04:31:19Z","created_by":"unknown","updated_at":"2026-02-22T04:31:19Z","labels":["needs-integration-review","scope:medium"]}
{"id":"StackWindowsElectron-17p.1","title":"Refactor _animateLayout to use timestamp-based progress instead of frame counting","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nReplace the current setInterval + frame-counting animation engine in _animateLayout() (lines 237-339) with a timestamp-based approach using setTimeout recursion and Date.now() (or process.hrtime).\n\nCurrent implementation:\n- Uses setInterval at 1000/60 (~16.67ms)\n- Counts frames: currentFrame++ up to TOTAL_FRAMES (12)\n- Progress = currentFrame / TOTAL_FRAMES\n- Problem: if setInterval fires late, frames bunch up or get skipped\n\nNew implementation:\n- Record startTime = Date.now() at animation start\n- Use recursive setTimeout (not setInterval) for each frame\n- Calculate progress = (Date.now() - startTime) / DURATION\n- Clamp progress to [0, 1]\n- Keep the same easing function: ease = 1 - Math.pow(1 - progress, 3)\n- Keep the same DeferWindowPos batching logic\n- Keep the same final snap logic when progress \u003e= 1\n- Keep the same error handling / fallback to instant SetWindowPos\n- Change _stopAnimation() to use clearTimeout instead of clearInterval\n- Rename _animationInterval to _animationTimer for clarity\n\nThe DURATION constant (200ms) and easing function must NOT change. Only the timing mechanism changes.\n\n## Don't\n- Don't change the easing function\n- Don't change the DeferWindowPos/BeginDeferWindowPos/EndDeferWindowPos API calls\n- Don't change the layoutStack() method\n- Don't change the final snap logic\n- Don't add any new dependencies\n- Don't use requestAnimationFrame (not available in main process)","acceptance_criteria":"1. _animateLayout uses Date.now() to compute progress as (elapsed / DURATION)\n2. Uses recursive setTimeout instead of setInterval\n3. _stopAnimation uses clearTimeout\n4. Animation still completes in ~200ms with cubic ease-out\n5. Final snap to exact target positions still occurs\n6. Error fallback to instant SetWindowPos still works\n7. App launches without errors and window transitions animate smoothly when switching between 2+ managed windows","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-22T04:31:35Z","created_by":"unknown","updated_at":"2026-02-22T04:39:34Z","closed_at":"2026-02-22T04:39:34Z","close_reason":"9bf0eb5 Refactor _animateLayout to use timestamp-based progress via recursive setTimeout and Date.now()","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.1","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:31:35Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.2","title":"Add animated window removal with slide-to-original-position effect","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nCurrently _restoreWindow() (lines 420-434) uses a single SetWindowPos call to instantly snap a removed window back to its original position. This is jarring compared to the smooth add/activate animations.\n\nCreate a new method _animateRestore(entry, callback) that:\n1. Gets the window's current position via GetWindowRect\n2. Computes target position from entry.originalRect (same logic as current _restoreWindow)\n3. Runs a standalone animation (NOT using _animateLayout, because that would conflict with the main layout animation) using the same timestamp-based approach from task 1\n4. Uses a SEPARATE timer reference (e.g. this._restoreAnimationTimer) so it doesn't cancel the main layout animation\n5. Duration: 250ms (slightly longer than layout animation for visual distinction)\n6. Easing: same cubic ease-out\n7. Uses single SetWindowPos per frame (not DeferWindowPos, since it's only one window)\n8. On the final frame, sets HWND_NOTOPMOST (same as current _restoreWindow)\n9. Calls callback() when animation completes (so removeWindow can chain doLayout after)\n\nModify removeWindow() (lines 150-164):\n- Instead of calling this._restoreWindow(entry), call this._animateRestore(entry, () =\u003e {})\n- The doLayout() call in main.js (line 155) already handles re-laying out remaining windows\n\nModify restoreAll() (lines 222-228):\n- Keep using instant _restoreWindow for restoreAll (app quit scenario - no time for animation)\n- Add a comment explaining why restoreAll stays instant\n\nAdd _stopRestoreAnimation() method similar to _stopAnimation() but for the restore timer.\nCall _stopRestoreAnimation() at the beginning of _animateRestore() to cancel any in-flight restore.\n\n## Don't\n- Don't modify _animateLayout or layoutStack\n- Don't use DeferWindowPos for single-window restore animation\n- Don't animate restoreAll() (app is quitting, no time)\n- Don't change the persistence format\n- Don't change the originalRect storage logic","acceptance_criteria":"1. removeWindow() triggers a smooth 250ms animation sliding the window back to its originalRect position\n2. The animation uses cubic ease-out easing\n3. The animation uses HWND_NOTOPMOST on the final frame\n4. restoreAll() still uses instant snap (no animation)\n5. A separate timer (_restoreAnimationTimer) is used, not conflicting with _animationTimer\n6. Remaining managed windows re-layout correctly after removal animation\n7. Removing a window while another removal is animating cancels the first and starts the new one\n8. App launches without errors; removing a window from a 3-window stack shows smooth slide-out","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":50,"created_at":"2026-02-22T04:31:52Z","created_by":"unknown","updated_at":"2026-02-22T04:44:44Z","closed_at":"2026-02-22T04:44:44Z","close_reason":"585b136 Add animated window removal with slide-to-original-position effect","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.2","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:31:51Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-17p.2","depends_on_id":"StackWindowsElectron-17p.1","type":"blocks","created_at":"2026-02-21T22:33:22Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.3","title":"Add SWP_NOZORDER flag to intermediate animation frames","description":"## Files\n- src/main/window-manager.js (modify)\n- src/main/win32.js (verify SWP_NOZORDER is exported — it already is at line 47/69)\n\n## What to do\nIn _animateLayout(), every animation frame calls DeferWindowPos with HWND_TOP, which re-issues a Z-order change for every window on every frame. This is redundant and can cause flicker on some systems.\n\nModify the animation loop in _animateLayout():\n1. On the FIRST frame (progress close to 0 or first iteration): use HWND_TOP and the existing flags (set Z-order)\n2. On INTERMEDIATE frames (not first, not last): add SWP_NOZORDER to the flags passed to DeferWindowPos, and pass 0 (or any value, it's ignored with SWP_NOZORDER) for hWndInsertAfter\n3. On the FINAL frame (the snap at the end): use HWND_TOP without SWP_NOZORDER (re-assert Z-order)\n\nImplementation approach:\n- Import SWP_NOZORDER from win32.js (already exported, line 69)\n- Add it to the destructured imports at the top of window-manager.js (line 5-8)\n- In the animation loop, add a boolean isFirstFrame tracked by a variable\n- For intermediate frames: flags = layout.flags | SWP_NOZORDER, and use 0 as hWndInsertAfter\n- The final snap block (lines 317-327) already uses HWND_TOP, keep it as-is\n\n## Don't\n- Don't change the first frame behavior (must set Z-order on first frame)\n- Don't change the final snap behavior\n- Don't change the easing or timing\n- Don't modify win32.js (SWP_NOZORDER is already exported)\n- Don't change layoutStack()","acceptance_criteria":"1. SWP_NOZORDER is imported in window-manager.js destructured imports\n2. First animation frame uses HWND_TOP without SWP_NOZORDER (sets Z-order)\n3. Intermediate frames (not first, not last) include SWP_NOZORDER in flags\n4. Final snap frame uses HWND_TOP without SWP_NOZORDER\n5. App launches without errors; switching between 3 managed windows animates without visible flicker\n6. Z-order is correct: active window on top, inactive windows behind in strip order","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-22T04:32:06Z","created_by":"unknown","updated_at":"2026-02-22T04:42:47Z","closed_at":"2026-02-22T04:42:47Z","close_reason":"7450107 Add SWP_NOZORDER flag to intermediate animation frames","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.3","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:32:06Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-17p.3","depends_on_id":"StackWindowsElectron-17p.1","type":"blocks","created_at":"2026-02-21T22:33:22Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.4","title":"Add debounce to doLayout to prevent animation restart jank on rapid triggers","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nCurrently, doLayout() (lines 75-88) is called directly from multiple triggers: foreground monitor (every 200ms), add-window, remove-window, activate-window, resize, and dead-window cleanup. When the user rapidly Alt-Tabs between managed windows, multiple doLayout() calls can fire within a single 200ms animation duration, causing _animateLayout to restart from scratch each time (jerky motion).\n\nAdd a debounce wrapper around doLayout:\n1. Create a module-level variable: let _layoutDebounceTimer = null;\n2. Create a new function doLayoutDebounced() that:\n   - Clears any pending _layoutDebounceTimer\n   - Sets _layoutDebounceTimer = setTimeout(() =\u003e { doLayout(); }, 16) — 16ms debounce (one frame at 60fps)\n   - This coalesces multiple rapid calls into a single layout pass\n3. Replace doLayout() calls with doLayoutDebounced() in these specific locations:\n   - onManagedWindowFocused (line 103) — this is the main rapid-fire source\n   - The cleanup timer callback (line 298)\n4. Keep doLayout() (NOT debounced) for these locations where immediate response is needed:\n   - add-window IPC handler (line 141) — user explicitly added, should respond immediately\n   - remove-window IPC handler (line 155) — user explicitly removed\n   - activate-window IPC handler (line 170) — user explicitly clicked\n   - resize event (line 49) — window is being resized, needs immediate feedback\n   - Initial layout setTimeout (line 289) — startup, only fires once\n5. Clean up _layoutDebounceTimer in the window-all-closed handler (line 312)\n\n## Don't\n- Don't modify window-manager.js\n- Don't modify foreground-monitor.js\n- Don't change the debounce delay to more than 50ms (would introduce perceptible lag)\n- Don't debounce the user-initiated actions (add, remove, activate, resize)\n- Don't use any external debounce library","acceptance_criteria":"1. A doLayoutDebounced() function exists that debounces with ~16ms delay\n2. onManagedWindowFocused uses doLayoutDebounced() instead of doLayout()\n3. Dead window cleanup timer uses doLayoutDebounced()\n4. add-window, remove-window, activate-window IPC handlers still use direct doLayout()\n5. resize event still uses direct doLayout()\n6. _layoutDebounceTimer is cleared in window-all-closed handler\n7. App launches without errors; rapid Alt-Tab between 3 managed windows produces smooth animation without visible jank/restart","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-22T04:32:20Z","created_by":"unknown","updated_at":"2026-02-22T04:39:25Z","closed_at":"2026-02-22T04:39:25Z","close_reason":"41be2f3 Add debounce to doLayout to prevent animation restart jank","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.4","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:32:20Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.5","title":"Make animation duration and easing configurable via constructor options","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nCurrently DURATION (200ms) and the easing function are hardcoded inside _animateLayout(). Extract them as configurable options on the WindowManager class for future flexibility and easier tuning.\n\n1. Add an options parameter to the WindowManager constructor with defaults:\n   constructor(options = {}) {\n     // ... existing code ...\n     this.animationDuration = options.animationDuration || 200;  // ms\n     this.animationEasing = options.animationEasing || 'ease-out-cubic';\n     this.restoreAnimationDuration = options.restoreAnimationDuration || 250; // ms\n   }\n\n2. Create a private method _applyEasing(progress) that maps a string name to an easing function:\n   - 'ease-out-cubic': 1 - Math.pow(1 - progress, 3)  (current default)\n   - 'ease-in-out-cubic': progress \u003c 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2\n   - 'linear': progress\n   Returns the eased value.\n\n3. In _animateLayout(), replace:\n   - const DURATION = 200; → use this.animationDuration\n   - const ease = 1 - Math.pow(1 - progress, 3); → const ease = this._applyEasing(progress);\n\n4. In _animateRestore() (from task 2, if it exists; otherwise in _restoreWindow), use this.restoreAnimationDuration.\n\n5. Do NOT change the default values — the app should behave identically with no options passed.\n\n## Don't\n- Don't change default behavior (200ms ease-out-cubic must remain the default)\n- Don't add more than 3 easing options\n- Don't expose these options via IPC or the renderer UI (internal only for now)\n- Don't change the persistence format\n- Don't modify main.js (it passes no options, gets defaults)","acceptance_criteria":"1. WindowManager constructor accepts an optional options object\n2. this.animationDuration defaults to 200 if not specified\n3. this.animationEasing defaults to 'ease-out-cubic' if not specified\n4. this.restoreAnimationDuration defaults to 250 if not specified\n5. _applyEasing('ease-out-cubic', 0.5) returns 1 - Math.pow(0.5, 3) = 0.875\n6. _applyEasing('linear', 0.5) returns 0.5\n7. _applyEasing('ease-in-out-cubic', 0.5) returns 0.5\n8. App launches without errors with no options passed to WindowManager()\n9. Animation behavior is identical to before (same duration, same easing)","status":"closed","priority":3,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-22T04:32:36Z","created_by":"unknown","updated_at":"2026-02-22T04:46:26Z","closed_at":"2026-02-22T04:46:26Z","close_reason":"f33cb7e Make animation duration and easing configurable via constructor options","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.5","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:32:35Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-17p.5","depends_on_id":"StackWindowsElectron-17p.1","type":"blocks","created_at":"2026-02-21T22:33:23Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-17p.5","depends_on_id":"StackWindowsElectron-17p.2","type":"blocks","created_at":"2026-02-21T22:33:24Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.6","title":"Add CSS transitions to managed window list in renderer","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\nCurrently renderManaged() (lines 505-563) destroys and recreates all DOM elements on every update via container.innerHTML = ''. This causes the list to 'jump' visually with no transition. Add smooth CSS transitions for managed window list items.\n\n### CSS Changes (add to the \u003cstyle\u003e block):\n1. Add transition to .managed-item for border-left-color and background:\n   .managed-item {\n     transition: border-left-color 0.2s ease, background-color 0.2s ease;\n   }\n\n2. Add a fade-in animation for new items:\n   @keyframes fadeSlideIn {\n     from { opacity: 0; transform: translateX(-8px); }\n     to { opacity: 1; transform: translateX(0); }\n   }\n   .window-item.entering {\n     animation: fadeSlideIn 0.2s ease forwards;\n   }\n\n### JavaScript Changes to renderManaged():\nReplace the current 'destroy all and recreate' approach with a DOM-diffing strategy:\n\n1. Build a Map of existing DOM items keyed by hwnd (data-hwnd attribute)\n2. Build the new desired list of hwnds from managedWindows\n3. For each window in managedWindows:\n   a. If a DOM element with matching data-hwnd exists: UPDATE it in place (change classes, badge text, etc.)\n   b. If no matching DOM element exists: CREATE a new element with class 'entering'\n4. Remove DOM elements whose hwnd is no longer in managedWindows\n5. Reorder DOM elements to match the managedWindows array order using insertBefore\n\nEach .window-item must have a data-hwnd attribute set to the window's hwnd for identification.\n\n### Key details:\n- The 'entering' class triggers the fadeSlideIn animation\n- The active/inactive class swap triggers the CSS transition on border-left-color and background\n- Remove the 'entering' class after animation ends (use animationend event listener)\n- Keep the empty state rendering (innerHTML for empty state is fine)\n\n## Don't\n- Don't use any framework or virtual DOM library\n- Don't change the visual appearance of items (colors, sizes, fonts must stay the same)\n- Don't modify the available windows list rendering (only managed list)\n- Don't change the IPC communication\n- Don't add transitions longer than 300ms","acceptance_criteria":"1. Managed window items have data-hwnd attributes\n2. When active window changes, the border-left-color and background transition smoothly (0.2s)\n3. When a new window is added to the stack, it fades/slides in from the left\n4. When a window is removed from the stack, its DOM element is removed (no exit animation required)\n5. DOM elements are reused when possible (not destroyed and recreated on every update)\n6. Empty state still renders correctly when all windows are removed\n7. The 'entering' class is removed after animation completes\n8. App launches without errors; adding/removing/switching windows shows smooth list transitions","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-22T04:32:51Z","created_by":"unknown","updated_at":"2026-02-22T04:40:24Z","closed_at":"2026-02-22T04:40:24Z","close_reason":"3f1a10b Add CSS transitions and DOM-diffing to managed window list","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.6","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:32:51Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.7","title":"Fix stale comments about activate-window IPC handler","description":"## Files\n- src/main/main.js (modify)\n- src/renderer/index.html (modify)\n\n## What to do\nThere are stale/contradictory comments in the codebase about the activate-window IPC handler:\n\n### main.js fixes:\n1. Line 109-110: Comment says 'Register IPC handlers — NO activate-window handler. Activation is driven by Win32 focus detection, not Electron.'\n   But line 165 registers an 'activate-window' handler that calls promoteToActive(hwnd, true).\n   \n   Replace the comment at lines 109-110 with:\n   // Register IPC handlers.\n   // Activation is primarily driven by Win32 focus detection (ForegroundMonitor),\n   // but an activate-window handler also exists for explicit UI-driven activation.\n\n2. Line 96-99: Comment says 'Called by ForegroundMonitor when a managed window gains OS focus. This is the ONLY activation path — driven by real Win32 focus, not Electron UI.'\n   This is false — the activate-window IPC handler (line 165) is another activation path.\n   \n   Replace with:\n   // Called by ForegroundMonitor when a managed window gains OS focus.\n   // This is the primary activation path. A secondary path exists via the\n   // 'activate-window' IPC handler for explicit UI-driven activation.\n\n### index.html fixes:\n1. Line 603: Comment says '// API calls — NO activateWindow. Activation is Win32-driven.'\n   But activateWindow() function exists at line 678 and is called from line 524.\n   \n   Replace with:\n   // API calls — activation is primarily Win32-driven, with UI fallback via activateWindow().\n\n## Don't\n- Don't change any code logic, only comments\n- Don't add new comments beyond what's specified\n- Don't reformat or restructure the code\n- Don't change any function signatures or behavior","acceptance_criteria":"1. Comment at main.js line 109-110 accurately describes that activate-window handler exists\n2. Comment at main.js line 96-99 mentions both activation paths (foreground monitor + IPC)\n3. Comment at index.html line 603 acknowledges activateWindow() exists\n4. No code logic changes — only comment text changes\n5. App launches without errors","status":"closed","priority":3,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-22T04:33:06Z","created_by":"unknown","updated_at":"2026-02-22T04:39:51Z","closed_at":"2026-02-22T04:39:51Z","close_reason":"5db73cd Fix stale comments about activate-window IPC handler","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.7","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:33:06Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.8","title":"Add animation-in-progress guard to prevent layout calls during active animation","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nCurrently _animateLayout() always cancels any in-progress animation and starts fresh. While the debounce in main.js (task 4) reduces the frequency of calls, there's still a case where layoutStack() is called while an animation is running and the new target positions are identical to the current targets (e.g., dead window cleanup finds no changes but doLayout still fires).\n\nAdd an optimization to skip redundant animations:\n\n1. Add a property this._currentTargets = null in the constructor\n2. At the start of _animateLayout(targetLayouts), before calling _stopAnimation():\n   - Serialize the target layouts into a comparable key: targetLayouts.map(t =\u003e t.hwnd + ':' + t.x + ',' + t.y + ',' + t.cx + ',' + t.cy).join('|')\n   - Compare with this._currentTargets\n   - If identical AND an animation is currently running (this._animationTimer !== null), return early (skip — already animating to these targets)\n3. If different or no animation running, proceed as normal and store the new key in this._currentTargets\n4. In _stopAnimation(), set this._currentTargets = null (animation completed, targets are reached)\n\nThis prevents unnecessary animation restarts when the target layout hasn't actually changed.\n\n## Don't\n- Don't skip animation when targets have changed (only skip when identical)\n- Don't modify layoutStack()\n- Don't modify main.js\n- Don't add any external dependencies\n- Don't change the animation timing or easing","acceptance_criteria":"1. this._currentTargets is initialized to null in constructor\n2. _animateLayout skips (returns early) when called with identical targets while animation is running\n3. _animateLayout proceeds normally when targets differ from current animation\n4. _animateLayout proceeds normally when no animation is running (even with same targets)\n5. _stopAnimation resets this._currentTargets to null\n6. App launches without errors; switching between windows still animates correctly\n7. Console.log or lack of animation restart confirms redundant calls are skipped","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-22T04:33:18Z","created_by":"unknown","updated_at":"2026-02-22T04:42:12Z","closed_at":"2026-02-22T04:42:12Z","close_reason":"a300a9b Add animation-in-progress guard to prevent redundant layout calls","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.8","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:33:18Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-17p.8","depends_on_id":"StackWindowsElectron-17p.1","type":"blocks","created_at":"2026-02-21T22:33:24Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-3go","title":"Epic: Fix custom dimensions, fix Hide behavior, add background color picker","description":"Tres problemas a resolver: (1) Custom dimensions no tiene efecto visible - el IPC funciona pero el layout no refleja los cambios porque setCustomDimensions recibe los valores correctamente y doLayout se llama, pero el problema es que availableWidth ya es menor o igual al customWidth solicitado, o hay un issue con el flujo. Necesita debugging y fix. (2) El boton Hide oculta la lista de managed windows ademas de available windows - solo deberia ocultar available windows. (3) Agregar un boton de color picker para cambiar el color de fondo de la pila administrativa, persistente entre sesiones.","status":"open","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-20T23:38:55Z","created_by":"unknown","updated_at":"2026-02-20T23:38:55Z","labels":["scope:medium"]}
{"id":"StackWindowsElectron-3go.1","title":"Fix custom dimensions sin efecto - debug y corregir layoutStack","description":"## Files\n- src/main/window-manager.js (modify)\n- src/main/main.js (modify) - posiblemente para agregar logging\n\n## What to do\nEl flujo IPC funciona: set-custom-dimensions llama setCustomDimensions(), luego doLayout(), pero las ventanas no cambian de tamano. \n\n### Analisis de la causa raiz\nEn layoutStack() linea 231: startX = workArea.x + workArea.width. Aqui workArea.x es la posicion X de mainWindow (bounds.x), y workArea.width es el ancho de mainWindow. Entonces startX = borde derecho de la pila administrativa.\n\nLinea 235-238: displayRightEdge viene de main.js como workArea.x + workArea.width del DISPLAY. availableWidth = displayRightEdge - startX. Este es el espacio entre el borde derecho de la pila admin y el borde derecho del monitor.\n\nLinea 242-244: effectiveWidth = Math.min(customWidth, availableWidth). Si customWidth (ej 800) \u003c availableWidth (ej 1620), deberia usar 800.\n\nEl PROBLEMA real: effectiveWidth SI se calcula bien, pero las ventanas de Windows tienen un tamano minimo impuesto por el OS. Ademas, SetWindowPos puede estar siendo sobreescrito por el timer de cleanup (cada 2s) o el resize handler de mainWindow que llama doLayout() sin custom dims.\n\n### Verificacion y fix\n1. Agregar console.log temporal en layoutStack() para imprimir: customWidth, customHeight, availableWidth, availableHeight, effectiveWidth, effectiveHeight justo antes de los SetWindowPos calls.\n2. Verificar que setCustomDimensions realmente guarda los valores (no los pierde por un race condition).\n3. Si el problema es que doLayout se llama desde el resize handler de mainWindow y este sobreescribe, verificar que customWidth/customHeight persisten entre llamadas a layoutStack.\n4. Agregar un console.log en el IPC handler set-custom-dimensions para confirmar que los valores llegan.\n5. Una vez identificado el bug exacto, corregirlo.\n6. REMOVER los console.log de debug despues de confirmar el fix.\n\n### Posible causa alternativa\nEl resize event de mainWindow (linea 48 de main.js) llama doLayout() que a su vez llama layoutStack(). Si el usuario cambia las dimensiones y luego mueve/resize la ventana admin, se re-aplica el layout con los custom dims. Pero si NO hay un trigger de re-layout despues del set-custom-dimensions... verificar que doLayout() SI se llama en el handler IPC (linea 216 de main.js - SI se llama).\n\n## Don't\n- No cambiar la logica de IPC\n- No cambiar la UI\n- No remover la funcionalidad de custom dimensions, solo hacerla funcionar","acceptance_criteria":"1. Establecer customWidth=800 customHeight=600 via Apply en la UI y las ventanas administradas se redimensionan visiblemente a 800x600 o menos. 2. Las ventanas no vuelven a su tamano anterior despues de un ciclo de cleanup (2s). 3. Reset vuelve las ventanas al tamano completo del espacio disponible.","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-20T23:39:20Z","created_by":"unknown","updated_at":"2026-02-20T23:48:45Z","closed_at":"2026-02-20T23:48:45Z","close_reason":"a4c944c fix: restore maximized windows before SetWindowPos so custom dimensions take effect","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-3go.1","depends_on_id":"StackWindowsElectron-3go","type":"parent-child","created_at":"2026-02-20T17:39:20Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-3go.2","title":"Fix Hide button - solo debe ocultar Available Windows, no Managed Stack","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\nEl boton Hide en la seccion Available Windows actualmente oculta la lista de managed windows (pestanas de la pila administrativa) ademas de la lista de available windows. Solo debe ocultar la seccion de Available Windows.\n\n### Causa raiz\nEn toggleAvailableVisibility() (linea 439), cuando isAvailableHidden=true, se calcula un targetHeight que es demasiado pequeno. El calculo en lineas 458-483 usa querySelectorAll('.section') y asume que sections[0] es managed y sections[1] es available. PERO ahora hay 3 secciones .section (dimensions-section, managed, available), asi que los indices estan desfasados.\n\nAdemas, el calculo de targetHeight no incluye la altura de la seccion dimensions-section ni su divider.\n\n### Fix\n1. Cambiar la logica de calculo de targetHeight para que sea robusta:\n   - Sumar la altura de TODOS los elementos visibles excepto el availableList\n   - O mejor: en vez de calcular un targetHeight exacto y hacer resizeApp, simplemente ocultar la seccion completa de Available Windows (el div.section que contiene availableList) y dejar que flexbox maneje el layout naturalmente SIN hacer resizeApp\n2. Alternativa mas simple y robusta: NO llamar resizeApp al ocultar. Solo ocultar el div availableList con display:none. La ventana de Electron mantiene su tamano y el espacio se redistribuye via flexbox.\n3. Elegir la alternativa 2: solo ocultar/mostrar availableList sin redimensionar la ventana de Electron. Esto evita el bug de calculo de alturas.\n\n### Implementacion concreta\n- En toggleAvailableVisibility(), cuando isAvailableHidden=true:\n  - listEl.classList.add('hidden') (ya existe)\n  - btn.textContent = 'Show' (ya existe)\n  - ELIMINAR todo el bloque setTimeout que calcula targetHeight y llama resizeApp\n- Cuando isAvailableHidden=false:\n  - listEl.classList.remove('hidden') (ya existe)\n  - btn.textContent = 'Hide' (ya existe)  \n  - ELIMINAR la llamada a resizeApp que restaura expandedHeight\n- Eliminar la variable expandedHeight ya que no se usa mas\n- Mantener la llamada a toggleAvailableVisibility IPC para persistir el estado\n\n## Don't\n- No tocar la seccion Managed Stack\n- No tocar la seccion Dimensions\n- No cambiar el comportamiento de persistencia del estado hideAvailable","acceptance_criteria":"1. Al hacer clic en Hide, solo se oculta la lista de Available Windows. La lista de Managed Stack (pestanas) sigue visible. 2. Al hacer clic en Show, la lista de Available Windows reaparece. 3. La seccion Dimensions no se ve afectada por Hide/Show. 4. El estado hideAvailable se persiste correctamente.","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-20T23:39:37Z","created_by":"unknown","updated_at":"2026-02-20T23:41:02Z","closed_at":"2026-02-20T23:41:02Z","close_reason":"5d63289 Fix Hide button - remove resizeApp from toggleAvailableVisibility","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-3go.2","depends_on_id":"StackWindowsElectron-3go","type":"parent-child","created_at":"2026-02-20T17:39:36Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-3go.3","title":"Agregar color picker para fondo de la pila administrativa","description":"## Files\n- src/renderer/index.html (modify)\n- src/main/window-manager.js (modify)\n- src/main/main.js (modify)\n- src/main/preload.js (modify)\n- src/main/persistence.js (modify)\n\n## What to do\nAgregar un boton en el header de la pila administrativa que abra un color picker nativo del navegador (input type=color) para elegir el color de fondo de la app. El color debe persistir entre sesiones.\n\n### window-manager.js\n- Agregar this.backgroundColor = '#000000' al constructor (negro por defecto, el color actual)\n- Agregar setBackgroundColor(color): valida que sea un string hex valido (#RRGGBB), guarda en this.backgroundColor\n- Agregar getBackgroundColor(): retorna this.backgroundColor\n- Incluir backgroundColor en getState()\n- Leer backgroundColor en loadState() con fallback a '#000000'\n\n### persistence.js\n- En save(): agregar backgroundColor: state.backgroundColor || '#000000'\n- En load() v2: agregar backgroundColor: data.backgroundColor || '#000000'\n- En load() v1 migration: agregar backgroundColor: '#000000'\n\n### main.js\n- Agregar IPC handler 'set-background-color': llama windowManager.setBackgroundColor(color), sendStateUpdate(), persistence.save()\n- Agregar IPC handler 'get-background-color': retorna windowManager.getBackgroundColor()\n- En sendStateUpdate(): incluir backgroundColor en el objeto enviado\n- En get-managed-windows handler: incluir backgroundColor\n\n### preload.js\n- Exponer setBackgroundColor: (color) =\u003e ipcRenderer.invoke('set-background-color', color)\n- Exponer getBackgroundColor: () =\u003e ipcRenderer.invoke('get-background-color')\n\n### index.html\n- En el header div, agregar un boton pequeno (icono de paleta o cuadrado de color) al lado derecho del titulo\n- Al hacer clic, abrir un input type=color oculto (trigger via click programatico)\n- Al seleccionar un color (evento change del input), llamar window.electronAPI.setBackgroundColor(color) y aplicar document.body.style.backgroundColor = color\n- En onStateUpdate: si data.backgroundColor, aplicar document.body.style.backgroundColor = data.backgroundColor\n- En refreshManaged (init): si result.backgroundColor, aplicar el color\n- CSS del boton: cuadrado de 16x16px con borde #444, el background del boton es el color actual, posicionado en el header con float right o flex\n\n## Don't\n- No usar librerias externas de color picker, usar el nativo input type=color\n- No cambiar el color de texto (solo el fondo)\n- No afectar el color de las ventanas administradas (solo la UI de la pila admin)","acceptance_criteria":"1. Un boton de color aparece en el header de la app. 2. Al hacer clic se abre el color picker nativo del OS. 3. Al elegir un color, el fondo de la app cambia inmediatamente. 4. El color persiste al reiniciar la app. 5. El color por defecto es negro (#000000).","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":40,"created_at":"2026-02-20T23:39:52Z","created_by":"unknown","updated_at":"2026-02-20T23:42:31Z","closed_at":"2026-02-20T23:42:31Z","close_reason":"a3f4331 Add background color picker to admin stack header","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-3go.3","depends_on_id":"StackWindowsElectron-3go","type":"parent-child","created_at":"2026-02-20T17:39:51Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-8oa","title":"Add rename-mode toggle button to managed stack header","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\nAdd a toggle button next to the managed window count (#managedCount) that enables/disables rename mode. When OFF (default), clicking a window title activates the window normally. When ON, clicking a title enters edit mode.\n\n### 1. Add CSS styles (inside existing \u003cstyle\u003e block, after .color-picker-btn:hover)\n\n```css\n.rename-toggle {\n  background: none;\n  border: 1px solid #444;\n  color: #666;\n  font-size: 9px;\n  padding: 2px 8px;\n  border-radius: 999px;\n  cursor: pointer;\n  transition: all 0.15s ease;\n  -webkit-app-region: no-drag;\n  margin-right: 6px;\n}\n\n.rename-toggle:hover {\n  border-color: #888;\n  color: #aaa;\n}\n\n.rename-toggle.active {\n  border-color: #f90;\n  color: #f90;\n  background: rgba(255, 153, 0, 0.1);\n}\n```\n\n### 2. Add the toggle button in HTML\n\nChange the managed stack section-header (line 399-402) from:\n```html\n\u003cdiv class=\"section-header\"\u003e\n  \u003cspan id=\"managedSubtitle\"\u003eMANAGED STACK\u003c/span\u003e\n  \u003cspan id=\"managedCount\"\u003e0\u003c/span\u003e\n\u003c/div\u003e\n```\n\nTo:\n```html\n\u003cdiv class=\"section-header\"\u003e\n  \u003cspan id=\"managedSubtitle\"\u003eMANAGED STACK\u003c/span\u003e\n  \u003cdiv style=\"display: flex; align-items: center; gap: 4px;\"\u003e\n    \u003cbutton id=\"renameToggleBtn\" class=\"rename-toggle\" onclick=\"toggleRenameMode()\" title=\"Toggle rename mode\"\u003e✏️ Rename\u003c/button\u003e\n    \u003cspan id=\"managedCount\"\u003e0\u003c/span\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n```\n\n### 3. Add JS state variable and toggle function\n\nAdd after the existing `let customSizeEnabled = false;` line (line 426):\n```js\nlet renameModeEnabled = false;\n```\n\nAdd the toggle function after the `onBackgroundColorChange` function:\n```js\nfunction toggleRenameMode() {\n  renameModeEnabled = !renameModeEnabled;\n  const btn = document.getElementById('renameToggleBtn');\n  if (renameModeEnabled) {\n    btn.classList.add('active');\n  } else {\n    btn.classList.remove('active');\n  }\n  // Re-render to apply/remove contentEditable\n  renderManaged();\n}\n```\n\n### 4. Modify renderManaged() — CREATE branch (the else block starting ~line 643)\n\nWhen creating the displayName span, make contentEditable conditional on renameModeEnabled:\n\nChange:\n```js\ndisplayName.contentEditable = 'true';\n```\nTo:\n```js\ndisplayName.contentEditable = renameModeEnabled ? 'true' : 'false';\n```\n\nThe click stopPropagation on displayName should ALSO be conditional. Change:\n```js\n// Prevent click from activating the window while editing\ndisplayName.addEventListener('click', (e) =\u003e {\n  e.stopPropagation();\n});\n```\nTo:\n```js\n// Only prevent click propagation (window activation) when rename mode is on\ndisplayName.addEventListener('click', (e) =\u003e {\n  if (renameModeEnabled) {\n    e.stopPropagation();\n  }\n});\n```\n\nThe dblclick handler should also be conditional:\n```js\ndisplayName.addEventListener('dblclick', (e) =\u003e {\n  if (!renameModeEnabled) return;\n  e.stopPropagation();\n  const selection = window.getSelection();\n  const range = document.createRange();\n  range.selectNodeContents(displayName);\n  selection.removeAllRanges();\n  selection.addRange(range);\n});\n```\n\nThe blur handler should only save when rename mode is on:\n```js\ndisplayName.addEventListener('blur', () =\u003e {\n  if (!renameModeEnabled) return;\n  const newName = displayName.textContent.trim();\n  renameWindowTitle(win.hwnd, newName || null);\n});\n```\n\nThe keydown handler should also check:\n```js\ndisplayName.addEventListener('keydown', (e) =\u003e {\n  if (!renameModeEnabled) return;\n  if (e.key === 'Enter') {\n    e.preventDefault();\n    displayName.blur();\n  }\n  if (e.key === 'Escape') {\n    e.preventDefault();\n    displayName.textContent = win.customTitle || win.title || 'Untitled';\n    displayName.blur();\n  }\n});\n```\n\n### 5. Modify renderManaged() — UPDATE branch (the if(item) block starting ~line 596)\n\nWhen updating existing elements, also update the contentEditable state of the display-name:\n\nAfter the existing `if (displayEl \u0026\u0026 document.activeElement !== displayEl) {` block, add:\n```js\nif (displayEl) {\n  displayEl.contentEditable = renameModeEnabled ? 'true' : 'false';\n}\n```\n\n### 6. Remove the hover style when rename mode is off\n\nAdd this CSS rule to make the hover effect only visible in rename mode. Actually, simpler: the .display-name hover effect is harmless when not editable. But to make it clearer, change:\n```css\n.managed-title .display-name:hover {\n  background: rgba(255, 255, 255, 0.08);\n}\n```\nTo:\n```css\n.managed-title .display-name[contenteditable='true']:hover {\n  background: rgba(255, 255, 255, 0.08);\n}\n```\nThis way the hover highlight only shows when rename mode is active.\n\n## Don't\n- Don't change any backend files (main.js, preload.js, window-manager.js)\n- Don't change the renameWindowTitle function\n- Don't remove any existing rename functionality — just gate it behind the toggle\n- Don't persist the rename mode state — it resets to OFF on every app launch","acceptance_criteria":"1. A '✏️ Rename' toggle button appears to the left of the managed count number\n2. The button is OFF by default (no active class, gray appearance)\n3. When OFF: clicking a window title activates the window (normal behavior)\n4. When OFF: the title text is NOT editable (contentEditable=false)\n5. When ON: the button shows orange highlight (active class)\n6. When ON: clicking a title enters edit mode (contentEditable=true)\n7. When ON: double-click selects all text, Enter saves, Escape reverts\n8. Toggling OFF while editing does not cause errors\n9. The hover highlight on titles only appears when rename mode is ON\n10. No backend files modified","status":"open","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-23T21:19:06Z","created_by":"unknown","updated_at":"2026-02-23T21:19:06Z","labels":["scope:small"]}
{"id":"StackWindowsElectron-b1s","title":"Epic: Multi-instance isolation - each app instance manages its own independent window group","description":"## Goal\nWhen the user launches multiple instances of StackWindowsElectron, each instance should manage its own independent group of windows without interfering with other running instances.\n\n## Current Problem\n- There is a single persistence file: window-group.json\n- On startup, loadState() reconnects ALL saved windows regardless of whether another instance is already managing them\n- The 'Available Windows' list shows ALL system windows, including those already managed by another instance\n- No concept of instance identity or group isolation exists\n\n## What Success Looks Like\n1. Each new instance starts FRESH (empty managed stack) - no auto-loading of windows from other instances\n2. Each instance persists to its OWN file (e.g., window-group-\u003cinstanceId\u003e.json)\n3. The 'Available Windows' list EXCLUDES windows already managed by another running instance\n4. When an instance quits, it cleans up its persistence file and restores its windows\n5. Instances can coexist without layout conflicts\n\n## Key Constraints\n- Must NOT break single-instance usage (first launch still works exactly as before)\n- Instance ID should be generated at launch time (UUID or timestamp-based)\n- Cross-instance communication via a shared registry file (not IPC between Electron processes)\n- No new dependencies allowed\n- Backward compatible: old window-group.json should still load for the first instance","status":"open","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-23T18:49:21Z","created_by":"unknown","updated_at":"2026-02-23T18:49:21Z","labels":["needs-integration-review","scope:medium"]}
{"id":"StackWindowsElectron-b1s.1","title":"Add instance registry module (instance-registry.js)","description":"## Files\n- src/main/instance-registry.js (create)\n\n## What to do\nCreate a new module that manages a shared registry of running instances. The registry is a JSON file at \u003cuserData\u003e/instance-registry.json.\n\n### Registry file format:\n```json\n{\n  \"instances\": {\n    \"\u003cinstanceId\u003e\": {\n      \"pid\": 12345,\n      \"startedAt\": \"2026-02-23T...\",\n      \"managedHwnds\": [123, 456, 789]\n    }\n  }\n}\n```\n\n### Class: InstanceRegistry\nConstructor: `new InstanceRegistry()`\n\nMethods:\n- `init()` — Sets filePath to `\u003cuserData\u003e/instance-registry.json`. Generates a unique instanceId using `crypto.randomUUID()`. Calls `_register()` to add this instance to the registry. Returns the instanceId.\n- `_register()` — Reads registry file (or creates empty), adds this instance entry with pid=process.pid, startedAt=now, managedHwnds=[]. Writes file. Before writing, calls `_pruneDeadInstances()`.\n- `_pruneDeadInstances(registry)` — For each instance in registry.instances, check if the PID is still alive using `process.kill(pid, 0)\" wrapped in try/catch (signal 0 doesn't kill, just checks). Remove entries whose PID is dead. Return cleaned registry.\n- `updateManagedHwnds(hwnds)` — Reads registry, updates this instance's managedHwnds array, writes file. Debounce writes to max once per 2 seconds.\n- `getOtherInstancesHwnds()` — Reads registry, prunes dead instances, returns a Set\u003cnumber\u003e of ALL managedHwnds from OTHER instances (not this one).\n- `unregister()` — Removes this instance from registry file. Synchronous (for use in quit handlers). If this was the last instance, delete the registry file.\n- `getInstanceId()` — Returns this instance's ID string.\n\n### File I/O safety:\n- All reads: try/catch, return empty registry on failure\n- All writes: write to temp file first, then rename (atomic write pattern)\n- Use fs.readFileSync/writeFileSync for simplicity (registry is tiny)\n\n## Don't\n- Don't use any IPC or network communication between instances\n- Don't add any npm dependencies\n- Don't use file locking libraries — the atomic write pattern is sufficient\n- Don't export anything except { InstanceRegistry }","acceptance_criteria":"1. File src/main/instance-registry.js exists and exports { InstanceRegistry }\n2. init() generates a unique instanceId (UUID format) and registers in the JSON file\n3. _pruneDeadInstances removes entries whose PID is no longer running\n4. getOtherInstancesHwnds() returns a Set of hwnds from other live instances only\n5. unregister() synchronously removes this instance; deletes file if last instance\n6. updateManagedHwnds() debounces writes to max once per 2 seconds\n7. All file I/O is wrapped in try/catch — never throws\n8. No new npm dependencies added","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-23T18:49:48Z","created_by":"unknown","updated_at":"2026-02-23T18:57:30Z","closed_at":"2026-02-23T18:57:30Z","close_reason":"fc50e05 Add instance registry module","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-b1s.1","depends_on_id":"StackWindowsElectron-b1s","type":"parent-child","created_at":"2026-02-23T12:49:47Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-b1s.1","depends_on_id":"StackWindowsElectron-b1s.4","type":"blocks","created_at":"2026-02-23T12:50:38Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-b1s.1","depends_on_id":"StackWindowsElectron-b1s.6","type":"blocks","created_at":"2026-02-23T12:51:07Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-b1s.2","title":"Make Persistence instance-aware (per-instance file)","description":"## Files\n- src/main/persistence.js (modify)\n\n## What to do\nModify the Persistence class so each app instance saves to its own file instead of the shared window-group.json.\n\n### Changes to constructor:\nNo changes needed.\n\n### Changes to init():\nAdd an optional `instanceId` parameter: `init(instanceId)`\n- If instanceId is provided, set `this.filePath` to `\u003cuserData\u003e/window-group-\u003cinstanceId\u003e.json`\n- If instanceId is null/undefined (backward compat), use the old path `\u003cuserData\u003e/window-group.json`\n- Store instanceId as `this.instanceId = instanceId || null`\n- Log the chosen file path\n\n### New method: cleanupFile()\n- Synchronous method for use in quit handlers\n- If `this.instanceId` is set (instance-aware mode), DELETE the persistence file (`fs.unlinkSync`)\n- If `this.instanceId` is null (legacy mode), do NOT delete (preserve backward compat)\n- Wrap in try/catch, log errors but never throw\n\n### No changes to save(), saveSync(), load(), clear()\nThese methods already work with this.filePath, so they'll automatically use the instance-specific file.\n\n## Don't\n- Don't change the save/saveSync/load/clear method signatures or behavior\n- Don't change the JSON format (still version 2)\n- Don't delete the legacy window-group.json file — it may be used by a first-instance fallback\n- Don't add any npm dependencies","acceptance_criteria":"1. init('abc-123') sets filePath to \u003cuserData\u003e/window-group-abc-123.json\n2. init() with no args still uses \u003cuserData\u003e/window-group.json (backward compat)\n3. cleanupFile() deletes the instance-specific file when instanceId is set\n4. cleanupFile() does NOT delete when instanceId is null\n5. cleanupFile() never throws (wrapped in try/catch)\n6. save/saveSync/load/clear still work unchanged\n7. No new npm dependencies","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-23T18:50:02Z","created_by":"unknown","updated_at":"2026-02-23T18:58:11Z","closed_at":"2026-02-23T18:58:11Z","close_reason":"4193f19 Make Persistence instance-aware with init(instanceId) and cleanupFile()","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-b1s.2","depends_on_id":"StackWindowsElectron-b1s","type":"parent-child","created_at":"2026-02-23T12:50:01Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-b1s.2","depends_on_id":"StackWindowsElectron-b1s.4","type":"blocks","created_at":"2026-02-23T12:50:38Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-b1s.3","title":"Filter available windows to exclude other instances' managed windows","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nModify WindowManager.getAvailableWindows() to accept an optional Set of HWNDs to exclude (windows managed by other instances).\n\n### Changes to getAvailableWindows():\nNew signature: `getAvailableWindows(excludeHwnds = new Set())`\n\nInside the EnumWindows callback, after the existing `if (managedHwnds.has(hwndNum)) return true;` check, add:\n```js\nif (excludeHwnds.has(hwndNum)) return true;\n```\n\nThis filters out windows that other running instances are already managing.\n\n### No other changes to window-manager.js\nThe rest of the class stays exactly the same.\n\n## Don't\n- Don't change any other method in WindowManager\n- Don't import InstanceRegistry in window-manager.js — the caller (main.js) will pass the exclude set\n- Don't change the return format of getAvailableWindows()\n- Don't change addWindow() — a user CAN still force-add a window even if another instance has it (edge case, acceptable)","acceptance_criteria":"1. getAvailableWindows() still works with no arguments (returns all available windows)\n2. getAvailableWindows(new Set([123, 456])) excludes hwnds 123 and 456 from results\n3. The exclude check happens AFTER the managedHwnds check (line order matters for perf)\n4. No other methods in WindowManager are changed\n5. No new imports added to window-manager.js","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-23T18:50:13Z","created_by":"unknown","updated_at":"2026-02-23T18:56:56Z","closed_at":"2026-02-23T18:56:56Z","close_reason":"c7b3ded Add excludeHwnds parameter to getAvailableWindows","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-b1s.3","depends_on_id":"StackWindowsElectron-b1s","type":"parent-child","created_at":"2026-02-23T12:50:13Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-b1s.3","depends_on_id":"StackWindowsElectron-b1s.4","type":"blocks","created_at":"2026-02-23T12:50:38Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-b1s.4","title":"Integrate instance registry into main.js startup and shutdown","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nWire up InstanceRegistry and instance-aware Persistence in main.js so each instance starts fresh and cleans up on exit.\n\n### New import at top:\n```js\nconst { InstanceRegistry } = require('./instance-registry');\n```\n\n### New module-level variable:\n```js\nlet instanceRegistry = null;\n```\n\n### Changes to app.whenReady() block (lines 269-330):\n\n**Replace the initialization section (lines 270-288) with:**\n```js\n// 1. Initialize instance registry\ninstanceRegistry = new InstanceRegistry();\nconst instanceId = instanceRegistry.init();\n\n// 2. Initialize persistence with instance-specific file\npersistence = new Persistence();\npersistence.init(instanceId);\n\n// 3. Initialize window manager — starts EMPTY, no loadState()\nwindowManager = new WindowManager();\n\n// NOTE: We intentionally do NOT call persistence.load() or windowManager.loadState().\n// Each new instance starts with an empty managed stack.\n// The user adds windows manually to this instance's group.\n```\n\n**Remove the savedState loading block entirely** (lines 278-288 and 294-296). Each instance starts fresh. No bounds restoration either (each instance positions itself independently).\n\n**Update the get-available-windows IPC handler** to pass exclude set:\n```js\nipcMain.handle('get-available-windows', async () =\u003e {\n  try {\n    const excludeHwnds = instanceRegistry.getOtherInstancesHwnds();\n    return windowManager.getAvailableWindows(excludeHwnds);\n  } catch (e) {\n    console.error('get-available-windows error:', e);\n    return [];\n  }\n});\n```\n\n**Update the refresh IPC handler** similarly:\n```js\nipcMain.handle('refresh', async () =\u003e {\n  try {\n    const excludeHwnds = instanceRegistry.getOtherInstancesHwnds();\n    return windowManager.getAvailableWindows(excludeHwnds);\n  } catch (e) {\n    console.error('refresh error:', e);\n    return [];\n  }\n});\n```\n\n**Update the add-window IPC handler** to sync registry after adding:\nAfter `persistence.save(windowManager.getState());`, add:\n```js\ninstanceRegistry.updateManagedHwnds(windowManager.getManagedHwnds());\n```\n\n**Update the remove-window IPC handler** similarly — add registry sync after persistence save.\n\n**Update the activate-window IPC handler** — no registry change needed (activation doesn't change the set of managed hwnds).\n\n**Update the cleanup timer** (removeDeadWindows block) — after persistence save, add:\n```js\ninstanceRegistry.updateManagedHwnds(windowManager.getManagedHwnds());\n```\n\n**Remove the auto-save timer** (lines 325-329) — it's redundant since we save on every meaningful change. Or keep it but also sync registry in it.\n\n### Changes to window-all-closed handler:\nBefore `app.quit()`, add:\n```js\npersistence.cleanupFile();\ninstanceRegistry.unregister();\n```\n\n### Changes to before-quit handler:\nAfter the persistence saveSync, add:\n```js\npersistence.cleanupFile();\ninstanceRegistry.unregister();\n```\n\n## Don't\n- Don't call persistence.load() or windowManager.loadState() — instances start empty\n- Don't restore saved bounds — each instance positions itself via createWindow() defaults\n- Don't change createWindow(), doLayout(), sendStateUpdate(), or foreground monitor logic\n- Don't change the IPC handler signatures (renderer API stays the same)\n- Don't remove the debouncedSave function — it's still used by foreground monitor callbacks","acceptance_criteria":"1. App starts with empty managed stack (no windows loaded from persistence)\n2. InstanceRegistry is initialized before Persistence\n3. Persistence uses instance-specific file path (window-group-\u003cid\u003e.json)\n4. get-available-windows and refresh IPC handlers pass excludeHwnds from registry\n5. add-window and remove-window IPC handlers sync registry after persistence save\n6. Cleanup timer syncs registry when dead windows are removed\n7. window-all-closed calls persistence.cleanupFile() and instanceRegistry.unregister()\n8. before-quit calls persistence.cleanupFile() and instanceRegistry.unregister()\n9. No changes to createWindow, doLayout, sendStateUpdate, or foreground monitor\n10. App launches and runs without errors when started with npm start","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-23T18:50:39Z","created_by":"unknown","updated_at":"2026-02-23T19:00:21Z","closed_at":"2026-02-23T19:00:21Z","close_reason":"520cdf3 Integrate instance registry into main.js startup and shutdown","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-b1s.4","depends_on_id":"StackWindowsElectron-b1s","type":"parent-child","created_at":"2026-02-23T12:50:38Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-b1s.4","depends_on_id":"StackWindowsElectron-b1s.5","type":"blocks","created_at":"2026-02-23T12:50:49Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-b1s.4","depends_on_id":"StackWindowsElectron-b1s.6","type":"blocks","created_at":"2026-02-23T12:51:07Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-b1s.5","title":"Show instance ID in controller window title for visual distinction","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nWhen multiple instances are running, the user needs to visually distinguish them. Add the instance ID (short form) to the BrowserWindow title.\n\n### Changes to createWindow() function:\nAfter the line `title: 'Stack Windows',` — this stays as the default.\n\n### Changes to app.whenReady() block:\nAfter createWindow() is called and instanceRegistry is initialized, set the window title:\n```js\nconst shortId = instanceId.substring(0, 8);\nmainWindow.setTitle('Stack Windows [' + shortId + ']');\n```\n\nThis gives titles like: `Stack Windows [a1b2c3d4]`\n\n### No other changes needed.\n\n## Don't\n- Don't change the renderer HTML title element\n- Don't change the stack name logic\n- Don't add the full UUID — only first 8 chars for readability","acceptance_criteria":"1. Controller window title shows 'Stack Windows [XXXXXXXX]' where X is first 8 chars of instanceId\n2. Each instance shows a different short ID\n3. No changes to renderer HTML\n4. No changes to stack name logic","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":10,"created_at":"2026-02-23T18:50:50Z","created_by":"unknown","updated_at":"2026-02-23T19:01:15Z","closed_at":"2026-02-23T19:01:15Z","close_reason":"b48fe5f Show instance ID in controller window title","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-b1s.5","depends_on_id":"StackWindowsElectron-b1s","type":"parent-child","created_at":"2026-02-23T12:50:49Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-b1s.6","title":"Handle stale registry cleanup on startup","description":"## Files\n- src/main/instance-registry.js (modify — if not already handled in task .1)\n- src/main/main.js (modify)\n\n## What to do\nEnsure that if the app crashes or is force-killed (without running quit handlers), stale entries in the instance registry are cleaned up on the next startup.\n\n### This is mostly already handled by _pruneDeadInstances() in task .1, but verify:\n\n1. In InstanceRegistry._register(), _pruneDeadInstances() is called BEFORE adding the new instance. This means every startup cleans up dead entries from crashed instances.\n\n2. In InstanceRegistry.getOtherInstancesHwnds(), _pruneDeadInstances() is called BEFORE collecting hwnds. This means every 'Available Windows' refresh also cleans up.\n\n### Additional cleanup in main.js app.whenReady():\nAfter instanceRegistry.init(), add cleanup of orphaned persistence files:\n```js\n// Clean up orphaned persistence files from crashed instances\nconst userDataPath = app.getPath('userData');\nconst fs = require('fs');\ntry {\n  const files = fs.readdirSync(userDataPath);\n  const registry = instanceRegistry._readRegistry(); // need to expose or inline\n  const liveIds = new Set(Object.keys(registry.instances || {}));\n  \n  for (const file of files) {\n    const match = file.match(/^window-group-(.+)\\.json$/);\n    if (match \u0026\u0026 !liveIds.has(match[1])) {\n      fs.unlinkSync(path.join(userDataPath, file));\n      console.log('Cleaned up orphaned persistence file:', file);\n    }\n  }\n} catch (e) {\n  console.error('Failed to clean orphaned files:', e);\n}\n```\n\n### Expose _readRegistry as a public method:\nIn instance-registry.js, rename `_readRegistry()` to have a public accessor or add:\n```js\ngetRegistry() { return this._readRegistry(); }\n```\n\n## Don't\n- Don't delete window-group.json (the legacy file without instance ID)\n- Don't add complex file locking — simple read+delete is fine\n- Don't make this blocking — if cleanup fails, log and continue","acceptance_criteria":"1. On startup, orphaned window-group-\u003cid\u003e.json files from dead instances are deleted\n2. The legacy window-group.json file is NEVER deleted by this cleanup\n3. Live instance files (whose instance is still in the registry with a live PID) are NOT deleted\n4. Cleanup errors are logged but don't prevent app startup\n5. getRegistry() or equivalent public method exists on InstanceRegistry","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":25,"created_at":"2026-02-23T18:51:07Z","created_by":"unknown","updated_at":"2026-02-23T19:01:37Z","closed_at":"2026-02-23T19:01:37Z","close_reason":"5932da7 Add orphaned persistence file cleanup on startup","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-b1s.6","depends_on_id":"StackWindowsElectron-b1s","type":"parent-child","created_at":"2026-02-23T12:51:07Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5","title":"Epic: Dimensiones personalizables de ventanas + Fix multi-monitor","description":"Las ventanas administradas actualmente ocupan todo el espacio libre de la pantalla. Cuando se usa un segundo monitor en proyeccion ampliada (monitor secundario a la izquierda del principal), las ventanas se extienden abarcando ambos monitores. Causa raiz: layoutStack() usa getPrimaryDisplay() hardcodeado en vez de detectar el monitor donde corre la app. Objetivo: (1) Corregir deteccion de monitor para que las ventanas solo ocupen el monitor donde esta la pila administrativa. (2) Permitir al usuario personalizar ancho y alto de las ventanas administradas desde la UI, aplicando esas dimensiones a todas las ventanas del stack. (3) Persistir las dimensiones custom. Exito: el usuario puede redimensionar sus ventanas administradas y la app funciona correctamente en configuraciones multi-monitor.","status":"open","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-20T23:13:23Z","created_by":"unknown","updated_at":"2026-02-20T23:13:23Z","labels":["needs-integration-review","scope:medium"]}
{"id":"StackWindowsElectron-fv5.1","title":"Fix deteccion de monitor - layoutStack usa getPrimaryDisplay hardcodeado","description":"## Files\n- src/main/main.js (modify)\n- src/main/window-manager.js (modify)\n\n## What to do\n### main.js - getWorkArea() y doLayout()\n- Cambiar getWorkArea() para que reciba opcionalmente un punto {x, y} y use screen.getDisplayNearestPoint() en vez de screen.getPrimaryDisplay(). Si no recibe punto, usar getPrimaryDisplay() como fallback.\n- En doLayout(), obtener bounds de mainWindow, luego llamar screen.getDisplayNearestPoint({ x: bounds.x, y: bounds.y }) para obtener el display correcto. Pasar el workArea de ESE display.\n- Agregar propiedad displayRightEdge al objeto que se pasa a layoutStack: displayRightEdge = display.workArea.x + display.workArea.width\n\n### window-manager.js - layoutStack()\n- Eliminar la linea 232: const primaryDisplay = require('electron').screen.getPrimaryDisplay()\n- Eliminar la linea 233: const screenRightEdge = primaryDisplay.workArea.x + primaryDisplay.workArea.width\n- En su lugar, leer screenBounds.displayRightEdge para calcular availableWidth: const availableWidth = screenBounds.displayRightEdge - startX\n- Si displayRightEdge no viene en screenBounds (backward compat), fallback a calcular con el ancho de pantalla: availableWidth = 1920 - startX\n\n## Don't\n- No cambiar la logica de strips ni de ventana activa\n- No tocar foreground-monitor.js\n- No importar electron/screen dentro de window-manager.js (recibirlo como parametro)","acceptance_criteria":"1. Cuando la app corre en un monitor secundario (izquierda del principal), las ventanas administradas ocupan solo el espacio libre de ESE monitor, no se extienden al primario. 2. Cuando la app corre en el monitor primario, el comportamiento es identico al actual. 3. availableWidth nunca es negativo ni mayor que el ancho del monitor donde esta la app.","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-20T23:13:39Z","created_by":"unknown","updated_at":"2026-02-20T23:17:31Z","closed_at":"2026-02-20T23:17:31Z","close_reason":"64e47a3 Fix multi-monitor: use getDisplayNearestPoint instead of getPrimaryDisplay","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.1","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:13:39Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.2","title":"Agregar estado customWidth/customHeight al WindowManager","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\n### Constructor\n- Agregar this.customWidth = null y this.customHeight = null. null significa usar todo el espacio disponible (comportamiento actual).\n\n### Nuevos metodos\n- setCustomDimensions(width, height): Si width no es null, clampear a Math.max(200, Number(width)). Si height no es null, clampear a Math.max(200, Number(height)). Si es null, guardar null. Guardar en this.customWidth y this.customHeight.\n- getCustomDimensions(): retorna { customWidth: this.customWidth, customHeight: this.customHeight }\n\n### getState()\n- Incluir customWidth: this.customWidth y customHeight: this.customHeight en el objeto retornado.\n\n### loadState()\n- Leer savedState.customWidth y savedState.customHeight. Si existen y no son null, asignarlos (con el mismo clamp de 200 minimo). Si no existen, dejar null.\n\n## Don't\n- No modificar layoutStack() todavia (eso es otra tarea)\n- No tocar la UI\n- No tocar preload.js ni main.js","acceptance_criteria":"1. setCustomDimensions(800, 600) guarda los valores; getCustomDimensions() retorna { customWidth: 800, customHeight: 600 }. 2. setCustomDimensions(null, null) resetea ambos a null. 3. setCustomDimensions(50, 50) clampea a { customWidth: 200, customHeight: 200 }. 4. getState() incluye customWidth y customHeight. 5. loadState({ customWidth: 900, customHeight: 700, windows: [] }) restaura los valores correctamente.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-20T23:13:48Z","created_by":"unknown","updated_at":"2026-02-20T23:17:52Z","closed_at":"2026-02-20T23:17:52Z","close_reason":"c03d80b Add customWidth/customHeight state to WindowManager","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.2","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:13:48Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.3","title":"Fix bug mainWindow null en restauracion de bounds al iniciar","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nEn app.whenReady(), hay un bug critico: en las lineas 220-228 se intenta hacer mainWindow.setBounds(savedState.bounds) pero createWindow() se llama DESPUES en la linea 240, por lo que mainWindow es null en ese punto.\n\n### Fix\n- Mover el bloque de restauracion de bounds (lineas 220-228) DESPUES de la llamada a createWindow() (linea 240).\n- El orden correcto debe ser:\n  1. persistence.init() + persistence.load()\n  2. windowManager = new WindowManager() + windowManager.loadState()\n  3. createWindow()  \u003c-- crea mainWindow\n  4. if (savedState.bounds) mainWindow.setBounds(savedState.bounds)  \u003c-- ahora mainWindow existe\n  5. foregroundMonitor.start()\n  6. registerIPC()\n\n## Don't\n- No cambiar la logica de persistencia\n- No cambiar el orden de inicializacion de windowManager o foregroundMonitor respecto a createWindow, solo mover el setBounds despues de createWindow\n- No agregar try/catch innecesarios, el bloque ya tiene validacion de savedState.bounds","acceptance_criteria":"1. La app no crashea al iniciar con un window-group.json que contiene bounds validos. 2. La app no crashea al iniciar con un window-group.json que tiene bounds: null. 3. Los bounds guardados se restauran correctamente al reiniciar (la ventana aparece en la posicion/tamano guardado).","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":10,"created_at":"2026-02-20T23:13:58Z","created_by":"unknown","updated_at":"2026-02-20T23:17:44Z","closed_at":"2026-02-20T23:17:44Z","close_reason":"235af5b fix: move setBounds after createWindow to prevent null mainWindow crash","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.3","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:13:58Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.4","title":"Integrar dimensiones custom en layoutStack","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nEn layoutStack(), despues de calcular availableWidth y availableHeight (ya corregidos por la tarea de fix multi-monitor), aplicar las dimensiones custom:\n\n### Ancho efectivo\n- Si this.customWidth !== null: effectiveWidth = Math.min(this.customWidth, availableWidth)\n- Si this.customWidth === null: effectiveWidth = availableWidth (comportamiento actual)\n\n### Alto efectivo\n- Si this.customHeight !== null: effectiveHeight = Math.min(this.customHeight, availableHeight)\n- Si this.customHeight === null: effectiveHeight = availableHeight (comportamiento actual)\n\n### Aplicar a SetWindowPos\n- Reemplazar todas las referencias a availableWidth por effectiveWidth en las llamadas a SetWindowPos (tanto para strips como para ventana activa)\n- Reemplazar availableHeight por effectiveHeight donde corresponda\n- La ventana activa: activeHeight = effectiveHeight - (inactiveCount * HEADER_HEIGHT)\n- Los strips: se posicionan con effectiveWidth de ancho y effectiveHeight de alto (para que el cuerpo quede oculto detras de la ventana activa)\n\n### Posicionamiento\n- startX no cambia (las ventanas siguen alineadas al borde derecho de la pila administrativa)\n\n## Don't\n- No cambiar el orden Z ni la logica de activacion (promoteToActive, etc)\n- No centrar las ventanas horizontalmente\n- No modificar HEADER_HEIGHT ni CONTROLLER_WIDTH","acceptance_criteria":"1. Con customWidth=800 y customHeight=600, todas las ventanas administradas tienen maximo 800px de ancho y el conjunto ocupa maximo 600px de alto. 2. Con customWidth=null y customHeight=null, se usa todo el espacio disponible del monitor (comportamiento identico al actual). 3. El ancho custom nunca excede el espacio disponible real del monitor (Math.min). 4. Los strips siguen mostrando HEADER_HEIGHT px de preview cada uno.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":40,"created_at":"2026-02-20T23:14:13Z","created_by":"unknown","updated_at":"2026-02-20T23:18:59Z","closed_at":"2026-02-20T23:18:59Z","close_reason":"Implemented effectiveWidth/effectiveHeight in layoutStack using Math.min(customDim, available)","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.4","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:14:12Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.4","depends_on_id":"StackWindowsElectron-fv5.1","type":"blocks","created_at":"2026-02-20T17:15:34Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.4","depends_on_id":"StackWindowsElectron-fv5.2","type":"blocks","created_at":"2026-02-20T17:15:35Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.5","title":"IPC handlers y preload para dimensiones custom","description":"## Files\n- src/main/main.js (modify)\n- src/main/preload.js (modify)\n\n## What to do\n### main.js - Nuevos IPC handlers\nAgregar dentro de registerIPC():\n\n1. ipcMain.handle('set-custom-dimensions', async (event, width, height) =\u003e { ... })\n   - Llamar windowManager.setCustomDimensions(width, height)\n   - Llamar doLayout()\n   - Llamar sendStateUpdate()\n   - Llamar persistence.save(windowManager.getState())\n   - Retornar { success: true }\n   - Wrap en try/catch, retornar { success: false, error: e.message } en caso de error\n\n2. ipcMain.handle('get-custom-dimensions', async () =\u003e { ... })\n   - Retornar windowManager.getCustomDimensions()\n\n### main.js - sendStateUpdate()\n- Agregar customWidth y customHeight al objeto enviado via state-update:\n  const dims = windowManager.getCustomDimensions();\n  Incluir ...dims en el objeto del send (customWidth: dims.customWidth, customHeight: dims.customHeight)\n\n### preload.js\n- Agregar al objeto expuesto por contextBridge:\n  setCustomDimensions: (width, height) =\u003e ipcRenderer.invoke('set-custom-dimensions', width, height)\n  getCustomDimensions: () =\u003e ipcRenderer.invoke('get-custom-dimensions')\n\n## Don't\n- No tocar la UI (index.html)\n- No modificar handlers IPC existentes\n- No cambiar la firma de sendStateUpdate()","acceptance_criteria":"1. Desde la consola del renderer, window.electronAPI.setCustomDimensions(800, 600) cambia las dimensiones y re-aplica el layout sin error. 2. window.electronAPI.getCustomDimensions() retorna { customWidth: 800, customHeight: 600 }. 3. El evento state-update recibido en el renderer incluye customWidth y customHeight. 4. window.electronAPI.setCustomDimensions(null, null) resetea al comportamiento por defecto.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-20T23:14:22Z","created_by":"unknown","updated_at":"2026-02-20T23:19:35Z","closed_at":"2026-02-20T23:19:35Z","close_reason":"0c14c0f Add IPC handlers and preload for custom dimensions","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.5","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:14:22Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.5","depends_on_id":"StackWindowsElectron-fv5.2","type":"blocks","created_at":"2026-02-20T17:15:35Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.6","title":"Persistencia de dimensiones custom en window-group.json","description":"## Files\n- src/main/persistence.js (modify)\n\n## What to do\n### save()\n- En el objeto data que se escribe a JSON, agregar:\n  customWidth: state.customWidth || null\n  customHeight: state.customHeight || null\n- Posicionar estos campos despues de hideAvailable y antes de bounds\n\n### load()\n- En el objeto retornado, incluir:\n  customWidth: data.customWidth || null\n  customHeight: data.customHeight || null\n- En la migracion v1 a v2, retornar customWidth: null y customHeight: null\n\n### Compatibilidad\n- NO cambiar la version del formato (sigue siendo version: 2)\n- Los campos nuevos son opcionales: si el JSON guardado no los tiene, retornar null para ambos sin error\n- La migracion v1 -\u003e v2 debe seguir funcionando\n\n## Don't\n- No cambiar el nombre del archivo (window-group.json)\n- No agregar validacion de tipos complejos, solo || null es suficiente\n- No romper la estructura existente del JSON","acceptance_criteria":"1. Guardar con dimensiones custom (800, 600) y recargar: los valores se restauran correctamente. 2. Cargar un JSON v2 antiguo (sin customWidth/customHeight): retorna null para ambos sin error. 3. Cargar un JSON v1 (array de windows): retorna null para customWidth/customHeight sin error. 4. El JSON guardado contiene los campos customWidth y customHeight.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-20T23:14:31Z","created_by":"unknown","updated_at":"2026-02-20T23:19:20Z","closed_at":"2026-02-20T23:19:20Z","close_reason":"90c736b persist customWidth/customHeight in window-group.json","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.6","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:14:31Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.6","depends_on_id":"StackWindowsElectron-fv5.2","type":"blocks","created_at":"2026-02-20T17:15:35Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.7","title":"UI - Controles de ancho y alto en el renderer","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\n### Nueva seccion HTML\nAgregar una seccion colapsable 'DIMENSIONS' entre el header y la seccion 'MANAGED STACK'. Estructura:\n\n1. section-header con titulo 'DIMENSIONS' y boton toggle para colapsar/expandir\n2. Contenido colapsable con:\n   - Un checkbox/toggle 'Custom size' (desactivado = usar todo el espacio disponible)\n   - Dos campos en linea cuando el toggle esta activo:\n     - Input numerico 'Width' con min=200, step=10, placeholder con el ancho disponible actual\n     - Input numerico 'Height' con min=200, step=10, placeholder con el alto disponible actual\n   - Boton 'Apply' que llama window.electronAPI.setCustomDimensions(widthValue, heightValue)\n   - Boton 'Reset' que llama window.electronAPI.setCustomDimensions(null, null) y desactiva el toggle\n\n### CSS\n- Estilo consistente con el diseno existente: fondo negro (#000), texto blanco, bordes #333\n- Inputs numericos: fondo #111, borde #444, texto blanco, ancho ~70px cada uno\n- Labels: font-size 10px, color #888, uppercase\n- Seccion colapsada por defecto al iniciar\n\n### JavaScript\n- Variable global customSizeEnabled = false\n- Al recibir state-update con customWidth/customHeight no-null, activar el toggle y llenar los inputs\n- Al recibir state-update con customWidth/customHeight null, desactivar el toggle\n- El boton Apply solo se habilita cuando ambos inputs tienen valores \u003e= 200\n- Funcion toggleDimensionsSection() para colapsar/expandir (similar a toggleAvailableVisibility pero sin resize de la app)\n\n## Don't\n- No usar frameworks (mantener vanilla JS/HTML/CSS inline)\n- No agregar sliders ni range inputs, solo inputs numericos type=number\n- No permitir valores menores a 200 (validar en el onclick de Apply)\n- No modificar las secciones existentes de Managed Stack ni Available Windows\n- No llamar a resizeApp desde esta seccion","acceptance_criteria":"1. La seccion DIMENSIONS aparece entre el header y MANAGED STACK. 2. El toggle Custom size activa/desactiva los inputs. 3. Ingresar 800x600 y hacer clic en Apply llama setCustomDimensions(800, 600) y las ventanas se redimensionan. 4. Reset vuelve al comportamiento de pantalla completa (setCustomDimensions(null, null)). 5. Los valores persisten al recargar la app (se restauran desde state-update). 6. La seccion se puede colapsar/expandir. 7. Estilo visual consistente con el resto de la app.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-20T23:14:48Z","created_by":"unknown","updated_at":"2026-02-20T23:21:23Z","closed_at":"2026-02-20T23:21:23Z","close_reason":"Implemented DIMENSIONS collapsible section with custom size toggle, width/height inputs, Apply/Reset buttons, and state sync in src/renderer/index.html","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.7","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:14:48Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.7","depends_on_id":"StackWindowsElectron-fv5.5","type":"blocks","created_at":"2026-02-20T17:15:36Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-h6u","title":"Epic: Reduce CPU spike on window switch (~25%% to \u003c5%%)","description":"## Goals\nWhen the user switches between managed windows, CPU usage spikes from 1-3%% idle to ~25%% (saturating one core). This epic targets reducing that spike to under 5%%.\n\n## Root Causes Identified\n1. **Animation at 60fps via FFI** - _animateLayout() runs setTimeout(tick, 1000/60) for 200ms, making ~12 frames x N windows x 3 FFI calls per frame = ~60+ FFI calls crossing JS-\u003eC-\u003ekernel boundary in 200ms\n2. **Synchronous disk write on every focus change** - persistence.save() uses fs.writeFileSync() blocking the event loop on every window switch\n3. **Redundant persistence saves** - save() is called on every focus change AND every 10s auto-save timer, with no debouncing between them\n\n## Success Criteria\n- CPU spike on window switch drops from ~25%% to \u003c5%% with 3 managed windows\n- Animation remains visually smooth (no perceptible jank)\n- Window state is still persisted reliably (no data loss on crash)\n- No new dependencies added\n\n## Key Constraints\n- Must remain pure vanilla JS (no frameworks, no TypeScript)\n- Must not break existing Win32 FFI bridge (koffi/user32.dll)\n- Animation must remain in Electron main process\n- Must maintain backward compatibility with persistence format v2\n- All changes testable by running the app and managing 2-3 windows","status":"open","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-22T06:22:03Z","created_by":"unknown","updated_at":"2026-02-22T06:22:03Z","labels":["needs-integration-review","scope:medium"]}
{"id":"StackWindowsElectron-h6u.1","title":"Reduce animation frame rate from 60fps to 30fps","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nIn _animateLayout() at line 476, the animation loop schedules frames at 60fps:\n  setTimeout(tick, 1000 / 60)  // ~16.67ms per frame\n\nChange this to 30fps:\n  setTimeout(tick, 1000 / 30)  // ~33.33ms per frame\n\nThis halves the number of FFI calls (BeginDeferWindowPos + DeferWindowPos*N + EndDeferWindowPos) from ~12 frames to ~6 frames over the 200ms animation duration. Each FFI call crosses the JS-\u003eC-\u003ekernel boundary which is the primary CPU cost.\n\nSimilarly, in _animateRestore() at line 347, change the restore animation frame rate:\n  setTimeout(tick, 1000 / 60)  →  setTimeout(tick, 1000 / 30)\n\n### Why 30fps is sufficient\n- The animation duration is only 200ms (barely perceptible)\n- Window repositioning via SetWindowPos has inherent latency from the Windows compositor\n- 30fps gives 6 frames over 200ms which is enough for smooth cubic ease-out\n- The final snap frame ensures pixel-perfect positioning regardless of frame count\n\n### Implementation\n1. Find line 476 in _animateLayout(): change 1000 / 60 to 1000 / 30\n2. Find line 347 in _animateRestore(): change 1000 / 60 to 1000 / 30\n3. No other changes needed - the timestamp-based progress calculation automatically adapts\n\n## Don't\n- Don't change the animation duration (200ms layout, 250ms restore)\n- Don't change the easing function\n- Don't change the DeferWindowPos batching logic\n- Don't change the final snap logic\n- Don't add any new dependencies\n- Don't modify any other files","acceptance_criteria":"1. Line 476 in _animateLayout uses setTimeout(tick, 1000 / 30) instead of 1000 / 60\n2. Line 347 in _animateRestore uses setTimeout(tick, 1000 / 30) instead of 1000 / 60\n3. App launches without errors\n4. Switching between 3 managed windows still animates smoothly (no visible jank)\n5. Animation still completes in ~200ms (duration unchanged)\n6. CPU spike during window switch is measurably lower than before (fewer FFI calls per animation)","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-22T06:22:29Z","created_by":"unknown","updated_at":"2026-02-22T06:37:28Z","closed_at":"2026-02-22T06:37:28Z","close_reason":"5b37b67 Reduce animation frame rate from 60fps to 30fps","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-h6u.1","depends_on_id":"StackWindowsElectron-h6u","type":"parent-child","created_at":"2026-02-22T00:22:28Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-h6u.2","title":"Replace fs.writeFileSync with async fs.promises.writeFile in persistence.save()","description":"## Files\n- src/main/persistence.js (modify)\n\n## What to do\nCurrently persistence.save() at line 33-48 uses fs.writeFileSync() which blocks the Node.js event loop during disk I/O. This is called on every window focus change, contributing to the CPU spike.\n\n### Changes to persistence.js\n\n1. Change save() from synchronous to async:\n   - Change method signature: save(state) → async save(state)\n   - Replace fs.writeFileSync(this.filePath, ...) with await fs.promises.writeFile(this.filePath, ...)\n   - Keep the same JSON.stringify(data, null, 2) formatting\n   - Keep the same try/catch error handling\n\n2. Add a write guard to prevent concurrent writes:\n   - Add this._writing = false in constructor\n   - At the start of save(), if this._writing is true, store the state in this._pendingState and return\n   - Set this._writing = true before the write\n   - After the write completes, set this._writing = false\n   - If this._pendingState is set, call save(this._pendingState) and clear this._pendingState\n   - This ensures the latest state is always eventually written without overlapping writes\n\n3. Add a synchronous saveSync(state) method:\n   - Move the current synchronous logic to saveSync()\n   - This is needed for app quit (before-quit, window-all-closed) where we MUST write synchronously before the process exits\n\n### Why this matters\nfs.writeFileSync blocks the event loop for the entire duration of the disk write. On a typical SSD this is 1-5ms, but on slower drives or when the OS is busy, it can be 10-50ms. During animation (which runs at 30fps = 33ms per frame), a 10ms block means dropping a frame.\n\n## Don't\n- Don't change the JSON format or structure\n- Don't change the file path logic\n- Don't change the load() method (it can stay synchronous - only runs at startup)\n- Don't change the clear() method\n- Don't add any new dependencies\n- Don't change the version number in the saved data","acceptance_criteria":"1. save() is an async method using await fs.promises.writeFile\n2. saveSync() exists as a synchronous fallback using fs.writeFileSync\n3. Concurrent save() calls don't produce corrupted files (write guard prevents overlapping writes)\n4. The latest state is always eventually written (pending state is flushed after current write)\n5. App launches without errors and window-group.json is written correctly\n6. App quit still saves state reliably (uses saveSync path)\n7. No change to the JSON format or file location","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":25,"created_at":"2026-02-22T06:22:48Z","created_by":"unknown","updated_at":"2026-02-22T06:37:30Z","closed_at":"2026-02-22T06:37:30Z","close_reason":"5b37b67 Replace fs.writeFileSync with async fs.promises.writeFile in persistence.save()","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-h6u.2","depends_on_id":"StackWindowsElectron-h6u","type":"parent-child","created_at":"2026-02-22T00:22:47Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-h6u.3","title":"Switch main.js callers to use async save() and saveSync() for quit paths","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nAfter persistence.save() becomes async (task h6u.2), all callers in main.js need to be updated. Currently persistence.save() is called in 8 places in main.js. Some can be fire-and-forget async, others (quit handlers) must use saveSync().\n\n### Calls that should use async save() (fire-and-forget, no await needed):\nThese are in event handlers where we don't need to wait for the write to complete:\n\n1. Line 112 in onManagedWindowFocused(): persistence.save(windowManager.getState())\n2. Line 151 in add-window handler: persistence.save(windowManager.getState())\n3. Line 165 in remove-window handler: persistence.save(windowManager.getState())\n4. Line 181 in activate-window handler: persistence.save(windowManager.getState())\n5. Line 200 in update-stack-name handler: persistence.save(windowManager.getState())\n6. Line 207 in toggle-available-visibility handler: persistence.save(windowManager.getState())\n7. Line 229 in set-custom-dimensions handler: persistence.save(windowManager.getState())\n8. Line 249 in set-background-color handler: persistence.save(windowManager.getState())\n9. Line 315 in auto-save timer (setInterval every 10s): persistence.save(windowManager.getState())\n\nAll of these are already fire-and-forget (return value is not used). Since save() is now async, these will return a Promise that resolves in the background. No change needed to these lines - they will work as-is because calling an async function without await just runs it in the background.\n\n### Calls that MUST use saveSync() (synchronous quit paths):\nThese are in quit handlers where the process may exit immediately after:\n\n1. Line 327 in window-all-closed handler: change to persistence.saveSync(windowManager.getState())\n2. Line 338 in before-quit handler: change to persistence.saveSync(windowManager.getState())\n\n### Also update the resize handler:\n3. Line 52-53 in mainWindow resize handler: the save call here fires on every resize pixel. Keep it as async save() but this is fine since the debounce in task h6u.4 will handle coalescing.\n\n## Don't\n- Don't add await to the fire-and-forget save() calls (unnecessary, would slow down the handlers)\n- Don't change the logic of any handler (only the save method name for quit paths)\n- Don't modify persistence.js (that's task h6u.2)\n- Don't modify window-manager.js\n- Don't change the auto-save timer interval","acceptance_criteria":"1. Lines 327 and 338 (quit handlers) use persistence.saveSync() instead of persistence.save()\n2. All other persistence.save() calls remain as-is (they work as fire-and-forget with async)\n3. App launches without errors\n4. Quitting the app (closing window or Ctrl+C) still saves state to window-group.json\n5. Window state is correctly persisted after add/remove/activate operations\n6. No unhandled promise rejection warnings in console","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-22T06:23:09Z","created_by":"unknown","updated_at":"2026-02-22T06:40:06Z","closed_at":"2026-02-22T06:40:06Z","close_reason":"986b906 Switch quit handlers to use saveSync() for reliable state persistence","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-h6u.3","depends_on_id":"StackWindowsElectron-h6u","type":"parent-child","created_at":"2026-02-22T00:23:08Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-h6u.3","depends_on_id":"StackWindowsElectron-h6u.2","type":"blocks","created_at":"2026-02-22T00:24:24Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-h6u.4","title":"Add debounced persistence save wrapper in main.js","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nCurrently every window focus change triggers an immediate persistence.save(). With 3 managed windows and rapid Alt-Tab, this can fire 5+ saves per second. Add a debounce wrapper so saves are coalesced.\n\n### Implementation\n\n1. Add a module-level debounce wrapper at the top of main.js (near the other timer variables around line 14-15):\n   let _saveDebounceTimer = null;\n   const SAVE_DEBOUNCE_MS = 2000; // 2 seconds\n\n   function debouncedSave() {\n     if (_saveDebounceTimer) clearTimeout(_saveDebounceTimer);\n     _saveDebounceTimer = setTimeout(() =\u003e {\n       _saveDebounceTimer = null;\n       if (windowManager) {\n         persistence.save(windowManager.getState());\n       }\n     }, SAVE_DEBOUNCE_MS);\n   }\n\n2. Replace persistence.save(windowManager.getState()) with debouncedSave() in these HIGH-FREQUENCY callers:\n   - onManagedWindowFocused() (line 112) - fires on every Alt-Tab\n   - mainWindow resize handler (line 52-53) - fires on every resize pixel\n\n3. Keep IMMEDIATE persistence.save() for these USER-INITIATED actions (low frequency, user expects immediate save):\n   - add-window handler (line 151)\n   - remove-window handler (line 165)\n   - activate-window handler (line 181)\n   - update-stack-name handler (line 200)\n   - toggle-available-visibility handler (line 207)\n   - set-custom-dimensions handler (line 229)\n   - set-background-color handler (line 249)\n\n4. Keep the auto-save timer at 10s (line 313-317) as a safety net.\n\n5. Clean up _saveDebounceTimer in window-all-closed handler (line 320):\n   if (_saveDebounceTimer) clearTimeout(_saveDebounceTimer);\n\n6. In the quit handlers (window-all-closed, before-quit), flush any pending debounced save immediately by clearing the timer and calling saveSync():\n   if (_saveDebounceTimer) {\n     clearTimeout(_saveDebounceTimer);\n     _saveDebounceTimer = null;\n   }\n   // saveSync is already called in these handlers (from task h6u.3)\n\n## Don't\n- Don't debounce user-initiated actions (add, remove, activate, etc.)\n- Don't change the auto-save timer interval\n- Don't modify persistence.js\n- Don't modify window-manager.js\n- Don't use lodash or any external debounce library","acceptance_criteria":"1. A debouncedSave() function exists with 2000ms debounce delay\n2. onManagedWindowFocused uses debouncedSave() instead of direct persistence.save()\n3. mainWindow resize handler uses debouncedSave() instead of direct persistence.save()\n4. User-initiated actions (add, remove, activate, etc.) still use immediate persistence.save()\n5. _saveDebounceTimer is cleaned up in window-all-closed handler\n6. Rapid Alt-Tab between 3 windows produces at most 1 save per 2 seconds (not 5+ per second)\n7. App launches without errors; state is still persisted correctly","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-22T06:23:27Z","created_by":"unknown","updated_at":"2026-02-22T06:40:37Z","closed_at":"2026-02-22T06:40:37Z","close_reason":"1dac10f Add debounced persistence save wrapper in main.js","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-h6u.4","depends_on_id":"StackWindowsElectron-h6u","type":"parent-child","created_at":"2026-02-22T00:23:27Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-h6u.4","depends_on_id":"StackWindowsElectron-h6u.2","type":"blocks","created_at":"2026-02-22T00:24:24Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-h6u.5","title":"Reduce default animation duration from 200ms to 100ms","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nThe current animation duration is 200ms (set via this.animationDuration in the constructor at line 28). At 30fps (after task h6u.1), this means ~6 frames of FFI calls. Reducing to 100ms cuts it to ~3 frames, further halving the CPU cost.\n\n### Changes\n\n1. In the WindowManager constructor (line 28), change the default animation duration:\n   this.animationDuration = options.animationDuration || 100;  // was 200\n\n2. In the constructor (line 30), change the default restore animation duration:\n   this.restoreAnimationDuration = options.restoreAnimationDuration || 150;  // was 250\n\n### Why 100ms is sufficient\n- 200ms was chosen for visual smoothness, but with cubic ease-out easing, 100ms still looks smooth because most of the motion happens in the first 50ms\n- Window managers like Windows 11 Snap use ~150ms animations\n- The user is switching focus, so their attention is on the target window, not the animation\n- The final snap frame ensures pixel-perfect positioning regardless of duration\n\n### Fallback\nThe durations are configurable via constructor options, so if 100ms feels too fast, it can be tuned back up without code changes (just pass options to new WindowManager({ animationDuration: 150 }) in main.js).\n\n## Don't\n- Don't change the easing function\n- Don't change the frame rate (that's task h6u.1)\n- Don't change the animation logic\n- Don't change main.js (it uses defaults)\n- Don't remove the options.animationDuration override capability","acceptance_criteria":"1. this.animationDuration defaults to 100 (was 200)\n2. this.restoreAnimationDuration defaults to 150 (was 250)\n3. App launches without errors\n4. Window switch animation completes in ~100ms (visually faster but still smooth)\n5. Window removal animation completes in ~150ms\n6. Passing options.animationDuration = 200 to constructor still works (override capability preserved)","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":10,"created_at":"2026-02-22T06:23:45Z","created_by":"unknown","updated_at":"2026-02-22T06:37:59Z","closed_at":"2026-02-22T06:37:59Z","close_reason":"6466c77 Reduce default animation duration from 200ms to 100ms","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-h6u.5","depends_on_id":"StackWindowsElectron-h6u","type":"parent-child","created_at":"2026-02-22T00:23:44Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-h6u.6","title":"Add skip-animation option to bypass animation entirely","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nAdd a constructor option to completely skip animation and snap windows to their target positions instantly. This is the nuclear option for users who want zero CPU overhead on window switch.\n\n### Changes to WindowManager constructor (line 14-31)\nAdd a new option:\n  this.skipAnimation = options.skipAnimation || false;\n\n### Changes to _animateLayout() (line 363)\nAt the very beginning of _animateLayout(), add an early-exit path:\n\n  if (this.skipAnimation) {\n    // Instant snap: single DeferWindowPos batch, no animation loop\n    const hWinPosInfo = api.BeginDeferWindowPos(targetLayouts.length);\n    if (hWinPosInfo) {\n      let hInfo = hWinPosInfo;\n      for (const target of targetLayouts) {\n        if (target.restore) {\n          api.ShowWindow(target.hwnd, SW_RESTORE);\n        }\n        hInfo = api.DeferWindowPos(hInfo, target.hwnd, HWND_TOP, target.x, target.y, target.cx, target.cy, target.flags);\n        if (!hInfo) break;\n      }\n      if (hInfo) api.EndDeferWindowPos(hInfo);\n    } else {\n      // Fallback: individual SetWindowPos\n      for (const target of targetLayouts) {\n        if (target.restore) api.ShowWindow(target.hwnd, SW_RESTORE);\n        api.SetWindowPos(target.hwnd, HWND_TOP, target.x, target.y, target.cx, target.cy, target.flags);\n      }\n    }\n    return;\n  }\n\n### Changes to _animateRestore() (line 288)\nAt the very beginning, add:\n\n  if (this.skipAnimation) {\n    this._restoreWindow(entry);\n    callback();\n    return;\n  }\n\n### No changes to main.js\nThe default is skipAnimation: false, so existing behavior is preserved. Users who want to enable it can modify main.js to pass { skipAnimation: true } to the WindowManager constructor.\n\n## Don't\n- Don't enable skipAnimation by default (must be opt-in)\n- Don't add UI controls for this option (internal only)\n- Don't change the animation logic when skipAnimation is false\n- Don't modify main.js\n- Don't modify any other files","acceptance_criteria":"1. this.skipAnimation defaults to false in constructor\n2. When skipAnimation is false, animation works exactly as before (no behavior change)\n3. When skipAnimation is true, _animateLayout snaps windows instantly with a single DeferWindowPos batch (no setTimeout loop)\n4. When skipAnimation is true, _animateRestore calls _restoreWindow directly and invokes callback\n5. App launches without errors with default options\n6. Manually testing with new WindowManager({ skipAnimation: true }) in main.js shows instant window positioning with no animation","status":"closed","priority":3,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-22T06:24:03Z","created_by":"unknown","updated_at":"2026-02-22T06:38:54Z","closed_at":"2026-02-22T06:38:54Z","close_reason":"e110b65 Add skipAnimation option to bypass animation entirely","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-h6u.6","depends_on_id":"StackWindowsElectron-h6u","type":"parent-child","created_at":"2026-02-22T00:24:02Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-ly9","title":"Epic: Rename managed windows in the stack","description":"## Goal\nAllow the user to rename any managed window in the stack to a custom alias. Currently the title shown is whatever Win32 reports (often a browser tab name or irrelevant text). The user wants to set their own label for better control.\n\n## Current Problem\n- Window titles come from Win32 GetWindowTextW and are stored as-is in managedWindows[].title\n- There is no way to edit them from the UI\n- The title persisted is whatever the OS reports, which may be a random browser tab\n\n## What Success Looks Like\n1. Each managed window item in the UI has a way to rename it (double-click on title text)\n2. The custom name is stored in the managedWindows entry as 'customTitle'\n3. The UI displays customTitle when set, falling back to the original title\n4. The custom name persists across the session (saved in the persistence file)\n5. The rename is inline — no modal dialogs\n\n## Key Constraints\n- Must not break existing UI layout or DOM-diffing logic\n- The original Win32 title should still be stored (for reference), the custom title is an overlay\n- No new dependencies","status":"open","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-23T21:06:37Z","created_by":"unknown","updated_at":"2026-02-23T21:06:37Z","labels":["needs-integration-review","scope:small"]}
{"id":"StackWindowsElectron-ly9.1","title":"Add renameWindow method to WindowManager","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\n\n### 1. Add a new field 'customTitle' to managed window entries\n\nIn addWindow() (line 147-151), add `customTitle: null` to the entry object:\n```js\nconst entry = {\n  hwnd: hwndNum,\n  title: title || this._getWindowTitle(hwndNum) || 'Untitled',\n  customTitle: null,   // \u003c-- NEW: user-defined alias, null = use original title\n  processId: pidBuf[0],\n  originalRect: { ... }\n};\n```\n\n### 2. Add renameWindow(hwnd, customTitle) method\n\n```js\n/**\n * Set a custom display name for a managed window.\n * Pass null or empty string to clear the custom name (revert to Win32 title).\n * @param {number} hwnd\n * @param {string|null} customTitle\n * @returns {boolean} true if the window was found and renamed\n */\nrenameWindow(hwnd, customTitle) {\n  const hwndNum = Number(hwnd);\n  const entry = this.managedWindows.find(w =\u003e w.hwnd === hwndNum);\n  if (!entry) return false;\n  entry.customTitle = (customTitle \u0026\u0026 customTitle.trim()) || null;\n  return true;\n}\n```\n\n### 3. Update getManagedWindows() to include customTitle\n\nChange the return map (line 638) to also include customTitle:\n```js\ngetManagedWindows() {\n  return this.managedWindows.map(w =\u003e ({\n    hwnd: w.hwnd,\n    title: w.title,\n    customTitle: w.customTitle || null,\n    processId: w.processId\n  }));\n}\n```\n\n### 4. Update getState() to persist customTitle\n\nChange the windows map in getState() (line 679) to include customTitle:\n```js\nwindows: this.managedWindows.map(w =\u003e ({\n  hwnd: w.hwnd,\n  title: w.title,\n  customTitle: w.customTitle || null,\n  processId: w.processId,\n  originalRect: w.originalRect\n}))\n```\n\n### 5. Update loadState() to restore customTitle\n\nIn the loadState() loop (line 732), add customTitle when pushing:\n```js\nthis.managedWindows.push({\n  hwnd: hwndNum,\n  title: title,\n  customTitle: saved.customTitle || null,   // \u003c-- NEW\n  processId: saved.processId || 0,\n  originalRect: saved.originalRect || { left: 100, top: 100, right: 900, bottom: 700 }\n});\n```\n\n## Don't\n- Don't change the title field itself — it always holds the Win32 title\n- Don't change any layout, animation, or Win32 API logic\n- Don't add imports","acceptance_criteria":"1. renameWindow(hwnd, 'My App') sets customTitle on the matching entry and returns true\n2. renameWindow(hwnd, '') clears customTitle to null\n3. renameWindow(invalidHwnd, 'x') returns false\n4. getManagedWindows() includes customTitle field (null when not set)\n5. getState() includes customTitle in serialized windows array\n6. loadState() restores customTitle from saved data\n7. addWindow() initializes customTitle as null\n8. No other methods changed","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-23T21:06:56Z","created_by":"unknown","updated_at":"2026-02-23T21:09:11Z","closed_at":"2026-02-23T21:09:11Z","close_reason":"32635f8 Add renameWindow method to WindowManager","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-ly9.1","depends_on_id":"StackWindowsElectron-ly9","type":"parent-child","created_at":"2026-02-23T15:06:56Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-ly9.1","depends_on_id":"StackWindowsElectron-ly9.3","type":"blocks","created_at":"2026-02-23T15:07:45Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-ly9.2","title":"Add rename-window IPC handler and preload bridge","description":"## Files\n- src/main/main.js (modify)\n- src/main/preload.js (modify)\n\n## What to do\n\n### 1. Add IPC handler in main.js registerIPC() function\n\nAdd this new handler inside registerIPC(), after the existing 'activate-window' handler:\n\n```js\nipcMain.handle('rename-window', async (event, hwnd, customTitle) =\u003e {\n  try {\n    const found = windowManager.renameWindow(hwnd, customTitle);\n    if (found) {\n      sendStateUpdate();\n      persistence.save(windowManager.getState());\n    }\n    return { success: found };\n  } catch (e) {\n    console.error('rename-window error:', e);\n    return { success: false, error: e.message };\n  }\n});\n```\n\n### 2. Add preload bridge in preload.js\n\nAdd this line inside the contextBridge.exposeInMainWorld object, after the activateWindow entry:\n\n```js\n// Rename a managed window's display title\nrenameWindow: (hwnd, customTitle) =\u003e ipcRenderer.invoke('rename-window', hwnd, customTitle),\n```\n\n## Don't\n- Don't change any existing IPC handlers\n- Don't change sendStateUpdate() — it already sends getManagedWindows() which will include customTitle from task .1\n- Don't add any validation beyond what WindowManager.renameWindow() already does","acceptance_criteria":"1. IPC handler 'rename-window' exists in main.js registerIPC()\n2. Handler calls windowManager.renameWindow(hwnd, customTitle)\n3. Handler calls sendStateUpdate() and persistence.save() on success\n4. Handler returns { success: true/false }\n5. preload.js exposes renameWindow(hwnd, customTitle) via electronAPI\n6. No existing IPC handlers modified\n7. node --check passes on both files","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-23T21:07:09Z","created_by":"unknown","updated_at":"2026-02-23T21:08:52Z","closed_at":"2026-02-23T21:08:52Z","close_reason":"ad7b6c1 Add rename-window IPC handler and preload bridge","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-ly9.2","depends_on_id":"StackWindowsElectron-ly9","type":"parent-child","created_at":"2026-02-23T15:07:09Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-ly9.2","depends_on_id":"StackWindowsElectron-ly9.3","type":"blocks","created_at":"2026-02-23T15:07:45Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-ly9.3","title":"Add inline rename UI to managed window items in renderer","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\nMake the title text of each managed window item double-clickable to rename it inline. The interaction is identical to how the stack name (h1#stackTitle) already works with contenteditable.\n\n### 1. Add CSS styles (inside the existing \u003cstyle\u003e block)\n\nAdd these styles after the existing `.managed-item.inactive` rule (around line 181):\n\n```css\n.managed-title {\n  font-size: 12px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  flex: 1;\n  margin-right: 8px;\n  cursor: pointer;\n}\n\n.managed-title .display-name {\n  cursor: pointer;\n  padding: 1px 3px;\n  border: 1px solid transparent;\n  border-radius: 3px;\n  transition: background 0.15s, border-color 0.15s;\n}\n\n.managed-title .display-name:hover {\n  background: rgba(255, 255, 255, 0.08);\n}\n\n.managed-title .display-name[contenteditable='true']:focus {\n  background: #222;\n  border-color: #555;\n  outline: none;\n  cursor: text;\n  white-space: normal;\n  overflow: visible;\n  text-overflow: clip;\n}\n\n.managed-title .original-title {\n  font-size: 9px;\n  color: #555;\n  display: block;\n  margin-top: 1px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n```\n\n### 2. Add renameWindow JS function (in the \u003cscript\u003e block)\n\nAdd this function after the existing `activateWindow()` function (around line 763):\n\n```js\nasync function renameWindowTitle(hwnd, newTitle) {\n  try {\n    await window.electronAPI.renameWindow(hwnd, newTitle);\n  } catch (e) {\n    console.error('Failed to rename:', e);\n  }\n}\n```\n\n### 3. Modify renderManaged() — UPDATE existing element path (the `if (item)` branch, around line 554)\n\nReplace the title text update section. Currently it does:\n```js\nconst titleEl = item.querySelector('.title');\ntitleEl.textContent = win.title || 'Untitled';\n```\n\nReplace with:\n```js\nconst titleEl = item.querySelector('.managed-title');\nif (titleEl) {\n  const displayEl = titleEl.querySelector('.display-name');\n  const origEl = titleEl.querySelector('.original-title');\n  const displayText = win.customTitle || win.title || 'Untitled';\n  // Only update if not currently being edited\n  if (displayEl \u0026\u0026 document.activeElement !== displayEl) {\n    displayEl.textContent = displayText;\n  }\n  if (origEl) {\n    // Show original title hint only when a custom name is set\n    if (win.customTitle) {\n      origEl.textContent = win.title || '';\n      origEl.style.display = 'block';\n    } else {\n      origEl.textContent = '';\n      origEl.style.display = 'none';\n    }\n  }\n}\n```\n\nAlso update the badge logic — change `titleEl.querySelector('.active-badge, .strip-badge')` to `item.querySelector('.active-badge, .strip-badge')` since the badge will now be inside the actions area instead. Actually, simpler: keep the badge appended to the displayEl. Change:\n```js\nlet badge = titleEl.querySelector('.active-badge, .strip-badge');\n```\nto:\n```js\nlet badge = item.querySelector('.active-badge, .strip-badge');\n```\nAnd append the badge to the actions div instead of the title. Actually, the simplest approach: put the badge AFTER the display-name span, inside the managed-title container. So:\n```js\nlet badge = titleEl.querySelector('.active-badge, .strip-badge');\nif (!badge) {\n  badge = document.createElement('span');\n  titleEl.appendChild(badge);\n}\n```\nThis keeps badges working as before.\n\n### 4. Modify renderManaged() — CREATE new element path (the `else` branch, around line 583)\n\nReplace the title creation block. Currently:\n```js\nconst title = document.createElement('span');\ntitle.className = 'title';\ntitle.textContent = win.title || 'Untitled';\n```\n\nReplace with:\n```js\nconst title = document.createElement('div');\ntitle.className = 'managed-title';\n\nconst displayName = document.createElement('span');\ndisplayName.className = 'display-name';\ndisplayName.contentEditable = 'true';\ndisplayName.spellcheck = false;\ndisplayName.textContent = win.customTitle || win.title || 'Untitled';\n\n// Double-click selects all text for easy replacement\ndisplayName.addEventListener('dblclick', (e) =\u003e {\n  e.stopPropagation();\n  const selection = window.getSelection();\n  const range = document.createRange();\n  range.selectNodeContents(displayName);\n  selection.removeAllRanges();\n  selection.addRange(range);\n});\n\n// Blur saves the rename\ndisplayName.addEventListener('blur', () =\u003e {\n  const newName = displayName.textContent.trim();\n  renameWindowTitle(win.hwnd, newName || null);\n});\n\n// Enter confirms (blur triggers save)\ndisplayName.addEventListener('keydown', (e) =\u003e {\n  if (e.key === 'Enter') {\n    e.preventDefault();\n    displayName.blur();\n  }\n  if (e.key === 'Escape') {\n    e.preventDefault();\n    displayName.textContent = win.customTitle || win.title || 'Untitled';\n    displayName.blur();\n  }\n});\n\n// Prevent click from activating the window while editing\ndisplayName.addEventListener('click', (e) =\u003e {\n  e.stopPropagation();\n});\n\ntitle.appendChild(displayName);\n\n// Show original Win32 title as a hint when custom name is set\nconst origTitle = document.createElement('span');\norigTitle.className = 'original-title';\nif (win.customTitle) {\n  origTitle.textContent = win.title || '';\n  origTitle.style.display = 'block';\n} else {\n  origTitle.style.display = 'none';\n}\ntitle.appendChild(origTitle);\n```\n\nThen the badge creation stays the same but is appended to `title` (the managed-title div).\n\n### 5. Update the item.onclick handler\n\nThe existing item.onclick activates the window. We need to make sure clicking the contenteditable span does NOT trigger activation. The `displayName.addEventListener('click', e.stopPropagation())` above handles this.\n\n## Don't\n- Don't use a modal/prompt dialog — must be inline contenteditable\n- Don't remove the badge (ACTIVE/strip) display logic\n- Don't change the available windows section rendering\n- Don't change the remove button logic\n- Don't break the DOM-diffing (existingItems Map keyed by hwnd)","acceptance_criteria":"1. Double-clicking a managed window title makes it editable inline\n2. Pressing Enter or clicking away saves the custom name via renameWindow IPC\n3. Pressing Escape reverts to the previous name without saving\n4. When a custom name is set, the original Win32 title shows as a small gray hint below\n5. When no custom name is set, only the Win32 title shows (no hint)\n6. Clicking the editable title does NOT activate the window (stopPropagation)\n7. The ACTIVE/strip badges still display correctly\n8. The Remove button still works\n9. DOM-diffing still works (no duplicate elements on state updates)\n10. No modal dialogs used","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-23T21:07:46Z","created_by":"unknown","updated_at":"2026-02-23T21:10:56Z","closed_at":"2026-02-23T21:10:56Z","close_reason":"52e42b5 Add inline rename UI to managed window items","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-ly9.3","depends_on_id":"StackWindowsElectron-ly9","type":"parent-child","created_at":"2026-02-23T15:07:45Z","created_by":"unknown","metadata":"{}"}]}
