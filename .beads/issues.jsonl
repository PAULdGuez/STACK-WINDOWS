{"id":"StackWindowsElectron-3go","title":"Epic: Fix custom dimensions, fix Hide behavior, add background color picker","description":"Tres problemas a resolver: (1) Custom dimensions no tiene efecto visible - el IPC funciona pero el layout no refleja los cambios porque setCustomDimensions recibe los valores correctamente y doLayout se llama, pero el problema es que availableWidth ya es menor o igual al customWidth solicitado, o hay un issue con el flujo. Necesita debugging y fix. (2) El boton Hide oculta la lista de managed windows ademas de available windows - solo deberia ocultar available windows. (3) Agregar un boton de color picker para cambiar el color de fondo de la pila administrativa, persistente entre sesiones.","status":"open","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-20T23:38:55Z","created_by":"unknown","updated_at":"2026-02-20T23:38:55Z","labels":["scope:medium"]}
{"id":"StackWindowsElectron-3go.1","title":"Fix custom dimensions sin efecto - debug y corregir layoutStack","description":"## Files\n- src/main/window-manager.js (modify)\n- src/main/main.js (modify) - posiblemente para agregar logging\n\n## What to do\nEl flujo IPC funciona: set-custom-dimensions llama setCustomDimensions(), luego doLayout(), pero las ventanas no cambian de tamano. \n\n### Analisis de la causa raiz\nEn layoutStack() linea 231: startX = workArea.x + workArea.width. Aqui workArea.x es la posicion X de mainWindow (bounds.x), y workArea.width es el ancho de mainWindow. Entonces startX = borde derecho de la pila administrativa.\n\nLinea 235-238: displayRightEdge viene de main.js como workArea.x + workArea.width del DISPLAY. availableWidth = displayRightEdge - startX. Este es el espacio entre el borde derecho de la pila admin y el borde derecho del monitor.\n\nLinea 242-244: effectiveWidth = Math.min(customWidth, availableWidth). Si customWidth (ej 800) \u003c availableWidth (ej 1620), deberia usar 800.\n\nEl PROBLEMA real: effectiveWidth SI se calcula bien, pero las ventanas de Windows tienen un tamano minimo impuesto por el OS. Ademas, SetWindowPos puede estar siendo sobreescrito por el timer de cleanup (cada 2s) o el resize handler de mainWindow que llama doLayout() sin custom dims.\n\n### Verificacion y fix\n1. Agregar console.log temporal en layoutStack() para imprimir: customWidth, customHeight, availableWidth, availableHeight, effectiveWidth, effectiveHeight justo antes de los SetWindowPos calls.\n2. Verificar que setCustomDimensions realmente guarda los valores (no los pierde por un race condition).\n3. Si el problema es que doLayout se llama desde el resize handler de mainWindow y este sobreescribe, verificar que customWidth/customHeight persisten entre llamadas a layoutStack.\n4. Agregar un console.log en el IPC handler set-custom-dimensions para confirmar que los valores llegan.\n5. Una vez identificado el bug exacto, corregirlo.\n6. REMOVER los console.log de debug despues de confirmar el fix.\n\n### Posible causa alternativa\nEl resize event de mainWindow (linea 48 de main.js) llama doLayout() que a su vez llama layoutStack(). Si el usuario cambia las dimensiones y luego mueve/resize la ventana admin, se re-aplica el layout con los custom dims. Pero si NO hay un trigger de re-layout despues del set-custom-dimensions... verificar que doLayout() SI se llama en el handler IPC (linea 216 de main.js - SI se llama).\n\n## Don't\n- No cambiar la logica de IPC\n- No cambiar la UI\n- No remover la funcionalidad de custom dimensions, solo hacerla funcionar","acceptance_criteria":"1. Establecer customWidth=800 customHeight=600 via Apply en la UI y las ventanas administradas se redimensionan visiblemente a 800x600 o menos. 2. Las ventanas no vuelven a su tamano anterior despues de un ciclo de cleanup (2s). 3. Reset vuelve las ventanas al tamano completo del espacio disponible.","status":"in_progress","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-20T23:39:20Z","created_by":"unknown","updated_at":"2026-02-20T23:40:25Z","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-3go.1","depends_on_id":"StackWindowsElectron-3go","type":"parent-child","created_at":"2026-02-20T17:39:20Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-3go.2","title":"Fix Hide button - solo debe ocultar Available Windows, no Managed Stack","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\nEl boton Hide en la seccion Available Windows actualmente oculta la lista de managed windows (pestanas de la pila administrativa) ademas de la lista de available windows. Solo debe ocultar la seccion de Available Windows.\n\n### Causa raiz\nEn toggleAvailableVisibility() (linea 439), cuando isAvailableHidden=true, se calcula un targetHeight que es demasiado pequeno. El calculo en lineas 458-483 usa querySelectorAll('.section') y asume que sections[0] es managed y sections[1] es available. PERO ahora hay 3 secciones .section (dimensions-section, managed, available), asi que los indices estan desfasados.\n\nAdemas, el calculo de targetHeight no incluye la altura de la seccion dimensions-section ni su divider.\n\n### Fix\n1. Cambiar la logica de calculo de targetHeight para que sea robusta:\n   - Sumar la altura de TODOS los elementos visibles excepto el availableList\n   - O mejor: en vez de calcular un targetHeight exacto y hacer resizeApp, simplemente ocultar la seccion completa de Available Windows (el div.section que contiene availableList) y dejar que flexbox maneje el layout naturalmente SIN hacer resizeApp\n2. Alternativa mas simple y robusta: NO llamar resizeApp al ocultar. Solo ocultar el div availableList con display:none. La ventana de Electron mantiene su tamano y el espacio se redistribuye via flexbox.\n3. Elegir la alternativa 2: solo ocultar/mostrar availableList sin redimensionar la ventana de Electron. Esto evita el bug de calculo de alturas.\n\n### Implementacion concreta\n- En toggleAvailableVisibility(), cuando isAvailableHidden=true:\n  - listEl.classList.add('hidden') (ya existe)\n  - btn.textContent = 'Show' (ya existe)\n  - ELIMINAR todo el bloque setTimeout que calcula targetHeight y llama resizeApp\n- Cuando isAvailableHidden=false:\n  - listEl.classList.remove('hidden') (ya existe)\n  - btn.textContent = 'Hide' (ya existe)  \n  - ELIMINAR la llamada a resizeApp que restaura expandedHeight\n- Eliminar la variable expandedHeight ya que no se usa mas\n- Mantener la llamada a toggleAvailableVisibility IPC para persistir el estado\n\n## Don't\n- No tocar la seccion Managed Stack\n- No tocar la seccion Dimensions\n- No cambiar el comportamiento de persistencia del estado hideAvailable","acceptance_criteria":"1. Al hacer clic en Hide, solo se oculta la lista de Available Windows. La lista de Managed Stack (pestanas) sigue visible. 2. Al hacer clic en Show, la lista de Available Windows reaparece. 3. La seccion Dimensions no se ve afectada por Hide/Show. 4. El estado hideAvailable se persiste correctamente.","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-20T23:39:37Z","created_by":"unknown","updated_at":"2026-02-20T23:41:02Z","closed_at":"2026-02-20T23:41:02Z","close_reason":"5d63289 Fix Hide button - remove resizeApp from toggleAvailableVisibility","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-3go.2","depends_on_id":"StackWindowsElectron-3go","type":"parent-child","created_at":"2026-02-20T17:39:36Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-3go.3","title":"Agregar color picker para fondo de la pila administrativa","description":"## Files\n- src/renderer/index.html (modify)\n- src/main/window-manager.js (modify)\n- src/main/main.js (modify)\n- src/main/preload.js (modify)\n- src/main/persistence.js (modify)\n\n## What to do\nAgregar un boton en el header de la pila administrativa que abra un color picker nativo del navegador (input type=color) para elegir el color de fondo de la app. El color debe persistir entre sesiones.\n\n### window-manager.js\n- Agregar this.backgroundColor = '#000000' al constructor (negro por defecto, el color actual)\n- Agregar setBackgroundColor(color): valida que sea un string hex valido (#RRGGBB), guarda en this.backgroundColor\n- Agregar getBackgroundColor(): retorna this.backgroundColor\n- Incluir backgroundColor en getState()\n- Leer backgroundColor en loadState() con fallback a '#000000'\n\n### persistence.js\n- En save(): agregar backgroundColor: state.backgroundColor || '#000000'\n- En load() v2: agregar backgroundColor: data.backgroundColor || '#000000'\n- En load() v1 migration: agregar backgroundColor: '#000000'\n\n### main.js\n- Agregar IPC handler 'set-background-color': llama windowManager.setBackgroundColor(color), sendStateUpdate(), persistence.save()\n- Agregar IPC handler 'get-background-color': retorna windowManager.getBackgroundColor()\n- En sendStateUpdate(): incluir backgroundColor en el objeto enviado\n- En get-managed-windows handler: incluir backgroundColor\n\n### preload.js\n- Exponer setBackgroundColor: (color) =\u003e ipcRenderer.invoke('set-background-color', color)\n- Exponer getBackgroundColor: () =\u003e ipcRenderer.invoke('get-background-color')\n\n### index.html\n- En el header div, agregar un boton pequeno (icono de paleta o cuadrado de color) al lado derecho del titulo\n- Al hacer clic, abrir un input type=color oculto (trigger via click programatico)\n- Al seleccionar un color (evento change del input), llamar window.electronAPI.setBackgroundColor(color) y aplicar document.body.style.backgroundColor = color\n- En onStateUpdate: si data.backgroundColor, aplicar document.body.style.backgroundColor = data.backgroundColor\n- En refreshManaged (init): si result.backgroundColor, aplicar el color\n- CSS del boton: cuadrado de 16x16px con borde #444, el background del boton es el color actual, posicionado en el header con float right o flex\n\n## Don't\n- No usar librerias externas de color picker, usar el nativo input type=color\n- No cambiar el color de texto (solo el fondo)\n- No afectar el color de las ventanas administradas (solo la UI de la pila admin)","acceptance_criteria":"1. Un boton de color aparece en el header de la app. 2. Al hacer clic se abre el color picker nativo del OS. 3. Al elegir un color, el fondo de la app cambia inmediatamente. 4. El color persiste al reiniciar la app. 5. El color por defecto es negro (#000000).","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":40,"created_at":"2026-02-20T23:39:52Z","created_by":"unknown","updated_at":"2026-02-20T23:42:31Z","closed_at":"2026-02-20T23:42:31Z","close_reason":"a3f4331 Add background color picker to admin stack header","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-3go.3","depends_on_id":"StackWindowsElectron-3go","type":"parent-child","created_at":"2026-02-20T17:39:51Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5","title":"Epic: Dimensiones personalizables de ventanas + Fix multi-monitor","description":"Las ventanas administradas actualmente ocupan todo el espacio libre de la pantalla. Cuando se usa un segundo monitor en proyeccion ampliada (monitor secundario a la izquierda del principal), las ventanas se extienden abarcando ambos monitores. Causa raiz: layoutStack() usa getPrimaryDisplay() hardcodeado en vez de detectar el monitor donde corre la app. Objetivo: (1) Corregir deteccion de monitor para que las ventanas solo ocupen el monitor donde esta la pila administrativa. (2) Permitir al usuario personalizar ancho y alto de las ventanas administradas desde la UI, aplicando esas dimensiones a todas las ventanas del stack. (3) Persistir las dimensiones custom. Exito: el usuario puede redimensionar sus ventanas administradas y la app funciona correctamente en configuraciones multi-monitor.","status":"open","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-20T23:13:23Z","created_by":"unknown","updated_at":"2026-02-20T23:13:23Z","labels":["needs-integration-review","scope:medium"]}
{"id":"StackWindowsElectron-fv5.1","title":"Fix deteccion de monitor - layoutStack usa getPrimaryDisplay hardcodeado","description":"## Files\n- src/main/main.js (modify)\n- src/main/window-manager.js (modify)\n\n## What to do\n### main.js - getWorkArea() y doLayout()\n- Cambiar getWorkArea() para que reciba opcionalmente un punto {x, y} y use screen.getDisplayNearestPoint() en vez de screen.getPrimaryDisplay(). Si no recibe punto, usar getPrimaryDisplay() como fallback.\n- En doLayout(), obtener bounds de mainWindow, luego llamar screen.getDisplayNearestPoint({ x: bounds.x, y: bounds.y }) para obtener el display correcto. Pasar el workArea de ESE display.\n- Agregar propiedad displayRightEdge al objeto que se pasa a layoutStack: displayRightEdge = display.workArea.x + display.workArea.width\n\n### window-manager.js - layoutStack()\n- Eliminar la linea 232: const primaryDisplay = require('electron').screen.getPrimaryDisplay()\n- Eliminar la linea 233: const screenRightEdge = primaryDisplay.workArea.x + primaryDisplay.workArea.width\n- En su lugar, leer screenBounds.displayRightEdge para calcular availableWidth: const availableWidth = screenBounds.displayRightEdge - startX\n- Si displayRightEdge no viene en screenBounds (backward compat), fallback a calcular con el ancho de pantalla: availableWidth = 1920 - startX\n\n## Don't\n- No cambiar la logica de strips ni de ventana activa\n- No tocar foreground-monitor.js\n- No importar electron/screen dentro de window-manager.js (recibirlo como parametro)","acceptance_criteria":"1. Cuando la app corre en un monitor secundario (izquierda del principal), las ventanas administradas ocupan solo el espacio libre de ESE monitor, no se extienden al primario. 2. Cuando la app corre en el monitor primario, el comportamiento es identico al actual. 3. availableWidth nunca es negativo ni mayor que el ancho del monitor donde esta la app.","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-20T23:13:39Z","created_by":"unknown","updated_at":"2026-02-20T23:17:31Z","closed_at":"2026-02-20T23:17:31Z","close_reason":"64e47a3 Fix multi-monitor: use getDisplayNearestPoint instead of getPrimaryDisplay","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.1","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:13:39Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.2","title":"Agregar estado customWidth/customHeight al WindowManager","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\n### Constructor\n- Agregar this.customWidth = null y this.customHeight = null. null significa usar todo el espacio disponible (comportamiento actual).\n\n### Nuevos metodos\n- setCustomDimensions(width, height): Si width no es null, clampear a Math.max(200, Number(width)). Si height no es null, clampear a Math.max(200, Number(height)). Si es null, guardar null. Guardar en this.customWidth y this.customHeight.\n- getCustomDimensions(): retorna { customWidth: this.customWidth, customHeight: this.customHeight }\n\n### getState()\n- Incluir customWidth: this.customWidth y customHeight: this.customHeight en el objeto retornado.\n\n### loadState()\n- Leer savedState.customWidth y savedState.customHeight. Si existen y no son null, asignarlos (con el mismo clamp de 200 minimo). Si no existen, dejar null.\n\n## Don't\n- No modificar layoutStack() todavia (eso es otra tarea)\n- No tocar la UI\n- No tocar preload.js ni main.js","acceptance_criteria":"1. setCustomDimensions(800, 600) guarda los valores; getCustomDimensions() retorna { customWidth: 800, customHeight: 600 }. 2. setCustomDimensions(null, null) resetea ambos a null. 3. setCustomDimensions(50, 50) clampea a { customWidth: 200, customHeight: 200 }. 4. getState() incluye customWidth y customHeight. 5. loadState({ customWidth: 900, customHeight: 700, windows: [] }) restaura los valores correctamente.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-20T23:13:48Z","created_by":"unknown","updated_at":"2026-02-20T23:17:52Z","closed_at":"2026-02-20T23:17:52Z","close_reason":"c03d80b Add customWidth/customHeight state to WindowManager","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.2","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:13:48Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.3","title":"Fix bug mainWindow null en restauracion de bounds al iniciar","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nEn app.whenReady(), hay un bug critico: en las lineas 220-228 se intenta hacer mainWindow.setBounds(savedState.bounds) pero createWindow() se llama DESPUES en la linea 240, por lo que mainWindow es null en ese punto.\n\n### Fix\n- Mover el bloque de restauracion de bounds (lineas 220-228) DESPUES de la llamada a createWindow() (linea 240).\n- El orden correcto debe ser:\n  1. persistence.init() + persistence.load()\n  2. windowManager = new WindowManager() + windowManager.loadState()\n  3. createWindow()  \u003c-- crea mainWindow\n  4. if (savedState.bounds) mainWindow.setBounds(savedState.bounds)  \u003c-- ahora mainWindow existe\n  5. foregroundMonitor.start()\n  6. registerIPC()\n\n## Don't\n- No cambiar la logica de persistencia\n- No cambiar el orden de inicializacion de windowManager o foregroundMonitor respecto a createWindow, solo mover el setBounds despues de createWindow\n- No agregar try/catch innecesarios, el bloque ya tiene validacion de savedState.bounds","acceptance_criteria":"1. La app no crashea al iniciar con un window-group.json que contiene bounds validos. 2. La app no crashea al iniciar con un window-group.json que tiene bounds: null. 3. Los bounds guardados se restauran correctamente al reiniciar (la ventana aparece en la posicion/tamano guardado).","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":10,"created_at":"2026-02-20T23:13:58Z","created_by":"unknown","updated_at":"2026-02-20T23:17:44Z","closed_at":"2026-02-20T23:17:44Z","close_reason":"235af5b fix: move setBounds after createWindow to prevent null mainWindow crash","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.3","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:13:58Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.4","title":"Integrar dimensiones custom en layoutStack","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nEn layoutStack(), despues de calcular availableWidth y availableHeight (ya corregidos por la tarea de fix multi-monitor), aplicar las dimensiones custom:\n\n### Ancho efectivo\n- Si this.customWidth !== null: effectiveWidth = Math.min(this.customWidth, availableWidth)\n- Si this.customWidth === null: effectiveWidth = availableWidth (comportamiento actual)\n\n### Alto efectivo\n- Si this.customHeight !== null: effectiveHeight = Math.min(this.customHeight, availableHeight)\n- Si this.customHeight === null: effectiveHeight = availableHeight (comportamiento actual)\n\n### Aplicar a SetWindowPos\n- Reemplazar todas las referencias a availableWidth por effectiveWidth en las llamadas a SetWindowPos (tanto para strips como para ventana activa)\n- Reemplazar availableHeight por effectiveHeight donde corresponda\n- La ventana activa: activeHeight = effectiveHeight - (inactiveCount * HEADER_HEIGHT)\n- Los strips: se posicionan con effectiveWidth de ancho y effectiveHeight de alto (para que el cuerpo quede oculto detras de la ventana activa)\n\n### Posicionamiento\n- startX no cambia (las ventanas siguen alineadas al borde derecho de la pila administrativa)\n\n## Don't\n- No cambiar el orden Z ni la logica de activacion (promoteToActive, etc)\n- No centrar las ventanas horizontalmente\n- No modificar HEADER_HEIGHT ni CONTROLLER_WIDTH","acceptance_criteria":"1. Con customWidth=800 y customHeight=600, todas las ventanas administradas tienen maximo 800px de ancho y el conjunto ocupa maximo 600px de alto. 2. Con customWidth=null y customHeight=null, se usa todo el espacio disponible del monitor (comportamiento identico al actual). 3. El ancho custom nunca excede el espacio disponible real del monitor (Math.min). 4. Los strips siguen mostrando HEADER_HEIGHT px de preview cada uno.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":40,"created_at":"2026-02-20T23:14:13Z","created_by":"unknown","updated_at":"2026-02-20T23:18:59Z","closed_at":"2026-02-20T23:18:59Z","close_reason":"Implemented effectiveWidth/effectiveHeight in layoutStack using Math.min(customDim, available)","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.4","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:14:12Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.4","depends_on_id":"StackWindowsElectron-fv5.1","type":"blocks","created_at":"2026-02-20T17:15:34Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.4","depends_on_id":"StackWindowsElectron-fv5.2","type":"blocks","created_at":"2026-02-20T17:15:35Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.5","title":"IPC handlers y preload para dimensiones custom","description":"## Files\n- src/main/main.js (modify)\n- src/main/preload.js (modify)\n\n## What to do\n### main.js - Nuevos IPC handlers\nAgregar dentro de registerIPC():\n\n1. ipcMain.handle('set-custom-dimensions', async (event, width, height) =\u003e { ... })\n   - Llamar windowManager.setCustomDimensions(width, height)\n   - Llamar doLayout()\n   - Llamar sendStateUpdate()\n   - Llamar persistence.save(windowManager.getState())\n   - Retornar { success: true }\n   - Wrap en try/catch, retornar { success: false, error: e.message } en caso de error\n\n2. ipcMain.handle('get-custom-dimensions', async () =\u003e { ... })\n   - Retornar windowManager.getCustomDimensions()\n\n### main.js - sendStateUpdate()\n- Agregar customWidth y customHeight al objeto enviado via state-update:\n  const dims = windowManager.getCustomDimensions();\n  Incluir ...dims en el objeto del send (customWidth: dims.customWidth, customHeight: dims.customHeight)\n\n### preload.js\n- Agregar al objeto expuesto por contextBridge:\n  setCustomDimensions: (width, height) =\u003e ipcRenderer.invoke('set-custom-dimensions', width, height)\n  getCustomDimensions: () =\u003e ipcRenderer.invoke('get-custom-dimensions')\n\n## Don't\n- No tocar la UI (index.html)\n- No modificar handlers IPC existentes\n- No cambiar la firma de sendStateUpdate()","acceptance_criteria":"1. Desde la consola del renderer, window.electronAPI.setCustomDimensions(800, 600) cambia las dimensiones y re-aplica el layout sin error. 2. window.electronAPI.getCustomDimensions() retorna { customWidth: 800, customHeight: 600 }. 3. El evento state-update recibido en el renderer incluye customWidth y customHeight. 4. window.electronAPI.setCustomDimensions(null, null) resetea al comportamiento por defecto.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-20T23:14:22Z","created_by":"unknown","updated_at":"2026-02-20T23:19:35Z","closed_at":"2026-02-20T23:19:35Z","close_reason":"0c14c0f Add IPC handlers and preload for custom dimensions","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.5","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:14:22Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.5","depends_on_id":"StackWindowsElectron-fv5.2","type":"blocks","created_at":"2026-02-20T17:15:35Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.6","title":"Persistencia de dimensiones custom en window-group.json","description":"## Files\n- src/main/persistence.js (modify)\n\n## What to do\n### save()\n- En el objeto data que se escribe a JSON, agregar:\n  customWidth: state.customWidth || null\n  customHeight: state.customHeight || null\n- Posicionar estos campos despues de hideAvailable y antes de bounds\n\n### load()\n- En el objeto retornado, incluir:\n  customWidth: data.customWidth || null\n  customHeight: data.customHeight || null\n- En la migracion v1 a v2, retornar customWidth: null y customHeight: null\n\n### Compatibilidad\n- NO cambiar la version del formato (sigue siendo version: 2)\n- Los campos nuevos son opcionales: si el JSON guardado no los tiene, retornar null para ambos sin error\n- La migracion v1 -\u003e v2 debe seguir funcionando\n\n## Don't\n- No cambiar el nombre del archivo (window-group.json)\n- No agregar validacion de tipos complejos, solo || null es suficiente\n- No romper la estructura existente del JSON","acceptance_criteria":"1. Guardar con dimensiones custom (800, 600) y recargar: los valores se restauran correctamente. 2. Cargar un JSON v2 antiguo (sin customWidth/customHeight): retorna null para ambos sin error. 3. Cargar un JSON v1 (array de windows): retorna null para customWidth/customHeight sin error. 4. El JSON guardado contiene los campos customWidth y customHeight.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-20T23:14:31Z","created_by":"unknown","updated_at":"2026-02-20T23:19:20Z","closed_at":"2026-02-20T23:19:20Z","close_reason":"90c736b persist customWidth/customHeight in window-group.json","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.6","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:14:31Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.6","depends_on_id":"StackWindowsElectron-fv5.2","type":"blocks","created_at":"2026-02-20T17:15:35Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.7","title":"UI - Controles de ancho y alto en el renderer","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\n### Nueva seccion HTML\nAgregar una seccion colapsable 'DIMENSIONS' entre el header y la seccion 'MANAGED STACK'. Estructura:\n\n1. section-header con titulo 'DIMENSIONS' y boton toggle para colapsar/expandir\n2. Contenido colapsable con:\n   - Un checkbox/toggle 'Custom size' (desactivado = usar todo el espacio disponible)\n   - Dos campos en linea cuando el toggle esta activo:\n     - Input numerico 'Width' con min=200, step=10, placeholder con el ancho disponible actual\n     - Input numerico 'Height' con min=200, step=10, placeholder con el alto disponible actual\n   - Boton 'Apply' que llama window.electronAPI.setCustomDimensions(widthValue, heightValue)\n   - Boton 'Reset' que llama window.electronAPI.setCustomDimensions(null, null) y desactiva el toggle\n\n### CSS\n- Estilo consistente con el diseno existente: fondo negro (#000), texto blanco, bordes #333\n- Inputs numericos: fondo #111, borde #444, texto blanco, ancho ~70px cada uno\n- Labels: font-size 10px, color #888, uppercase\n- Seccion colapsada por defecto al iniciar\n\n### JavaScript\n- Variable global customSizeEnabled = false\n- Al recibir state-update con customWidth/customHeight no-null, activar el toggle y llenar los inputs\n- Al recibir state-update con customWidth/customHeight null, desactivar el toggle\n- El boton Apply solo se habilita cuando ambos inputs tienen valores \u003e= 200\n- Funcion toggleDimensionsSection() para colapsar/expandir (similar a toggleAvailableVisibility pero sin resize de la app)\n\n## Don't\n- No usar frameworks (mantener vanilla JS/HTML/CSS inline)\n- No agregar sliders ni range inputs, solo inputs numericos type=number\n- No permitir valores menores a 200 (validar en el onclick de Apply)\n- No modificar las secciones existentes de Managed Stack ni Available Windows\n- No llamar a resizeApp desde esta seccion","acceptance_criteria":"1. La seccion DIMENSIONS aparece entre el header y MANAGED STACK. 2. El toggle Custom size activa/desactiva los inputs. 3. Ingresar 800x600 y hacer clic en Apply llama setCustomDimensions(800, 600) y las ventanas se redimensionan. 4. Reset vuelve al comportamiento de pantalla completa (setCustomDimensions(null, null)). 5. Los valores persisten al recargar la app (se restauran desde state-update). 6. La seccion se puede colapsar/expandir. 7. Estilo visual consistente con el resto de la app.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-20T23:14:48Z","created_by":"unknown","updated_at":"2026-02-20T23:21:23Z","closed_at":"2026-02-20T23:21:23Z","close_reason":"Implemented DIMENSIONS collapsible section with custom size toggle, width/height inputs, Apply/Reset buttons, and state sync in src/renderer/index.html","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.7","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:14:48Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.7","depends_on_id":"StackWindowsElectron-fv5.5","type":"blocks","created_at":"2026-02-20T17:15:36Z","created_by":"unknown","metadata":"{}"}]}
