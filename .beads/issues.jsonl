{"id":"StackWindowsElectron-17p","title":"Epic: Improve window transition animation system","description":"## Goals\nThis epic improves the Win32 window transition animation system in StackWindowsElectron. The current system uses a 200ms/12-frame setInterval-based animation with cubic ease-out to move real OS windows via DeferWindowPos. While functional, it has several issues:\n\n1. **Timing fragility**: setInterval at 16.67ms in Node.js is not guaranteed to fire on time, causing frame drops and choppy motion\n2. **No animation on removal**: removeWindow() and restoreAll() snap windows instantly, jarring contrast with smooth add/activate\n3. **Redundant Z-order work**: Every animation frame re-issues HWND_TOP for all windows, causing potential flicker\n4. **Rapid trigger jank**: Fast Alt-Tab restarts animation from scratch each time, resetting the 200ms duration\n5. **No CSS transitions in renderer**: Managed window list re-renders with innerHTML='', causing visual jumps\n6. **Stale code comments**: Comments claim no activate-window handler exists, but one does (line 165 main.js)\n\n## Success Criteria\n- Animation uses timestamp-based progress (performance.now/Date.now) instead of frame counting\n- Window removal is animated (slide back to original position)\n- Intermediate animation frames use SWP_NOZORDER to reduce flicker\n- Rapid layout triggers are debounced to prevent animation restart jank\n- Managed window list in renderer has CSS enter/exit transitions\n- All stale comments are corrected\n\n## Key Constraints\n- Must remain pure vanilla JS (no frameworks, no TypeScript)\n- Must not break existing Win32 FFI bridge (koffi/user32.dll)\n- Animation must remain in Electron main process (no requestAnimationFrame available)\n- Must maintain backward compatibility with persistence format v2\n- All changes must be testable by running the app and managing 2-3 windows","status":"open","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-22T04:31:19Z","created_by":"unknown","updated_at":"2026-02-22T04:31:19Z","labels":["scope:medium"]}
{"id":"StackWindowsElectron-17p.1","title":"Refactor _animateLayout to use timestamp-based progress instead of frame counting","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nReplace the current setInterval + frame-counting animation engine in _animateLayout() (lines 237-339) with a timestamp-based approach using setTimeout recursion and Date.now() (or process.hrtime).\n\nCurrent implementation:\n- Uses setInterval at 1000/60 (~16.67ms)\n- Counts frames: currentFrame++ up to TOTAL_FRAMES (12)\n- Progress = currentFrame / TOTAL_FRAMES\n- Problem: if setInterval fires late, frames bunch up or get skipped\n\nNew implementation:\n- Record startTime = Date.now() at animation start\n- Use recursive setTimeout (not setInterval) for each frame\n- Calculate progress = (Date.now() - startTime) / DURATION\n- Clamp progress to [0, 1]\n- Keep the same easing function: ease = 1 - Math.pow(1 - progress, 3)\n- Keep the same DeferWindowPos batching logic\n- Keep the same final snap logic when progress \u003e= 1\n- Keep the same error handling / fallback to instant SetWindowPos\n- Change _stopAnimation() to use clearTimeout instead of clearInterval\n- Rename _animationInterval to _animationTimer for clarity\n\nThe DURATION constant (200ms) and easing function must NOT change. Only the timing mechanism changes.\n\n## Don't\n- Don't change the easing function\n- Don't change the DeferWindowPos/BeginDeferWindowPos/EndDeferWindowPos API calls\n- Don't change the layoutStack() method\n- Don't change the final snap logic\n- Don't add any new dependencies\n- Don't use requestAnimationFrame (not available in main process)","acceptance_criteria":"1. _animateLayout uses Date.now() to compute progress as (elapsed / DURATION)\n2. Uses recursive setTimeout instead of setInterval\n3. _stopAnimation uses clearTimeout\n4. Animation still completes in ~200ms with cubic ease-out\n5. Final snap to exact target positions still occurs\n6. Error fallback to instant SetWindowPos still works\n7. App launches without errors and window transitions animate smoothly when switching between 2+ managed windows","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-22T04:31:35Z","created_by":"unknown","updated_at":"2026-02-22T04:39:34Z","closed_at":"2026-02-22T04:39:34Z","close_reason":"9bf0eb5 Refactor _animateLayout to use timestamp-based progress via recursive setTimeout and Date.now()","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.1","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:31:35Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.2","title":"Add animated window removal with slide-to-original-position effect","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nCurrently _restoreWindow() (lines 420-434) uses a single SetWindowPos call to instantly snap a removed window back to its original position. This is jarring compared to the smooth add/activate animations.\n\nCreate a new method _animateRestore(entry, callback) that:\n1. Gets the window's current position via GetWindowRect\n2. Computes target position from entry.originalRect (same logic as current _restoreWindow)\n3. Runs a standalone animation (NOT using _animateLayout, because that would conflict with the main layout animation) using the same timestamp-based approach from task 1\n4. Uses a SEPARATE timer reference (e.g. this._restoreAnimationTimer) so it doesn't cancel the main layout animation\n5. Duration: 250ms (slightly longer than layout animation for visual distinction)\n6. Easing: same cubic ease-out\n7. Uses single SetWindowPos per frame (not DeferWindowPos, since it's only one window)\n8. On the final frame, sets HWND_NOTOPMOST (same as current _restoreWindow)\n9. Calls callback() when animation completes (so removeWindow can chain doLayout after)\n\nModify removeWindow() (lines 150-164):\n- Instead of calling this._restoreWindow(entry), call this._animateRestore(entry, () =\u003e {})\n- The doLayout() call in main.js (line 155) already handles re-laying out remaining windows\n\nModify restoreAll() (lines 222-228):\n- Keep using instant _restoreWindow for restoreAll (app quit scenario - no time for animation)\n- Add a comment explaining why restoreAll stays instant\n\nAdd _stopRestoreAnimation() method similar to _stopAnimation() but for the restore timer.\nCall _stopRestoreAnimation() at the beginning of _animateRestore() to cancel any in-flight restore.\n\n## Don't\n- Don't modify _animateLayout or layoutStack\n- Don't use DeferWindowPos for single-window restore animation\n- Don't animate restoreAll() (app is quitting, no time)\n- Don't change the persistence format\n- Don't change the originalRect storage logic","acceptance_criteria":"1. removeWindow() triggers a smooth 250ms animation sliding the window back to its originalRect position\n2. The animation uses cubic ease-out easing\n3. The animation uses HWND_NOTOPMOST on the final frame\n4. restoreAll() still uses instant snap (no animation)\n5. A separate timer (_restoreAnimationTimer) is used, not conflicting with _animationTimer\n6. Remaining managed windows re-layout correctly after removal animation\n7. Removing a window while another removal is animating cancels the first and starts the new one\n8. App launches without errors; removing a window from a 3-window stack shows smooth slide-out","status":"open","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":50,"created_at":"2026-02-22T04:31:52Z","created_by":"unknown","updated_at":"2026-02-22T04:31:52Z","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.2","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:31:51Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-17p.2","depends_on_id":"StackWindowsElectron-17p.1","type":"blocks","created_at":"2026-02-21T22:33:22Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.3","title":"Add SWP_NOZORDER flag to intermediate animation frames","description":"## Files\n- src/main/window-manager.js (modify)\n- src/main/win32.js (verify SWP_NOZORDER is exported — it already is at line 47/69)\n\n## What to do\nIn _animateLayout(), every animation frame calls DeferWindowPos with HWND_TOP, which re-issues a Z-order change for every window on every frame. This is redundant and can cause flicker on some systems.\n\nModify the animation loop in _animateLayout():\n1. On the FIRST frame (progress close to 0 or first iteration): use HWND_TOP and the existing flags (set Z-order)\n2. On INTERMEDIATE frames (not first, not last): add SWP_NOZORDER to the flags passed to DeferWindowPos, and pass 0 (or any value, it's ignored with SWP_NOZORDER) for hWndInsertAfter\n3. On the FINAL frame (the snap at the end): use HWND_TOP without SWP_NOZORDER (re-assert Z-order)\n\nImplementation approach:\n- Import SWP_NOZORDER from win32.js (already exported, line 69)\n- Add it to the destructured imports at the top of window-manager.js (line 5-8)\n- In the animation loop, add a boolean isFirstFrame tracked by a variable\n- For intermediate frames: flags = layout.flags | SWP_NOZORDER, and use 0 as hWndInsertAfter\n- The final snap block (lines 317-327) already uses HWND_TOP, keep it as-is\n\n## Don't\n- Don't change the first frame behavior (must set Z-order on first frame)\n- Don't change the final snap behavior\n- Don't change the easing or timing\n- Don't modify win32.js (SWP_NOZORDER is already exported)\n- Don't change layoutStack()","acceptance_criteria":"1. SWP_NOZORDER is imported in window-manager.js destructured imports\n2. First animation frame uses HWND_TOP without SWP_NOZORDER (sets Z-order)\n3. Intermediate frames (not first, not last) include SWP_NOZORDER in flags\n4. Final snap frame uses HWND_TOP without SWP_NOZORDER\n5. App launches without errors; switching between 3 managed windows animates without visible flicker\n6. Z-order is correct: active window on top, inactive windows behind in strip order","status":"open","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-22T04:32:06Z","created_by":"unknown","updated_at":"2026-02-22T04:32:06Z","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.3","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:32:06Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-17p.3","depends_on_id":"StackWindowsElectron-17p.1","type":"blocks","created_at":"2026-02-21T22:33:22Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.4","title":"Add debounce to doLayout to prevent animation restart jank on rapid triggers","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nCurrently, doLayout() (lines 75-88) is called directly from multiple triggers: foreground monitor (every 200ms), add-window, remove-window, activate-window, resize, and dead-window cleanup. When the user rapidly Alt-Tabs between managed windows, multiple doLayout() calls can fire within a single 200ms animation duration, causing _animateLayout to restart from scratch each time (jerky motion).\n\nAdd a debounce wrapper around doLayout:\n1. Create a module-level variable: let _layoutDebounceTimer = null;\n2. Create a new function doLayoutDebounced() that:\n   - Clears any pending _layoutDebounceTimer\n   - Sets _layoutDebounceTimer = setTimeout(() =\u003e { doLayout(); }, 16) — 16ms debounce (one frame at 60fps)\n   - This coalesces multiple rapid calls into a single layout pass\n3. Replace doLayout() calls with doLayoutDebounced() in these specific locations:\n   - onManagedWindowFocused (line 103) — this is the main rapid-fire source\n   - The cleanup timer callback (line 298)\n4. Keep doLayout() (NOT debounced) for these locations where immediate response is needed:\n   - add-window IPC handler (line 141) — user explicitly added, should respond immediately\n   - remove-window IPC handler (line 155) — user explicitly removed\n   - activate-window IPC handler (line 170) — user explicitly clicked\n   - resize event (line 49) — window is being resized, needs immediate feedback\n   - Initial layout setTimeout (line 289) — startup, only fires once\n5. Clean up _layoutDebounceTimer in the window-all-closed handler (line 312)\n\n## Don't\n- Don't modify window-manager.js\n- Don't modify foreground-monitor.js\n- Don't change the debounce delay to more than 50ms (would introduce perceptible lag)\n- Don't debounce the user-initiated actions (add, remove, activate, resize)\n- Don't use any external debounce library","acceptance_criteria":"1. A doLayoutDebounced() function exists that debounces with ~16ms delay\n2. onManagedWindowFocused uses doLayoutDebounced() instead of doLayout()\n3. Dead window cleanup timer uses doLayoutDebounced()\n4. add-window, remove-window, activate-window IPC handlers still use direct doLayout()\n5. resize event still uses direct doLayout()\n6. _layoutDebounceTimer is cleared in window-all-closed handler\n7. App launches without errors; rapid Alt-Tab between 3 managed windows produces smooth animation without visible jank/restart","status":"closed","priority":1,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-22T04:32:20Z","created_by":"unknown","updated_at":"2026-02-22T04:39:25Z","closed_at":"2026-02-22T04:39:25Z","close_reason":"41be2f3 Add debounce to doLayout to prevent animation restart jank","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.4","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:32:20Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.5","title":"Make animation duration and easing configurable via constructor options","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nCurrently DURATION (200ms) and the easing function are hardcoded inside _animateLayout(). Extract them as configurable options on the WindowManager class for future flexibility and easier tuning.\n\n1. Add an options parameter to the WindowManager constructor with defaults:\n   constructor(options = {}) {\n     // ... existing code ...\n     this.animationDuration = options.animationDuration || 200;  // ms\n     this.animationEasing = options.animationEasing || 'ease-out-cubic';\n     this.restoreAnimationDuration = options.restoreAnimationDuration || 250; // ms\n   }\n\n2. Create a private method _applyEasing(progress) that maps a string name to an easing function:\n   - 'ease-out-cubic': 1 - Math.pow(1 - progress, 3)  (current default)\n   - 'ease-in-out-cubic': progress \u003c 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2\n   - 'linear': progress\n   Returns the eased value.\n\n3. In _animateLayout(), replace:\n   - const DURATION = 200; → use this.animationDuration\n   - const ease = 1 - Math.pow(1 - progress, 3); → const ease = this._applyEasing(progress);\n\n4. In _animateRestore() (from task 2, if it exists; otherwise in _restoreWindow), use this.restoreAnimationDuration.\n\n5. Do NOT change the default values — the app should behave identically with no options passed.\n\n## Don't\n- Don't change default behavior (200ms ease-out-cubic must remain the default)\n- Don't add more than 3 easing options\n- Don't expose these options via IPC or the renderer UI (internal only for now)\n- Don't change the persistence format\n- Don't modify main.js (it passes no options, gets defaults)","acceptance_criteria":"1. WindowManager constructor accepts an optional options object\n2. this.animationDuration defaults to 200 if not specified\n3. this.animationEasing defaults to 'ease-out-cubic' if not specified\n4. this.restoreAnimationDuration defaults to 250 if not specified\n5. _applyEasing('ease-out-cubic', 0.5) returns 1 - Math.pow(0.5, 3) = 0.875\n6. _applyEasing('linear', 0.5) returns 0.5\n7. _applyEasing('ease-in-out-cubic', 0.5) returns 0.5\n8. App launches without errors with no options passed to WindowManager()\n9. Animation behavior is identical to before (same duration, same easing)","status":"open","priority":3,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-22T04:32:36Z","created_by":"unknown","updated_at":"2026-02-22T04:32:36Z","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.5","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:32:35Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-17p.5","depends_on_id":"StackWindowsElectron-17p.1","type":"blocks","created_at":"2026-02-21T22:33:23Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-17p.5","depends_on_id":"StackWindowsElectron-17p.2","type":"blocks","created_at":"2026-02-21T22:33:24Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.6","title":"Add CSS transitions to managed window list in renderer","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\nCurrently renderManaged() (lines 505-563) destroys and recreates all DOM elements on every update via container.innerHTML = ''. This causes the list to 'jump' visually with no transition. Add smooth CSS transitions for managed window list items.\n\n### CSS Changes (add to the \u003cstyle\u003e block):\n1. Add transition to .managed-item for border-left-color and background:\n   .managed-item {\n     transition: border-left-color 0.2s ease, background-color 0.2s ease;\n   }\n\n2. Add a fade-in animation for new items:\n   @keyframes fadeSlideIn {\n     from { opacity: 0; transform: translateX(-8px); }\n     to { opacity: 1; transform: translateX(0); }\n   }\n   .window-item.entering {\n     animation: fadeSlideIn 0.2s ease forwards;\n   }\n\n### JavaScript Changes to renderManaged():\nReplace the current 'destroy all and recreate' approach with a DOM-diffing strategy:\n\n1. Build a Map of existing DOM items keyed by hwnd (data-hwnd attribute)\n2. Build the new desired list of hwnds from managedWindows\n3. For each window in managedWindows:\n   a. If a DOM element with matching data-hwnd exists: UPDATE it in place (change classes, badge text, etc.)\n   b. If no matching DOM element exists: CREATE a new element with class 'entering'\n4. Remove DOM elements whose hwnd is no longer in managedWindows\n5. Reorder DOM elements to match the managedWindows array order using insertBefore\n\nEach .window-item must have a data-hwnd attribute set to the window's hwnd for identification.\n\n### Key details:\n- The 'entering' class triggers the fadeSlideIn animation\n- The active/inactive class swap triggers the CSS transition on border-left-color and background\n- Remove the 'entering' class after animation ends (use animationend event listener)\n- Keep the empty state rendering (innerHTML for empty state is fine)\n\n## Don't\n- Don't use any framework or virtual DOM library\n- Don't change the visual appearance of items (colors, sizes, fonts must stay the same)\n- Don't modify the available windows list rendering (only managed list)\n- Don't change the IPC communication\n- Don't add transitions longer than 300ms","acceptance_criteria":"1. Managed window items have data-hwnd attributes\n2. When active window changes, the border-left-color and background transition smoothly (0.2s)\n3. When a new window is added to the stack, it fades/slides in from the left\n4. When a window is removed from the stack, its DOM element is removed (no exit animation required)\n5. DOM elements are reused when possible (not destroyed and recreated on every update)\n6. Empty state still renders correctly when all windows are removed\n7. The 'entering' class is removed after animation completes\n8. App launches without errors; adding/removing/switching windows shows smooth list transitions","status":"closed","priority":2,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-22T04:32:51Z","created_by":"unknown","updated_at":"2026-02-22T04:40:24Z","closed_at":"2026-02-22T04:40:24Z","close_reason":"3f1a10b Add CSS transitions and DOM-diffing to managed window list","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.6","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:32:51Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.7","title":"Fix stale comments about activate-window IPC handler","description":"## Files\n- src/main/main.js (modify)\n- src/renderer/index.html (modify)\n\n## What to do\nThere are stale/contradictory comments in the codebase about the activate-window IPC handler:\n\n### main.js fixes:\n1. Line 109-110: Comment says 'Register IPC handlers — NO activate-window handler. Activation is driven by Win32 focus detection, not Electron.'\n   But line 165 registers an 'activate-window' handler that calls promoteToActive(hwnd, true).\n   \n   Replace the comment at lines 109-110 with:\n   // Register IPC handlers.\n   // Activation is primarily driven by Win32 focus detection (ForegroundMonitor),\n   // but an activate-window handler also exists for explicit UI-driven activation.\n\n2. Line 96-99: Comment says 'Called by ForegroundMonitor when a managed window gains OS focus. This is the ONLY activation path — driven by real Win32 focus, not Electron UI.'\n   This is false — the activate-window IPC handler (line 165) is another activation path.\n   \n   Replace with:\n   // Called by ForegroundMonitor when a managed window gains OS focus.\n   // This is the primary activation path. A secondary path exists via the\n   // 'activate-window' IPC handler for explicit UI-driven activation.\n\n### index.html fixes:\n1. Line 603: Comment says '// API calls — NO activateWindow. Activation is Win32-driven.'\n   But activateWindow() function exists at line 678 and is called from line 524.\n   \n   Replace with:\n   // API calls — activation is primarily Win32-driven, with UI fallback via activateWindow().\n\n## Don't\n- Don't change any code logic, only comments\n- Don't add new comments beyond what's specified\n- Don't reformat or restructure the code\n- Don't change any function signatures or behavior","acceptance_criteria":"1. Comment at main.js line 109-110 accurately describes that activate-window handler exists\n2. Comment at main.js line 96-99 mentions both activation paths (foreground monitor + IPC)\n3. Comment at index.html line 603 acknowledges activateWindow() exists\n4. No code logic changes — only comment text changes\n5. App launches without errors","status":"closed","priority":3,"issue_type":"task","assignee":"unknown","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-22T04:33:06Z","created_by":"unknown","updated_at":"2026-02-22T04:39:51Z","closed_at":"2026-02-22T04:39:51Z","close_reason":"5db73cd Fix stale comments about activate-window IPC handler","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.7","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:33:06Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-17p.8","title":"Add animation-in-progress guard to prevent layout calls during active animation","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nCurrently _animateLayout() always cancels any in-progress animation and starts fresh. While the debounce in main.js (task 4) reduces the frequency of calls, there's still a case where layoutStack() is called while an animation is running and the new target positions are identical to the current targets (e.g., dead window cleanup finds no changes but doLayout still fires).\n\nAdd an optimization to skip redundant animations:\n\n1. Add a property this._currentTargets = null in the constructor\n2. At the start of _animateLayout(targetLayouts), before calling _stopAnimation():\n   - Serialize the target layouts into a comparable key: targetLayouts.map(t =\u003e t.hwnd + ':' + t.x + ',' + t.y + ',' + t.cx + ',' + t.cy).join('|')\n   - Compare with this._currentTargets\n   - If identical AND an animation is currently running (this._animationTimer !== null), return early (skip — already animating to these targets)\n3. If different or no animation running, proceed as normal and store the new key in this._currentTargets\n4. In _stopAnimation(), set this._currentTargets = null (animation completed, targets are reached)\n\nThis prevents unnecessary animation restarts when the target layout hasn't actually changed.\n\n## Don't\n- Don't skip animation when targets have changed (only skip when identical)\n- Don't modify layoutStack()\n- Don't modify main.js\n- Don't add any external dependencies\n- Don't change the animation timing or easing","acceptance_criteria":"1. this._currentTargets is initialized to null in constructor\n2. _animateLayout skips (returns early) when called with identical targets while animation is running\n3. _animateLayout proceeds normally when targets differ from current animation\n4. _animateLayout proceeds normally when no animation is running (even with same targets)\n5. _stopAnimation resets this._currentTargets to null\n6. App launches without errors; switching between windows still animates correctly\n7. Console.log or lack of animation restart confirms redundant calls are skipped","status":"open","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-22T04:33:18Z","created_by":"unknown","updated_at":"2026-02-22T04:33:18Z","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-17p.8","depends_on_id":"StackWindowsElectron-17p","type":"parent-child","created_at":"2026-02-21T22:33:18Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-17p.8","depends_on_id":"StackWindowsElectron-17p.1","type":"blocks","created_at":"2026-02-21T22:33:24Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-3go","title":"Epic: Fix custom dimensions, fix Hide behavior, add background color picker","description":"Tres problemas a resolver: (1) Custom dimensions no tiene efecto visible - el IPC funciona pero el layout no refleja los cambios porque setCustomDimensions recibe los valores correctamente y doLayout se llama, pero el problema es que availableWidth ya es menor o igual al customWidth solicitado, o hay un issue con el flujo. Necesita debugging y fix. (2) El boton Hide oculta la lista de managed windows ademas de available windows - solo deberia ocultar available windows. (3) Agregar un boton de color picker para cambiar el color de fondo de la pila administrativa, persistente entre sesiones.","status":"open","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-20T23:38:55Z","created_by":"unknown","updated_at":"2026-02-20T23:38:55Z","labels":["scope:medium"]}
{"id":"StackWindowsElectron-3go.1","title":"Fix custom dimensions sin efecto - debug y corregir layoutStack","description":"## Files\n- src/main/window-manager.js (modify)\n- src/main/main.js (modify) - posiblemente para agregar logging\n\n## What to do\nEl flujo IPC funciona: set-custom-dimensions llama setCustomDimensions(), luego doLayout(), pero las ventanas no cambian de tamano. \n\n### Analisis de la causa raiz\nEn layoutStack() linea 231: startX = workArea.x + workArea.width. Aqui workArea.x es la posicion X de mainWindow (bounds.x), y workArea.width es el ancho de mainWindow. Entonces startX = borde derecho de la pila administrativa.\n\nLinea 235-238: displayRightEdge viene de main.js como workArea.x + workArea.width del DISPLAY. availableWidth = displayRightEdge - startX. Este es el espacio entre el borde derecho de la pila admin y el borde derecho del monitor.\n\nLinea 242-244: effectiveWidth = Math.min(customWidth, availableWidth). Si customWidth (ej 800) \u003c availableWidth (ej 1620), deberia usar 800.\n\nEl PROBLEMA real: effectiveWidth SI se calcula bien, pero las ventanas de Windows tienen un tamano minimo impuesto por el OS. Ademas, SetWindowPos puede estar siendo sobreescrito por el timer de cleanup (cada 2s) o el resize handler de mainWindow que llama doLayout() sin custom dims.\n\n### Verificacion y fix\n1. Agregar console.log temporal en layoutStack() para imprimir: customWidth, customHeight, availableWidth, availableHeight, effectiveWidth, effectiveHeight justo antes de los SetWindowPos calls.\n2. Verificar que setCustomDimensions realmente guarda los valores (no los pierde por un race condition).\n3. Si el problema es que doLayout se llama desde el resize handler de mainWindow y este sobreescribe, verificar que customWidth/customHeight persisten entre llamadas a layoutStack.\n4. Agregar un console.log en el IPC handler set-custom-dimensions para confirmar que los valores llegan.\n5. Una vez identificado el bug exacto, corregirlo.\n6. REMOVER los console.log de debug despues de confirmar el fix.\n\n### Posible causa alternativa\nEl resize event de mainWindow (linea 48 de main.js) llama doLayout() que a su vez llama layoutStack(). Si el usuario cambia las dimensiones y luego mueve/resize la ventana admin, se re-aplica el layout con los custom dims. Pero si NO hay un trigger de re-layout despues del set-custom-dimensions... verificar que doLayout() SI se llama en el handler IPC (linea 216 de main.js - SI se llama).\n\n## Don't\n- No cambiar la logica de IPC\n- No cambiar la UI\n- No remover la funcionalidad de custom dimensions, solo hacerla funcionar","acceptance_criteria":"1. Establecer customWidth=800 customHeight=600 via Apply en la UI y las ventanas administradas se redimensionan visiblemente a 800x600 o menos. 2. Las ventanas no vuelven a su tamano anterior despues de un ciclo de cleanup (2s). 3. Reset vuelve las ventanas al tamano completo del espacio disponible.","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-20T23:39:20Z","created_by":"unknown","updated_at":"2026-02-20T23:48:45Z","closed_at":"2026-02-20T23:48:45Z","close_reason":"a4c944c fix: restore maximized windows before SetWindowPos so custom dimensions take effect","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-3go.1","depends_on_id":"StackWindowsElectron-3go","type":"parent-child","created_at":"2026-02-20T17:39:20Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-3go.2","title":"Fix Hide button - solo debe ocultar Available Windows, no Managed Stack","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\nEl boton Hide en la seccion Available Windows actualmente oculta la lista de managed windows (pestanas de la pila administrativa) ademas de la lista de available windows. Solo debe ocultar la seccion de Available Windows.\n\n### Causa raiz\nEn toggleAvailableVisibility() (linea 439), cuando isAvailableHidden=true, se calcula un targetHeight que es demasiado pequeno. El calculo en lineas 458-483 usa querySelectorAll('.section') y asume que sections[0] es managed y sections[1] es available. PERO ahora hay 3 secciones .section (dimensions-section, managed, available), asi que los indices estan desfasados.\n\nAdemas, el calculo de targetHeight no incluye la altura de la seccion dimensions-section ni su divider.\n\n### Fix\n1. Cambiar la logica de calculo de targetHeight para que sea robusta:\n   - Sumar la altura de TODOS los elementos visibles excepto el availableList\n   - O mejor: en vez de calcular un targetHeight exacto y hacer resizeApp, simplemente ocultar la seccion completa de Available Windows (el div.section que contiene availableList) y dejar que flexbox maneje el layout naturalmente SIN hacer resizeApp\n2. Alternativa mas simple y robusta: NO llamar resizeApp al ocultar. Solo ocultar el div availableList con display:none. La ventana de Electron mantiene su tamano y el espacio se redistribuye via flexbox.\n3. Elegir la alternativa 2: solo ocultar/mostrar availableList sin redimensionar la ventana de Electron. Esto evita el bug de calculo de alturas.\n\n### Implementacion concreta\n- En toggleAvailableVisibility(), cuando isAvailableHidden=true:\n  - listEl.classList.add('hidden') (ya existe)\n  - btn.textContent = 'Show' (ya existe)\n  - ELIMINAR todo el bloque setTimeout que calcula targetHeight y llama resizeApp\n- Cuando isAvailableHidden=false:\n  - listEl.classList.remove('hidden') (ya existe)\n  - btn.textContent = 'Hide' (ya existe)  \n  - ELIMINAR la llamada a resizeApp que restaura expandedHeight\n- Eliminar la variable expandedHeight ya que no se usa mas\n- Mantener la llamada a toggleAvailableVisibility IPC para persistir el estado\n\n## Don't\n- No tocar la seccion Managed Stack\n- No tocar la seccion Dimensions\n- No cambiar el comportamiento de persistencia del estado hideAvailable","acceptance_criteria":"1. Al hacer clic en Hide, solo se oculta la lista de Available Windows. La lista de Managed Stack (pestanas) sigue visible. 2. Al hacer clic en Show, la lista de Available Windows reaparece. 3. La seccion Dimensions no se ve afectada por Hide/Show. 4. El estado hideAvailable se persiste correctamente.","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-20T23:39:37Z","created_by":"unknown","updated_at":"2026-02-20T23:41:02Z","closed_at":"2026-02-20T23:41:02Z","close_reason":"5d63289 Fix Hide button - remove resizeApp from toggleAvailableVisibility","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-3go.2","depends_on_id":"StackWindowsElectron-3go","type":"parent-child","created_at":"2026-02-20T17:39:36Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-3go.3","title":"Agregar color picker para fondo de la pila administrativa","description":"## Files\n- src/renderer/index.html (modify)\n- src/main/window-manager.js (modify)\n- src/main/main.js (modify)\n- src/main/preload.js (modify)\n- src/main/persistence.js (modify)\n\n## What to do\nAgregar un boton en el header de la pila administrativa que abra un color picker nativo del navegador (input type=color) para elegir el color de fondo de la app. El color debe persistir entre sesiones.\n\n### window-manager.js\n- Agregar this.backgroundColor = '#000000' al constructor (negro por defecto, el color actual)\n- Agregar setBackgroundColor(color): valida que sea un string hex valido (#RRGGBB), guarda en this.backgroundColor\n- Agregar getBackgroundColor(): retorna this.backgroundColor\n- Incluir backgroundColor en getState()\n- Leer backgroundColor en loadState() con fallback a '#000000'\n\n### persistence.js\n- En save(): agregar backgroundColor: state.backgroundColor || '#000000'\n- En load() v2: agregar backgroundColor: data.backgroundColor || '#000000'\n- En load() v1 migration: agregar backgroundColor: '#000000'\n\n### main.js\n- Agregar IPC handler 'set-background-color': llama windowManager.setBackgroundColor(color), sendStateUpdate(), persistence.save()\n- Agregar IPC handler 'get-background-color': retorna windowManager.getBackgroundColor()\n- En sendStateUpdate(): incluir backgroundColor en el objeto enviado\n- En get-managed-windows handler: incluir backgroundColor\n\n### preload.js\n- Exponer setBackgroundColor: (color) =\u003e ipcRenderer.invoke('set-background-color', color)\n- Exponer getBackgroundColor: () =\u003e ipcRenderer.invoke('get-background-color')\n\n### index.html\n- En el header div, agregar un boton pequeno (icono de paleta o cuadrado de color) al lado derecho del titulo\n- Al hacer clic, abrir un input type=color oculto (trigger via click programatico)\n- Al seleccionar un color (evento change del input), llamar window.electronAPI.setBackgroundColor(color) y aplicar document.body.style.backgroundColor = color\n- En onStateUpdate: si data.backgroundColor, aplicar document.body.style.backgroundColor = data.backgroundColor\n- En refreshManaged (init): si result.backgroundColor, aplicar el color\n- CSS del boton: cuadrado de 16x16px con borde #444, el background del boton es el color actual, posicionado en el header con float right o flex\n\n## Don't\n- No usar librerias externas de color picker, usar el nativo input type=color\n- No cambiar el color de texto (solo el fondo)\n- No afectar el color de las ventanas administradas (solo la UI de la pila admin)","acceptance_criteria":"1. Un boton de color aparece en el header de la app. 2. Al hacer clic se abre el color picker nativo del OS. 3. Al elegir un color, el fondo de la app cambia inmediatamente. 4. El color persiste al reiniciar la app. 5. El color por defecto es negro (#000000).","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":40,"created_at":"2026-02-20T23:39:52Z","created_by":"unknown","updated_at":"2026-02-20T23:42:31Z","closed_at":"2026-02-20T23:42:31Z","close_reason":"a3f4331 Add background color picker to admin stack header","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-3go.3","depends_on_id":"StackWindowsElectron-3go","type":"parent-child","created_at":"2026-02-20T17:39:51Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5","title":"Epic: Dimensiones personalizables de ventanas + Fix multi-monitor","description":"Las ventanas administradas actualmente ocupan todo el espacio libre de la pantalla. Cuando se usa un segundo monitor en proyeccion ampliada (monitor secundario a la izquierda del principal), las ventanas se extienden abarcando ambos monitores. Causa raiz: layoutStack() usa getPrimaryDisplay() hardcodeado en vez de detectar el monitor donde corre la app. Objetivo: (1) Corregir deteccion de monitor para que las ventanas solo ocupen el monitor donde esta la pila administrativa. (2) Permitir al usuario personalizar ancho y alto de las ventanas administradas desde la UI, aplicando esas dimensiones a todas las ventanas del stack. (3) Persistir las dimensiones custom. Exito: el usuario puede redimensionar sus ventanas administradas y la app funciona correctamente en configuraciones multi-monitor.","status":"open","priority":1,"issue_type":"epic","owner":"paulhernandezdominguez10@gmail.com","created_at":"2026-02-20T23:13:23Z","created_by":"unknown","updated_at":"2026-02-20T23:13:23Z","labels":["needs-integration-review","scope:medium"]}
{"id":"StackWindowsElectron-fv5.1","title":"Fix deteccion de monitor - layoutStack usa getPrimaryDisplay hardcodeado","description":"## Files\n- src/main/main.js (modify)\n- src/main/window-manager.js (modify)\n\n## What to do\n### main.js - getWorkArea() y doLayout()\n- Cambiar getWorkArea() para que reciba opcionalmente un punto {x, y} y use screen.getDisplayNearestPoint() en vez de screen.getPrimaryDisplay(). Si no recibe punto, usar getPrimaryDisplay() como fallback.\n- En doLayout(), obtener bounds de mainWindow, luego llamar screen.getDisplayNearestPoint({ x: bounds.x, y: bounds.y }) para obtener el display correcto. Pasar el workArea de ESE display.\n- Agregar propiedad displayRightEdge al objeto que se pasa a layoutStack: displayRightEdge = display.workArea.x + display.workArea.width\n\n### window-manager.js - layoutStack()\n- Eliminar la linea 232: const primaryDisplay = require('electron').screen.getPrimaryDisplay()\n- Eliminar la linea 233: const screenRightEdge = primaryDisplay.workArea.x + primaryDisplay.workArea.width\n- En su lugar, leer screenBounds.displayRightEdge para calcular availableWidth: const availableWidth = screenBounds.displayRightEdge - startX\n- Si displayRightEdge no viene en screenBounds (backward compat), fallback a calcular con el ancho de pantalla: availableWidth = 1920 - startX\n\n## Don't\n- No cambiar la logica de strips ni de ventana activa\n- No tocar foreground-monitor.js\n- No importar electron/screen dentro de window-manager.js (recibirlo como parametro)","acceptance_criteria":"1. Cuando la app corre en un monitor secundario (izquierda del principal), las ventanas administradas ocupan solo el espacio libre de ESE monitor, no se extienden al primario. 2. Cuando la app corre en el monitor primario, el comportamiento es identico al actual. 3. availableWidth nunca es negativo ni mayor que el ancho del monitor donde esta la app.","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":30,"created_at":"2026-02-20T23:13:39Z","created_by":"unknown","updated_at":"2026-02-20T23:17:31Z","closed_at":"2026-02-20T23:17:31Z","close_reason":"64e47a3 Fix multi-monitor: use getDisplayNearestPoint instead of getPrimaryDisplay","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.1","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:13:39Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.2","title":"Agregar estado customWidth/customHeight al WindowManager","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\n### Constructor\n- Agregar this.customWidth = null y this.customHeight = null. null significa usar todo el espacio disponible (comportamiento actual).\n\n### Nuevos metodos\n- setCustomDimensions(width, height): Si width no es null, clampear a Math.max(200, Number(width)). Si height no es null, clampear a Math.max(200, Number(height)). Si es null, guardar null. Guardar en this.customWidth y this.customHeight.\n- getCustomDimensions(): retorna { customWidth: this.customWidth, customHeight: this.customHeight }\n\n### getState()\n- Incluir customWidth: this.customWidth y customHeight: this.customHeight en el objeto retornado.\n\n### loadState()\n- Leer savedState.customWidth y savedState.customHeight. Si existen y no son null, asignarlos (con el mismo clamp de 200 minimo). Si no existen, dejar null.\n\n## Don't\n- No modificar layoutStack() todavia (eso es otra tarea)\n- No tocar la UI\n- No tocar preload.js ni main.js","acceptance_criteria":"1. setCustomDimensions(800, 600) guarda los valores; getCustomDimensions() retorna { customWidth: 800, customHeight: 600 }. 2. setCustomDimensions(null, null) resetea ambos a null. 3. setCustomDimensions(50, 50) clampea a { customWidth: 200, customHeight: 200 }. 4. getState() incluye customWidth y customHeight. 5. loadState({ customWidth: 900, customHeight: 700, windows: [] }) restaura los valores correctamente.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-20T23:13:48Z","created_by":"unknown","updated_at":"2026-02-20T23:17:52Z","closed_at":"2026-02-20T23:17:52Z","close_reason":"c03d80b Add customWidth/customHeight state to WindowManager","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.2","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:13:48Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.3","title":"Fix bug mainWindow null en restauracion de bounds al iniciar","description":"## Files\n- src/main/main.js (modify)\n\n## What to do\nEn app.whenReady(), hay un bug critico: en las lineas 220-228 se intenta hacer mainWindow.setBounds(savedState.bounds) pero createWindow() se llama DESPUES en la linea 240, por lo que mainWindow es null en ese punto.\n\n### Fix\n- Mover el bloque de restauracion de bounds (lineas 220-228) DESPUES de la llamada a createWindow() (linea 240).\n- El orden correcto debe ser:\n  1. persistence.init() + persistence.load()\n  2. windowManager = new WindowManager() + windowManager.loadState()\n  3. createWindow()  \u003c-- crea mainWindow\n  4. if (savedState.bounds) mainWindow.setBounds(savedState.bounds)  \u003c-- ahora mainWindow existe\n  5. foregroundMonitor.start()\n  6. registerIPC()\n\n## Don't\n- No cambiar la logica de persistencia\n- No cambiar el orden de inicializacion de windowManager o foregroundMonitor respecto a createWindow, solo mover el setBounds despues de createWindow\n- No agregar try/catch innecesarios, el bloque ya tiene validacion de savedState.bounds","acceptance_criteria":"1. La app no crashea al iniciar con un window-group.json que contiene bounds validos. 2. La app no crashea al iniciar con un window-group.json que tiene bounds: null. 3. Los bounds guardados se restauran correctamente al reiniciar (la ventana aparece en la posicion/tamano guardado).","status":"closed","priority":1,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":10,"created_at":"2026-02-20T23:13:58Z","created_by":"unknown","updated_at":"2026-02-20T23:17:44Z","closed_at":"2026-02-20T23:17:44Z","close_reason":"235af5b fix: move setBounds after createWindow to prevent null mainWindow crash","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.3","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:13:58Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.4","title":"Integrar dimensiones custom en layoutStack","description":"## Files\n- src/main/window-manager.js (modify)\n\n## What to do\nEn layoutStack(), despues de calcular availableWidth y availableHeight (ya corregidos por la tarea de fix multi-monitor), aplicar las dimensiones custom:\n\n### Ancho efectivo\n- Si this.customWidth !== null: effectiveWidth = Math.min(this.customWidth, availableWidth)\n- Si this.customWidth === null: effectiveWidth = availableWidth (comportamiento actual)\n\n### Alto efectivo\n- Si this.customHeight !== null: effectiveHeight = Math.min(this.customHeight, availableHeight)\n- Si this.customHeight === null: effectiveHeight = availableHeight (comportamiento actual)\n\n### Aplicar a SetWindowPos\n- Reemplazar todas las referencias a availableWidth por effectiveWidth en las llamadas a SetWindowPos (tanto para strips como para ventana activa)\n- Reemplazar availableHeight por effectiveHeight donde corresponda\n- La ventana activa: activeHeight = effectiveHeight - (inactiveCount * HEADER_HEIGHT)\n- Los strips: se posicionan con effectiveWidth de ancho y effectiveHeight de alto (para que el cuerpo quede oculto detras de la ventana activa)\n\n### Posicionamiento\n- startX no cambia (las ventanas siguen alineadas al borde derecho de la pila administrativa)\n\n## Don't\n- No cambiar el orden Z ni la logica de activacion (promoteToActive, etc)\n- No centrar las ventanas horizontalmente\n- No modificar HEADER_HEIGHT ni CONTROLLER_WIDTH","acceptance_criteria":"1. Con customWidth=800 y customHeight=600, todas las ventanas administradas tienen maximo 800px de ancho y el conjunto ocupa maximo 600px de alto. 2. Con customWidth=null y customHeight=null, se usa todo el espacio disponible del monitor (comportamiento identico al actual). 3. El ancho custom nunca excede el espacio disponible real del monitor (Math.min). 4. Los strips siguen mostrando HEADER_HEIGHT px de preview cada uno.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":40,"created_at":"2026-02-20T23:14:13Z","created_by":"unknown","updated_at":"2026-02-20T23:18:59Z","closed_at":"2026-02-20T23:18:59Z","close_reason":"Implemented effectiveWidth/effectiveHeight in layoutStack using Math.min(customDim, available)","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.4","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:14:12Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.4","depends_on_id":"StackWindowsElectron-fv5.1","type":"blocks","created_at":"2026-02-20T17:15:34Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.4","depends_on_id":"StackWindowsElectron-fv5.2","type":"blocks","created_at":"2026-02-20T17:15:35Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.5","title":"IPC handlers y preload para dimensiones custom","description":"## Files\n- src/main/main.js (modify)\n- src/main/preload.js (modify)\n\n## What to do\n### main.js - Nuevos IPC handlers\nAgregar dentro de registerIPC():\n\n1. ipcMain.handle('set-custom-dimensions', async (event, width, height) =\u003e { ... })\n   - Llamar windowManager.setCustomDimensions(width, height)\n   - Llamar doLayout()\n   - Llamar sendStateUpdate()\n   - Llamar persistence.save(windowManager.getState())\n   - Retornar { success: true }\n   - Wrap en try/catch, retornar { success: false, error: e.message } en caso de error\n\n2. ipcMain.handle('get-custom-dimensions', async () =\u003e { ... })\n   - Retornar windowManager.getCustomDimensions()\n\n### main.js - sendStateUpdate()\n- Agregar customWidth y customHeight al objeto enviado via state-update:\n  const dims = windowManager.getCustomDimensions();\n  Incluir ...dims en el objeto del send (customWidth: dims.customWidth, customHeight: dims.customHeight)\n\n### preload.js\n- Agregar al objeto expuesto por contextBridge:\n  setCustomDimensions: (width, height) =\u003e ipcRenderer.invoke('set-custom-dimensions', width, height)\n  getCustomDimensions: () =\u003e ipcRenderer.invoke('get-custom-dimensions')\n\n## Don't\n- No tocar la UI (index.html)\n- No modificar handlers IPC existentes\n- No cambiar la firma de sendStateUpdate()","acceptance_criteria":"1. Desde la consola del renderer, window.electronAPI.setCustomDimensions(800, 600) cambia las dimensiones y re-aplica el layout sin error. 2. window.electronAPI.getCustomDimensions() retorna { customWidth: 800, customHeight: 600 }. 3. El evento state-update recibido en el renderer incluye customWidth y customHeight. 4. window.electronAPI.setCustomDimensions(null, null) resetea al comportamiento por defecto.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":20,"created_at":"2026-02-20T23:14:22Z","created_by":"unknown","updated_at":"2026-02-20T23:19:35Z","closed_at":"2026-02-20T23:19:35Z","close_reason":"0c14c0f Add IPC handlers and preload for custom dimensions","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.5","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:14:22Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.5","depends_on_id":"StackWindowsElectron-fv5.2","type":"blocks","created_at":"2026-02-20T17:15:35Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.6","title":"Persistencia de dimensiones custom en window-group.json","description":"## Files\n- src/main/persistence.js (modify)\n\n## What to do\n### save()\n- En el objeto data que se escribe a JSON, agregar:\n  customWidth: state.customWidth || null\n  customHeight: state.customHeight || null\n- Posicionar estos campos despues de hideAvailable y antes de bounds\n\n### load()\n- En el objeto retornado, incluir:\n  customWidth: data.customWidth || null\n  customHeight: data.customHeight || null\n- En la migracion v1 a v2, retornar customWidth: null y customHeight: null\n\n### Compatibilidad\n- NO cambiar la version del formato (sigue siendo version: 2)\n- Los campos nuevos son opcionales: si el JSON guardado no los tiene, retornar null para ambos sin error\n- La migracion v1 -\u003e v2 debe seguir funcionando\n\n## Don't\n- No cambiar el nombre del archivo (window-group.json)\n- No agregar validacion de tipos complejos, solo || null es suficiente\n- No romper la estructura existente del JSON","acceptance_criteria":"1. Guardar con dimensiones custom (800, 600) y recargar: los valores se restauran correctamente. 2. Cargar un JSON v2 antiguo (sin customWidth/customHeight): retorna null para ambos sin error. 3. Cargar un JSON v1 (array de windows): retorna null para customWidth/customHeight sin error. 4. El JSON guardado contiene los campos customWidth y customHeight.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":15,"created_at":"2026-02-20T23:14:31Z","created_by":"unknown","updated_at":"2026-02-20T23:19:20Z","closed_at":"2026-02-20T23:19:20Z","close_reason":"90c736b persist customWidth/customHeight in window-group.json","labels":["scope:trivial"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.6","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:14:31Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.6","depends_on_id":"StackWindowsElectron-fv5.2","type":"blocks","created_at":"2026-02-20T17:15:35Z","created_by":"unknown","metadata":"{}"}]}
{"id":"StackWindowsElectron-fv5.7","title":"UI - Controles de ancho y alto en el renderer","description":"## Files\n- src/renderer/index.html (modify)\n\n## What to do\n### Nueva seccion HTML\nAgregar una seccion colapsable 'DIMENSIONS' entre el header y la seccion 'MANAGED STACK'. Estructura:\n\n1. section-header con titulo 'DIMENSIONS' y boton toggle para colapsar/expandir\n2. Contenido colapsable con:\n   - Un checkbox/toggle 'Custom size' (desactivado = usar todo el espacio disponible)\n   - Dos campos en linea cuando el toggle esta activo:\n     - Input numerico 'Width' con min=200, step=10, placeholder con el ancho disponible actual\n     - Input numerico 'Height' con min=200, step=10, placeholder con el alto disponible actual\n   - Boton 'Apply' que llama window.electronAPI.setCustomDimensions(widthValue, heightValue)\n   - Boton 'Reset' que llama window.electronAPI.setCustomDimensions(null, null) y desactiva el toggle\n\n### CSS\n- Estilo consistente con el diseno existente: fondo negro (#000), texto blanco, bordes #333\n- Inputs numericos: fondo #111, borde #444, texto blanco, ancho ~70px cada uno\n- Labels: font-size 10px, color #888, uppercase\n- Seccion colapsada por defecto al iniciar\n\n### JavaScript\n- Variable global customSizeEnabled = false\n- Al recibir state-update con customWidth/customHeight no-null, activar el toggle y llenar los inputs\n- Al recibir state-update con customWidth/customHeight null, desactivar el toggle\n- El boton Apply solo se habilita cuando ambos inputs tienen valores \u003e= 200\n- Funcion toggleDimensionsSection() para colapsar/expandir (similar a toggleAvailableVisibility pero sin resize de la app)\n\n## Don't\n- No usar frameworks (mantener vanilla JS/HTML/CSS inline)\n- No agregar sliders ni range inputs, solo inputs numericos type=number\n- No permitir valores menores a 200 (validar en el onclick de Apply)\n- No modificar las secciones existentes de Managed Stack ni Available Windows\n- No llamar a resizeApp desde esta seccion","acceptance_criteria":"1. La seccion DIMENSIONS aparece entre el header y MANAGED STACK. 2. El toggle Custom size activa/desactiva los inputs. 3. Ingresar 800x600 y hacer clic en Apply llama setCustomDimensions(800, 600) y las ventanas se redimensionan. 4. Reset vuelve al comportamiento de pantalla completa (setCustomDimensions(null, null)). 5. Los valores persisten al recargar la app (se restauran desde state-update). 6. La seccion se puede colapsar/expandir. 7. Estilo visual consistente con el resto de la app.","status":"closed","priority":2,"issue_type":"task","owner":"paulhernandezdominguez10@gmail.com","estimated_minutes":45,"created_at":"2026-02-20T23:14:48Z","created_by":"unknown","updated_at":"2026-02-20T23:21:23Z","closed_at":"2026-02-20T23:21:23Z","close_reason":"Implemented DIMENSIONS collapsible section with custom size toggle, width/height inputs, Apply/Reset buttons, and state sync in src/renderer/index.html","labels":["scope:small"],"dependencies":[{"issue_id":"StackWindowsElectron-fv5.7","depends_on_id":"StackWindowsElectron-fv5","type":"parent-child","created_at":"2026-02-20T17:14:48Z","created_by":"unknown","metadata":"{}"},{"issue_id":"StackWindowsElectron-fv5.7","depends_on_id":"StackWindowsElectron-fv5.5","type":"blocks","created_at":"2026-02-20T17:15:36Z","created_by":"unknown","metadata":"{}"}]}
